{"version":3,"sources":["components/NavigationBar.tsx","components/Slider.tsx","model/util.ts","components/Graph.tsx","components/Main.tsx","components/GraphMenu.tsx","components/NodeMenu.tsx","components/Search.tsx","components/NodeCard.tsx","components/NodeDetails.tsx","components/Aside.tsx","model/sat-node.ts","model/unit.ts","model/literal.ts","model/unit-parser.ts","model/traversal.ts","model/substitution.ts","model/dag.ts","model/transformations.ts","model/callViz.js","model/viz-wrapper.ts","model/clause-orientation.ts","components/App.tsx","model/find-node.ts","components/AppWrapper.tsx","components/Menu.tsx","components/Router.tsx","serviceWorker.js","index.tsx","resources/icons/all.svg"],"names":["icons","require","NavigationBar","_React$Component","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","apply","arguments","inherits","createClass","key","value","react","id","onClick","history","back","viewBox","className","xlinkHref","concat","props","name","React","Slider","slider","_this2","_this$props","historyLength","currentTime","onCurrentTimeChange","disabled","enabled","ref","type","min","max","onChange","getSliderValue","current","parseInt","SatVisAssertionError","message","_this","call","Error","assert","condition","length","undefined","styleTemplates","Graph","state","metaPressed","markers","Set","network","networkNodes","DataSet","networkEdges","graphContainer","dragStartEvent","cachedChangeNodesEvent","generateNetwork","updateNetwork","fit","window","addEventListener","keydownHandler","bind","keyupHandler","removeEventListener","prevProps","dag","selectNodes","nodeSelection","nodes","map","nodeId","toString","animation","incomingEvent","changedNodesEvent","visNodes","Array","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","visNode","label","get","toHTMLString","push","err","return","update","Network","edges","physics","interaction","multiselect","on","_ref","asyncToGenerator","regenerator_default","a","mark","_callee","clickEvent","clickedNodeId","wrap","_context","prev","find","onNodeSelectionChange","filter","stop","_x","dragEndEvent","isPassiveDag","deltaX","pointer","canvas","x","deltaY","y","onUpdateNodePositions","onlyUpdateStyles","visEdges","edgeId","nodePartition","styleMap","computeNodePartition","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_ref4","_ref3","slicedToArray","satNodeId","satNode","nodeStyle","hidden","toVisNode","getPosition","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","parents","parentId","visEdge","toVisEdge","clear","add","nodesInActiveDag","computeNodesInActiveDag","Map","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_ref7","_ref6","node","isDeleted","deletionTime","nodeIsTheoryAxiom","set","isFromPreprocessing","inferenceRule","activeTime","has","style","position","styleData","isMarked","labelHighlightBold","shape","color","border","markedStyle","defaultStyle","background","highlight","highlightStyle","font","text","multi","Math","round","parentNodeId","arrows","from","to","smooth","clickPosition","getNodeAt","layerX","layerY","event","setState","delete","ReactModal","setAppElement","Main","passiveDag","onDismissPassiveDag","modal","lib_default","isOpen","contentLabel","activeNodeId","onRequestClose","Graph_Graph","Slider_Slider","GraphMenu","title","undoEnabled","onUndo","filterUpEnabled","onRenderParentsOnly","filterDownEnabled","onRenderChildrenOnly","passiveDagButtonEnabled","passiveDagButtonFunctionality","onShowPassiveDag","NodeMenu","onSelectParents","onSelectChildren","onSelectCommonConsequences","Search","foundNodes","searchField1","searchField2","searchField3","toListItem","onUpdateNodeSelection","getDisabledListItem","placeholder","onKeyUp","search","slice","searchString1","searchString2","searchString3","candidates","values","_i","_candidates","unit","clause","foundLiteral","premiseLiterals","includes","conclusionLiterals","contextLiterals","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","sort","node1","node2","clause1","clause2","NodeCard","NodeMenu_NodeMenu","Search_Search","NodeDetails","keep","toList","orientation","literals","react_sortablejs_lib_default","options","group","tag","_items","_sortable","onLiteralOrientationChange","oldIndex","newIndex","literal","index","data-id","onDoubleClick","onLiteralRepresentationChange","currentTarget","innerText","statisticsStrings","statistics","_ref2","numberOfTransitiveActivatedChildren","join","Aside","nodeDetails","multipleVersions","NodeDetails_NodeDetails","maximalActiveTime","GraphMenu_GraphMenu","NodeCard_NodeCard","SatNode","newTime","deletionParents","isBoundary","isActive","Formula","formula","Clause","literalsNewEvent","literalsActiveEvent","oldPosition","newPosition","removedLiterals","splice","removedLiteral","orientationReason","premiseString","isSelected","conclusionString","contextString","premiseStringWithoutBoldness","conclusionStringWithoutBoldness","contextStringWithoutBoldness","estimatedLengthOfLine","ceil","line","repeat","implication","Literal","args","negated","representation","hideBracketsAssoc","nonStrictForNegatedStrictInequalities","literalInParent","negateLiteral","occursNegated","switchSides","lhs","rhs","arg","Term","isVariable","startsWith","inner","UnitParser","string","match","parseClause","literalStrings","split","i","parseLiteral","equalityPosition","substring","lhsString","rhsString","parseTerm","atomString","literalTerm","tokens","stringPos","char","tokenEnd","token","stack","pos","pop","f","DFPostOrderTraversal","todo","visited","leaves","last","currentId","currentNode","existsUnvisitedParent","ReversePostOrderTraversal","postOrder","it","hasNext","getNext","literalsMatch","literal1","literal2","allowSubstitutions","success","substitution","arg1","arg2","computeSubstitution","substitutionEq","isSubstitution","termsAreEqual","isEqual","f1","f2","substitutedVariable","ParsedLine","unitString","Dag","mergeMap","_ref5","nonLeaves","keys","size","children","counter","transitiveChildrenIds","existsRelevantParent","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","isRelevant","alreadyGenerated","alreadyActivated","activeNodeIds","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","_ref9","_ref8","nodeIds","computeActiveNodes","currentNodeId","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_iterator12","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_step13","_iterator13","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_step14","_iterator14","parsedLines","existingDag","emptyClauseNode","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_step15","_iterator15","parentsAfterMerge","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_step16","_iterator16","mergedParentsOrUndefined","toConsumableArray","parsePreprocessingUnit","parent","clauseAfterActivation","nSel","existingLiteralsActiveOrder","foundMatch","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_step17","_iterator17","existingLiteral","filterNonParents","relevantIds","transitiveParentIds","remainingNodes","forEach","remainingNodesDeepCopy","copy","filterNonConsequences","boundaryNode","createBoundaryNode","mergePreprocessing","nodeIdsToRemove","postOrderTraversal","updatedParents","parentNode","parent2Id","updatedNode","nodeIdToRemove","passiveDagForSelection","selectionIds","selectionIdsSet","idToActiveDagParents","activeDagParents","activeDagParentsParent","activeDagParent","passiveDagNodes","relevantNodes","iterator2","runViz","_runViz","dotString","viz","Viz","Module","render","abrupt","renderString","format","then","result","catch","error","console","PLAIN_PATTERN","VizWrapper","_layoutNodesAtPosition","sourceNode","isSourceNode","_position","posSelectedX","posSelectedY","posSourceX","posSourceY","_node","_position2","layoutNodes","t0","finish","t1","t2","_x2","_layoutDag","_callee2","onlyActiveDag","layoutString","_context2","dagToDotString","sent","parseLayoutString","_x3","_x4","_layoutNodes","_callee3","_context3","nodesToDotString","_x5","Number","MAX_SAFE_INTEGER","inputStrings","preprocessingStrings","otherStrings","nodeIsInputNode","edgeStrings","nodeStrings","firstEdgeLineIndex","indexOf","parsedNodeLines","substr","matchAll","parsedNodeLine","_parsedNodeLine","idString","xString","yString","parseFloat","computeParentLiteralsCase1","parentLiterals","parentLiteral","setLiteralInParent","computeParentLiteralsCase2","allowMultipleRemovals","foundRemovedLit","j","computeParentLiteralsCase3","foundRewrittenLiteral","computeParentLiterals","hasSwitchedParents","parentClause","leftNode","rightNode","leftClause","rightClause","leftWasAlreadyActivated","rightWasAlreadyActivated","leftLiterals","rightLiterals","computeClauseRepresentation","changedClauseId","changedClauses","isEqualityResolutionWithDeletion","propagateSingleParent","propagateTwoParents","_loop","l","existsUserOrientedLiteral","premiseIndexMap","conclusionIndexMap","contextIndexMap","lit1","lit2","index1","index2","App","dags","nodeIdToActivate","main","_this$state","Main_Main","updateNodeSelection","updateCurrentTime","dismissPassiveDag","updateNodePositions","Aside_Aside","undoLastStep","renderParentsOnly","renderChildrenOnly","showPassiveDag","selectParents","selectChildren","selectCommonConsequences","changeLiteralOrientation","changeLiteralRepresentation","runVampire","problem","vampireUserOptions","mode","selectFinalPreprocessingClauses","json","lines","val","lineType","unitId","fetch","method","headers","Accept","Content-Type","body","JSON","stringify","file","fetchedJSON","status","vampireState","jsonToParsedLines","fromParsedLines","isRefutation","layoutDag","orientClauses","setLiteralOptions","errorMessage","selectedId","positioningHint","currentDag","currentDagActiveNodes","newDag","newDagActiveNodes","newNodes","layoutNodesAtPosition","selectClause","popDag","pushDag","posCurrentX","posCurrentY","posPassiveX","posPassiveY","performActivation","_this$state4","newSelection","_this$state5","getChildren","childId","_this$state6","commonConsequences","idToRelevantParentIds","relevantParents","relevantParentIdsFromParent","relevantParentId","findCommonConsequences","changedNodes","changedNodesInCurrentDag","changedNodeId","switchToNextRepresentation","delta","_this$state7","selectedNodesInNewDag","_iteratorNormalCompletion18","_didIteratorError18","_iteratorError18","_step18","_iterator18","Component","AppWrapper","NavigationBar_NavigationBar","src_components_App","Menu","_getPrototypeOf2","_len","_key","isChromeOrFirefox","navigator","userAgent","fileUpload","monacoDiv","monaco","Monaco","create","lineNumbers","roundedSelection","scrollBeyondLastLine","scrollBeyondLastColumn","minimap","renderLineHighlight","hideCursorInOverviewRuler","links","overviewRulerBorder","automaticLayout","lineDecorationsWidth","lineNumbersMinChars","wordWrap","setValue","getModel","onDidChangeContent","onChangeProblem","getValue","problemName","chooseFile","uploadEncoding","htmlFor","changeInputSyntax","inputSyntax","changeVampireUserOptions","checked","changeHideBracketsAssoc","changeNonStrictForNegatedStrictInequalities","changeOrientClauses","react_router_dom","click","_this3","target","files","reader","FileReader","onloadend","onChangeProblemName","endsWith","onChangeInputSyntax","readAsText","newValue","onChangeVampireUserOptions","onChangeHideBracketsAssoc","onChangeNonStrictForNegatedStrictInequalities","onChangeOrientClauses","AppRouter","react_router","path","exact","Menu_Menu","changeProblem","changeProblemName","appComponent","AppWrapper_AppWrapper","Boolean","location","hostname","ReactDOM","Router_AppRouter","document","getElementById","serviceWorker","ready","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.b063c202.chunk.js","sourcesContent":["import * as React from 'react';\nimport './NavigationBar.css';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  name: string\n}\n\nexport class NavigationBar extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <nav id=\"navigationBar\">\n        <button onClick={() => history.back()}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#nav-back`}/>\n          </svg>\n\t\t\t\t\t<span>Back</span>\n        </button>\n        <small>{this.props.name}</small>\n        <div className=\"hidden\"></div>\n      </nav>\n    )\n  }\n}","import * as React from 'react';\n\nimport './Slider.css';\n\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  historyLength: number,\n  currentTime: number,\n  onCurrentTimeChange: (newState: number) => void,\n  enabled: boolean\n};\nexport default class Slider extends React.Component<Props, {}> {\n\n  private slider = React.createRef<HTMLInputElement>();\n\n  render() {\n    const {historyLength, currentTime, onCurrentTimeChange} = this.props;\n\n    return (\n      <section className=\"component-slider\">\n\n        <button disabled={!this.props.enabled || currentTime <= 0} onClick={() => onCurrentTimeChange(currentTime - 1)}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#history-back`}/>\n          </svg>\n        </button>\n\n        <section className=\"wrapper\">\n          <input\n            ref={this.slider}\n            type=\"range\"\n            min={0}\n            max={historyLength}\n            value={currentTime}\n            disabled={!this.props.enabled}\n            onChange={() => onCurrentTimeChange(this.getSliderValue())}\n          />\n        </section>\n\n        <button disabled={!this.props.enabled || currentTime >= historyLength} onClick={() => onCurrentTimeChange(currentTime + 1)}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#history-forward`}/>\n          </svg>\n        </button>\n\n      </section>\n    );\n  }\n\n  // HELPERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  getSliderValue(): number {\n    return this.slider.current ? parseInt(this.slider.current.value, 10) : 0;\n  }\n\n}\n","class SatVisAssertionError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = \"SatVisAssertionError\";\n    }\n  }\n\nexport function assert(condition, message=\"\") {\n    if (!condition)\n        throw new SatVisAssertionError('Assertion failed: ' + (message || ''));\n};","import * as React from 'react';\nimport {DataSet, Network, IdType, Node, Edge} from 'vis'\n\nimport './Graph.css'\nimport { assert } from '../model/util';\n\nimport { Dag } from '../model/dag';\nimport SatNode from '../model/sat-node';\n\nconst styleTemplates = require('../resources/styleTemplates');\n\ntype Props = {\n  dag: Dag,\n  nodeSelection: number[],\n  changedNodesEvent?: Set<number>,\n  currentTime: number,\n  onNodeSelectionChange: (selection: number[]) => void,\n  onUpdateNodePositions: (nodeIds: Array<number>, delta: [number, number]) => void\n};\n\ntype State = {\n  metaPressed: boolean,\n}\n\nexport default class Graph extends React.Component<Props, {}> {\n\n  state: State = {\n    metaPressed: false,\n  }\n\n  markers = new Set<number>();\n  network: Network | null = null;\n  networkNodes = new DataSet<Node>([]);\n  networkEdges = new DataSet<Edge>([]);\n  graphContainer = React.createRef<HTMLDivElement>();\n  dragStartEvent: any = null;\n  cachedChangeNodesEvent?: Set<number> = undefined;\n\n  componentDidMount() {\n    this.generateNetwork();\n    this.updateNetwork(false);\n    this.network!.fit();\n\n    window.addEventListener(\"keydown\", this.keydownHandler.bind(this), false);\n    window.addEventListener(\"keyup\", this.keyupHandler.bind(this), false);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.keydownHandler.bind(this), false);\n    window.removeEventListener(\"keyup\", this.keyupHandler.bind(this), false);\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (this.props.dag !== prevProps.dag) {\n      this.updateNetwork(false);\n      this.network!.selectNodes(this.props.nodeSelection);\n      if (this.props.nodeSelection.length > 0) {\n        // center the view to selected nodes\n        this.network!.fit({\n          nodes: this.props.nodeSelection.map(nodeId => nodeId.toString()), \n          animation: true\n        });\n      } else {\n        // set the view so that the whole graph is visible\n        this.network!.fit();\n      }\n    } else {\n      if (this.props.nodeSelection !== prevProps.nodeSelection) {\n        this.network!.selectNodes(this.props.nodeSelection);\n      }\n      if (this.props.currentTime !== prevProps.currentTime) {\n        this.updateNetwork(true);\n      }\n      const incomingEvent = this.props.changedNodesEvent;\n      if (incomingEvent !== prevProps.changedNodesEvent) {\n        assert(incomingEvent !== undefined);\n        if (incomingEvent !== this.cachedChangeNodesEvent) {\n          this.cachedChangeNodesEvent = incomingEvent;\n\n          // update all nodes from event\n          const visNodes = new Array<Node>();\n          for (const nodeId of incomingEvent!) {\n            const visNode = {\n              id : nodeId,\n              label : this.props.dag.get(nodeId).toHTMLString(this.props.currentTime)\n            };\n            visNodes.push(visNode);\n          }\n          this.networkNodes.update(visNodes);\n        }\n      }\n    }\n  }\n\n  render() {\n    return (\n      <section className=\"component-graph\" ref={this.graphContainer}>\n        <canvas/>\n      </section>\n    );\n  }\n\n\n  // DISPLAY NETWORK ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  generateNetwork() {\n    assert(this.graphContainer.current);\n    assert(!this.network); // should only be called once\n\n    this.network = new Network(this.graphContainer.current!, {\n      nodes: this.networkNodes,\n      edges: this.networkEdges\n    }, {\n      physics: false,\n      interaction: {\n        multiselect: false\n      },\n    });\n\n    this.network.on('click', async (clickEvent) => {\n      if (clickEvent.nodes.length > 0) {\n        assert(clickEvent.nodes.length === 1);\n        const clickedNodeId = clickEvent.nodes[0];\n        if (this.state.metaPressed) {\n          if (this.props.nodeSelection.find((nodeId: number) => nodeId === clickedNodeId) !== undefined) {\n            this.props.onNodeSelectionChange(this.props.nodeSelection.filter((nodeId: number) => nodeId !== clickedNodeId));\n          } else {\n            this.props.onNodeSelectionChange(this.props.nodeSelection.concat(clickEvent.nodes));\n          }\n        } else {\n          this.props.onNodeSelectionChange(clickEvent.nodes);\n        }\n      } else {\n        this.props.onNodeSelectionChange([]);\n      }\n    });\n\n    this.network.on('dragStart', (dragStartEvent) => {\n      assert(dragStartEvent !== undefined && dragStartEvent !== null);\n      assert(dragStartEvent.nodes !== undefined && dragStartEvent.nodes !== null);\n      this.dragStartEvent = dragStartEvent;\n      if (dragStartEvent.nodes.length > 0) {\n        this.props.onNodeSelectionChange(dragStartEvent.nodes);\n      }\n    });\n\n    this.network.on('dragEnd', (dragEndEvent) => {\n      assert(this.dragStartEvent !== undefined && this.dragStartEvent !== null);\n      assert(this.dragStartEvent.nodes !== undefined && this.dragStartEvent.nodes !== null);\n      assert(dragEndEvent !== undefined && dragEndEvent !== null);\n      assert(dragEndEvent.nodes !== undefined && dragEndEvent.nodes !== null);\n      if (dragEndEvent.nodes.length > 0 && !this.props.dag.isPassiveDag) {\n        const deltaX = dragEndEvent.pointer.canvas.x - this.dragStartEvent.pointer.canvas.x;\n        const deltaY = dragEndEvent.pointer.canvas.y - this.dragStartEvent.pointer.canvas.y;\n        this.props.onUpdateNodePositions(dragEndEvent.nodes as Array<number>, [deltaX / (-70), deltaY / (-120)]);\n      }\n    });\n  }\n\n  // updates the network displayed by Vis.js\n  // if onlyUpdateStyles is false, all nodes and edges are newly generated.\n  // if onlyUpdateStyles is true, only the attributes of the nodes and edges are updated\n  updateNetwork(onlyUpdateStyles: boolean) {\n    const {dag, currentTime} = this.props;\n\n    const visNodes = new Array<Node>();\n    const visEdges = new Array<Edge>();\n    let edgeId = 0;\n\n    // partition nodes:\n    // for standard dags, compute node partition\n    // for passive dags use style map cached in dag\n    const nodePartition = dag.isPassiveDag ? (dag.styleMap as Map<number, string>) : this.computeNodePartition(dag, currentTime);\n\n    // update network nodes\n    for (const [satNodeId, satNode] of dag.nodes) {\n      const nodeStyle = nodePartition.get(satNodeId);\n      assert(nodeStyle !== undefined, \"invar\");\n      if (nodeStyle === \"hidden\") {\n        const visNode = {id : satNodeId, hidden : true};\n        visNodes.push(visNode);\n      } else {\n        const visNode = this.toVisNode(satNode, nodeStyle, satNode.getPosition());\n        visNodes.push(visNode);\n      }\n\n      for (const parentId of satNode.parents) {\n        const visEdge = this.toVisEdge(edgeId, parentId, satNode.id, nodeStyle === \"hidden\");\n        edgeId = edgeId + 1;\n        visEdges.push(visEdge);\n      }\n    }\n\n    if(onlyUpdateStyles) {\n      // QUESTION: it seems that using a single call to update is faster than separately updating each node. is this true?\n      this.networkNodes.update(visNodes);\n      this.networkEdges.update(visEdges);\n    } else {\n      // QUESTION: it seems that using a single call to add is faster than separately adding each node. is this true?\n      this.networkNodes.clear();\n      this.networkNodes.add(visNodes);\n      this.networkEdges.clear();\n      this.networkEdges.add(visEdges);\n    }\n  }\n\n  computeNodePartition(dag: Dag, currentTime: number): Map<number, any> {\n\n    const nodesInActiveDag = dag.computeNodesInActiveDag(currentTime);\n\n    const nodePartition = new Map<number, any>();\n    for (const [nodeId, node] of dag.nodes) {\n\n      const isDeleted = (node.deletionTime !== null && node.deletionTime <= currentTime);\n\n      if (dag.nodeIsTheoryAxiom(nodeId)) {\n        nodePartition.set(nodeId, isDeleted ? \"theory-axiom-deleted\" : \"theory-axiom\");\n        continue;\n      }\n      if (node.isFromPreprocessing) {\n        if (node.inferenceRule === \"negated conjecture\") {\n          nodePartition.set(nodeId, \"conjecture\");\n        } else {\n          nodePartition.set(nodeId, isDeleted ? \"preprocessing-deleted\" : \"preprocessing\");\n        }\n        continue;\n      }\n\n      const isActivated = (node.activeTime !== null && node.activeTime <= currentTime);\n      if (isActivated) {\n        nodePartition.set(nodeId, isDeleted ? \"activated-deleted\" : \"activated\");\n        continue;\n      }\n\n      if (nodesInActiveDag.has(nodeId)) {\n        nodePartition.set(nodeId, \"deleted\");\n        continue;\n      } \n\n      nodePartition.set(nodeId, \"hidden\");\n    }\n\n    return nodePartition;\n  }\n\n  toVisNode(node: SatNode, style: string, position: [number, number]): any {\n    const styleData = styleTemplates[style];\n    const isMarked = this.markers.has(node.id);\n\n    return {\n      id : node.id,\n      label : node.toHTMLString(this.props.currentTime),\n      labelHighlightBold : false,\n      shape : \"box\",\n      color : {\n        border : isMarked ? styleData.markedStyle.border : styleData.defaultStyle.border,\n        background : isMarked ? styleData.markedStyle.background : styleData.defaultStyle.background,\n        highlight : {\n          border : styleData.highlightStyle.border,\n          background : styleData.highlightStyle.background\n        }\n      },\n      font : {\n        color : styleData.text,\n        multi : true\n      },\n      hidden : false,\n      x : Math.round(position[0] * -70),\n      y : Math.round(position[1] * -120)\n    };\n\n  }\n\n  toVisEdge(edgeId: number, parentNodeId: number, nodeId: number, hidden: boolean) {\n    return {\n      id : edgeId,\n      arrows : \"to\",\n      color : {\n        color : \"#dddddd\",\n        highlight : \"#f8cfc1\",\n      },\n      from : parentNodeId,\n      to : nodeId,\n      smooth : false,\n      hidden : hidden\n    }\n  }\n\n\n  // INTERACTION ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  findNodeAt(clickPosition: {layerX: number, layerY: number}): IdType  {\n    return this.network!.getNodeAt({\n      x: clickPosition.layerX,\n      y: clickPosition.layerY\n    });\n  }\n\n  keydownHandler(event) {\n    if (event.key === \"Meta\") {\n      this.setState({metaPressed: true});\n    }\n  }\n  keyupHandler(event) {\n    if (event.key === \"Meta\") {\n      this.setState({metaPressed: false});\n    }\n  }\n\n  // MARKERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  toggleMarker(nodeId: number) {\n    assert(this.networkNodes);\n\n    if (this.markers.has(nodeId)) {\n      this.markers.delete(nodeId);\n    } else {\n      this.markers.add(nodeId);\n    }\n    this.updateNetwork(true);\n  }\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport Slider from './Slider';\nimport Graph from './Graph';\nimport ReactModal from 'react-modal';\nReactModal.setAppElement('#root');\n\ntype Props = {\n  dag: Dag,\n  passiveDag: Dag | null,\n  nodeSelection: number[],\n  changedNodesEvent?: Set<number>,\n  historyLength: number,\n  currentTime: number,\n  onNodeSelectionChange: (selection: number[]) => void,\n  onCurrentTimeChange: (newState: number) => void,\n  onDismissPassiveDag: (performActivation: boolean) => void,\n  onUpdateNodePositions: (nodeIds: Array<number>, delta: [number, number]) => void\n};\nexport default class Main extends React.Component<Props, {}> {\n\n  // TODO: remove this, after supporting button clicks in Aside while the modal is active\n  componentDidMount() {\n    window.addEventListener(\"keyup\", async (event) => {\n      if (event.key === \"Alt\") {\n        if (this.props.passiveDag !== null) {\n          this.props.onDismissPassiveDag(true);\n        }\n      }\n    },false);\n  }\n\n  render() {\n    let modal;\n    if (this.props.passiveDag !== null) {\n      modal =\n      <ReactModal\n        isOpen={this.props.passiveDag !== null}\n        contentLabel={`Clauses currently in Passive generated by clause with id ${this.props.passiveDag!.activeNodeId!}`}\n        onRequestClose={() => {\n          this.props.onDismissPassiveDag(false);\n        }}\n      >\n        <Graph\n          dag={this.props.passiveDag}\n          nodeSelection={this.props.nodeSelection}\n          changedNodesEvent={this.props.changedNodesEvent}\n          currentTime={this.props.currentTime}\n          onNodeSelectionChange={this.props.onNodeSelectionChange}\n          onUpdateNodePositions={this.props.onUpdateNodePositions}\n        />\n      </ReactModal>  \n    }\n\n    return (\n      <main>\n        <Graph\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          changedNodesEvent={this.props.changedNodesEvent}\n          currentTime={this.props.currentTime}\n          onNodeSelectionChange={this.props.onNodeSelectionChange}\n          onUpdateNodePositions={this.props.onUpdateNodePositions}\n        />\n        {modal}\n        <Slider\n          historyLength={this.props.historyLength}\n          currentTime={this.props.currentTime}\n          onCurrentTimeChange={this.props.onCurrentTimeChange}\n          enabled={!this.props.dag.isPassiveDag}\n        />\n      </main>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport './GraphMenu.css';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  undoEnabled: boolean,\n  filterUpEnabled: boolean,\n  filterDownEnabled: boolean,\n  passiveDagButtonEnabled: boolean,\n  passiveDagButtonFunctionality: 'show' | 'activate',\n  onUndo: () => void,\n  onRenderParentsOnly: () => void,\n  onRenderChildrenOnly: () => void,\n  onShowPassiveDag: () => void,\n  onDismissPassiveDag: (performActivation: boolean) => void,\n};\n\nexport default class GraphMenu extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-graph-menu\">\n        <button title=\"Undo last graph transformation\" disabled={!this.props.undoEnabled} onClick={this.props.onUndo}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#graph-undo`}/>\n          </svg>\n        </button>\n\n        <button title=\"Render selection only (up)\" disabled={!this.props.filterUpEnabled}\n                onClick={this.props.onRenderParentsOnly}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#graph-up`}/>\n          </svg>\n        </button>\n\n        <button title=\"Render selection only (down)\" disabled={!this.props.filterDownEnabled}\n                onClick={this.props.onRenderChildrenOnly}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#graph-down`}/>\n          </svg>\n        </button>\n\n        <button title=\"Select clauses\"\n                disabled={!this.props.passiveDagButtonEnabled}\n                onClick={() => {\n                  this.props.passiveDagButtonFunctionality === 'activate' ? this.props.onShowPassiveDag() : this.props.onDismissPassiveDag(true)\n                }}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#graph-s`}/>\n          </svg>\n        </button>\n      </section>\n    );\n  }\n}\n","import * as React from 'react';\n\nimport './NodeMenu.css';\n\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  nodeSelection: number[],\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void\n};\nexport default class NodeMenu extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-node-menu\">\n\n        <button\n          title=\"Select parents of selected nodes\"\n          disabled={!this.props.nodeSelection.length}\n          onClick={this.props.onSelectParents}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-parents`}/>\n          </svg>\n        </button>\n\n        <button\n          title=\"Select children of selected nodes\"\n          disabled={!this.props.nodeSelection.length}\n          onClick={this.props.onSelectChildren}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-children`}/>\n          </svg>\n        </button>\n\n        <button\n          title=\"Find common consequences of selected nodes\"\n          disabled={this.props.nodeSelection.length < 2}\n          onClick={this.props.onSelectCommonConsequences}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-consequences`}/>\n          </svg>\n        </button>\n\n      </section>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport './Search.css';\nimport SatNode from '../model/sat-node';\nimport { assert } from '../model/util';\nimport { Clause } from '../model/unit';\n\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  onUpdateNodeSelection: (selection: number[]) => void\n};\ntype State = {\n  foundNodes: Array<SatNode>\n};\n\nexport default class Search extends React.Component<Props, State> {\n\n  state = {\n    foundNodes: []\n  };\n  private searchField1 = React.createRef<HTMLInputElement>();\n  private searchField2 = React.createRef<HTMLInputElement>();\n  private searchField3 = React.createRef<HTMLInputElement>();\n\n  componentDidUpdate(prevProps) {\n    if (this.props.dag !== prevProps.dag || this.props.currentTime !== prevProps.currentTime) {\n      this.searchField1.current!.value = \"\";\n      this.searchField2.current!.value = \"\";\n      this.searchField3.current!.value = \"\";\n\n      this.setState({foundNodes: []});\n    }\n  }\n\n  render() {\n    const {foundNodes} = this.state;\n\n    return (\n      <section className=\"component-search\">\n        <input\n          type=\"text\"\n          ref={this.searchField1}\n          placeholder=\"Search for nodes including literal\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <input\n          type=\"text\"\n          ref={this.searchField2}\n          placeholder=\"Search for nodes excluding literals\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <input\n          type=\"text\"\n          ref={this.searchField3}\n          placeholder=\"Search for nodes using inference rule\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <ul id=\"searchResults\">\n          {\n            foundNodes.slice(0, 21).map(node => this.toListItem(node))\n          }\n          {\n            foundNodes.length > 20 && this.getDisabledListItem()\n          }\n        </ul>\n      </section>\n    );\n  }\n\n\n  // SEARCH ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  search() {\n    assert(this.props.dag !== null);\n\n    assert(this.searchField1.current!);\n    assert(this.searchField2.current!);\n    assert(this.searchField3.current!);\n    const searchString1 = this.searchField1.current!.value;\n    const searchString2 = this.searchField2.current!.value;\n    const searchString3 = this.searchField3.current!.value;\n\n    // only perform search if at least one search string is non-empty\n    if (searchString1 === \"\" && searchString2 === \"\" && searchString3 === \"\") {\n      this.props.onUpdateNodeSelection([]);\n      this.setState({\n        foundNodes: []\n      });\n      return;\n    }\n\n    let candidates = Array.from(this.props.dag!.nodes.values());\n\n    // find all clauses which contain a literal which matches the first search string\n    if (searchString1 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        if (node.unit.type === \"Clause\") {\n          const clause = node.unit as Clause;\n        \n          let foundLiteral = false;\n          for (const literal of clause.premiseLiterals) {\n            if(literal.toString(true).includes(searchString1)) {\n              foundLiteral = true;\n              break;\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.conclusionLiterals) {\n              if(literal.toString(false).includes(searchString1)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.contextLiterals) {\n              if(literal.toString(false).includes(searchString1)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if(foundLiteral) {\n            foundNodes.push(node);\n          }\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    // find all clauses which don't contain a literal which matches the second search string\n    if (searchString2 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        if (node.unit.type === \"Clause\") {\n          const clause = node.unit as Clause;\n        \n          let foundLiteral = false;\n          for (const literal of clause.premiseLiterals) {\n            if(literal.toString(true).includes(searchString2)) {\n              foundLiteral = true;\n              break;\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.conclusionLiterals) {\n              if(literal.toString(false).includes(searchString2)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.contextLiterals) {\n              if(literal.toString(false).includes(searchString2)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n\n          if(!foundLiteral) {\n            foundNodes.push(node);\n          }\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    // find all clauses which have been derived using an inference rule which matches the third search string\n    if (searchString3 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        // note: using an exact check here instead of includes check\n        // e.g. so that \"resolution\" does not match \"subsumption resolution\"\n        if (node.inferenceRule === searchString3) {\n          foundNodes.push(node);\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    const nodesInActiveDag = this.props.dag!.computeNodesInActiveDag(this.props.currentTime);\n    const foundNodes = new Array<SatNode>();\n    for (const node of candidates) {\n      if (nodesInActiveDag.has(node.id)) {\n        foundNodes.push(node);\n      }\n    }\n    candidates = foundNodes;\n\n    // order found clauses by length\n    candidates.sort((node1: SatNode, node2: SatNode) => {\n      const clause1 = node1.unit as Clause;\n      const clause2 = node2.unit as Clause;\n      return clause1.toString().length - clause2.toString().length\n    });\n\n    // select all found clauses\n    this.props.onUpdateNodeSelection(candidates.map(node => node.id));\n  \n    // present search results\n    this.setState({\n      foundNodes: candidates\n    });\n  }\n\n  toListItem = (node: SatNode) => {\n    return <li key={node.id} onClick={() => this.props.onUpdateNodeSelection([node.id])}>{node.toString()}</li>;\n  };\n\n  getDisabledListItem = () => {\n    return <li className=\"disabled-element\">...</li>;\n  };\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport NodeMenu from './NodeMenu';\nimport Search from './Search';\nimport './NodeCard.css';\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  nodeSelection: number[],\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void\n};\nexport default class NodeCard extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-node-card\">\n        <article>\n          <h2>Select Nodes</h2>\n          <NodeMenu\n            nodeSelection={this.props.nodeSelection}\n            onSelectParents={this.props.onSelectParents}\n            onSelectChildren={this.props.onSelectChildren}\n            onSelectCommonConsequences={this.props.onSelectCommonConsequences}\n          />\n          <Search\n            dag={this.props.dag}\n            currentTime={this.props.currentTime}\n            onUpdateNodeSelection={this.props.onUpdateNodeSelection}\n          />\n        </article>\n      </section>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport './NodeDetails.css';\nimport Sortable from 'react-sortablejs';\nimport { Clause } from '../model/unit';\nimport { Literal } from '../model/literal';\nimport SatNode from '../model/sat-node';\n\ntype Props = {\n  node: SatNode,\n  numberOfTransitiveActivatedChildren: number,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void\n};\n\nexport default class NodeDetails extends React.Component<Props, {}> {\n\n  keep=false; // hack to skip each second event generated by Sortable\n\n  render() {\n    const statisticsStrings = new Array<string>();\n    for (const [key, value] of this.props.node.statistics) {\n      statisticsStrings.push(`${key}: ${value}`);\n    }\n    \n    return (\n      <section className={'component-node-details details'}>\n        <article>\n          <h2>Node <strong>{this.props.node.id}, </strong></h2>\n          <h3>{this.props.node.inferenceRule}</h3>\n          <h3>{this.props.numberOfTransitiveActivatedChildren} {this.props.numberOfTransitiveActivatedChildren === 1 ? \"child\" : \"children\"}</h3>\n          <h3>{statisticsStrings.join(\", \")}</h3>\n          {\n            this.props.node.unit.type === \"Formula\" ? (\n              <section className={'literal-wrapper'}>\n                {\n                  this.props.node.toString()\n                }\n              </section>\n            ) : (\n              <section className={'literal-wrapper'}>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"premise\")\n                }\n                <br/>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"conclusion\")\n                }\n                <br/>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"context\")\n                }\n              </section>\n            )\n          }\n        </article>\n      </section>\n    );\n  }\n\n  toList = (nodeId: number, clause: Clause, orientation: \"premise\" | \"conclusion\" | \"context\") => {\n    const literals = orientation === \"premise\" ? clause.premiseLiterals : (orientation === \"conclusion\" ? clause.conclusionLiterals : clause.contextLiterals);\n  \n    return (\n      <Sortable\n        options={{\n          group: 'shared'\n        }}\n        tag={\"ul\"}\n        id={orientation === \"premise\" ? \"id1\" : (orientation === \"conclusion\" ? \"id2\" : \"id3\")}\n        onChange={(_items, _sortable, event)=>{\n          // Hack: Sortable generates two identical events (one for each modified list), so we need to ignore one of them\n          this.keep = !this.keep;\n          if (this.keep) {\n            const from = event.from.id === \"id1\" ? \"premise\" : event.from.id === \"id2\" ? \"conclusion\" : \"context\";\n            const to = event.to.id === \"id1\" ? \"premise\" : event.to.id === \"id2\" ? \"conclusion\" : \"context\";\n            this.props.onLiteralOrientationChange(nodeId, [from, event.oldIndex], [to, event.newIndex]);\n          }\n        }}\n      >\n        {\n          literals.map((literal, index) => this.toListItem(literal, index, orientation))\n        }\n      </Sortable>\n      )\n    };\n  \n  toListItem = (literal: Literal, index: number, orientation: \"premise\" | \"conclusion\" | \"context\") => {\n    return <li key={index} data-id={index} onDoubleClick={(event) => {\n      this.props.onLiteralRepresentationChange(this.props.node.id, literal);\n      event.currentTarget.innerText = literal.toString(orientation === \"premise\");\n    }}>{literal.toString(orientation === \"premise\")}</li>\n  };\n}\n","import * as React from 'react';\n\nimport GraphMenu from './GraphMenu';\nimport NodeCard from './NodeCard';\nimport NodeDetails from './NodeDetails';\nimport { Dag } from '../model/dag';\nimport { Literal } from '../model/literal';\nimport { assert } from '../model/util';\n\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  nodeSelection: number[],\n  multipleVersions: boolean,\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onUndo: () => void,\n  onRenderParentsOnly: () => void,\n  onRenderChildrenOnly: () => void,\n  onShowPassiveDag: () => void,\n  onDismissPassiveDag: (performActivation: boolean) => void,\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void\n};\nexport default class Aside extends React.Component<Props, {}> {\n\n  render() {\n    if (this.props.dag === null) {\n      assert(this.props.nodeSelection.length === 0);\n      assert(!this.props.multipleVersions);\n    }\n\n    let nodeDetails;\n    if (this.props.nodeSelection.length === 1) {\n      const node = this.props.dag!.get(this.props.nodeSelection[0]);\n      nodeDetails = \n      <NodeDetails\n        node={node}\n        numberOfTransitiveActivatedChildren={this.props.dag!.numberOfTransitiveActivatedChildren(node.id, this.props.currentTime)}\n        onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n        onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n      />;\n    } else {\n      nodeDetails = \n      <section className={'component-node-details overview'}>\n        <small id=\"nodeInfo\"><strong>{`${this.props.nodeSelection.length} nodes`}</strong> selected</small>\n      </section>\n    }\n\n    let passiveDagButtonFunctionality: \"activate\" | \"show\" = \"activate\";\n    let passiveDagButtonEnabled = false;\n    if (this.props.dag !== null) {\n      passiveDagButtonFunctionality = this.props.dag!.isPassiveDag ? \"show\" : \"activate\";\n      if (passiveDagButtonFunctionality === \"activate\") {\n        passiveDagButtonEnabled = this.props.nodeSelection.length > 0;\n      } else {\n        const styleMap = this.props.dag!.styleMap!;\n        assert(styleMap !== null);\n        passiveDagButtonEnabled = this.props.currentTime === this.props.dag.maximalActiveTime() && this.props.nodeSelection.length === 1 && styleMap.get(this.props.nodeSelection[0]) === \"passive\";\n      }\n    }\n\n    return (\n      <aside>\n        <GraphMenu\n          undoEnabled={this.props.dag !== null && this.props.multipleVersions}\n          filterUpEnabled={this.props.dag !== null && this.props.nodeSelection.length > 0 && !this.props.dag!.isPassiveDag}\n          filterDownEnabled={this.props.dag !== null && this.props.nodeSelection.length > 0 && !this.props.dag!.isPassiveDag}\n          passiveDagButtonFunctionality={passiveDagButtonFunctionality}\n          passiveDagButtonEnabled={passiveDagButtonEnabled}\n          onUndo={this.props.onUndo}\n          onRenderParentsOnly={this.props.onRenderParentsOnly}\n          onRenderChildrenOnly={this.props.onRenderChildrenOnly}\n          onShowPassiveDag={this.props.onShowPassiveDag}\n          onDismissPassiveDag={this.props.onDismissPassiveDag}\n        />\n        <NodeCard\n          dag={this.props.dag}\n          currentTime={this.props.currentTime}\n          nodeSelection={this.props.nodeSelection}\n          onUpdateNodeSelection={this.props.onUpdateNodeSelection}\n          onSelectParents={this.props.onSelectParents}\n          onSelectChildren={this.props.onSelectChildren}\n          onSelectCommonConsequences={this.props.onSelectCommonConsequences}\n        />\n        {nodeDetails}\n      </aside>\n    );\n  }\n\n}\n","import { assert } from './util'\nimport { Unit } from './unit'\nimport { UnitParser } from './unit-parser';\n\nexport default class SatNode {\n\n  readonly id: number;\n  unit: Unit;\n  readonly inferenceRule: string;\n  readonly parents: number[];\n  statistics: Map<string,number>;\n  readonly isFromPreprocessing: boolean;\n  newTime: number | null;\n  activeTime: number | null;\n  deletionTime: number | null;\n  deletionParents: number[];\n  position: [number,number] | null;\n  isBoundary: boolean;\n\n  constructor(\n    id: number,\n    unit: Unit,\n    inferenceRule: string,\n    parents: number[],\n    statistics: Map<string,number>,\n    isFromPreprocessing: boolean,\n    newTime: number | null,\n    activeTime: number | null,\n    deletionTime: number | null,\n    deletionParents: number[],\n    isBoundary: boolean\n  ) {\n    this.id = id;\n    this.unit = unit;\n    this.inferenceRule = inferenceRule;\n    this.parents = parents;\n    this.statistics = statistics;\n    this.isFromPreprocessing = isFromPreprocessing;\n    this.newTime = newTime;\n    this.activeTime = activeTime;\n    this.deletionTime = deletionTime;\n    this.deletionParents = deletionParents;\n    this.position = null;\n    this.isBoundary = isBoundary;\n  }\n\n  // return a copy of this node, where the position is null\n  copy(): SatNode {\n    return new SatNode(this.id, this.unit, this.inferenceRule, this.parents, this.statistics, this.isFromPreprocessing, this.newTime, this.activeTime, this.deletionTime, this.deletionParents, this.isBoundary);\n  }\n\n  getPosition(): [number,number] {\n    assert(this.position !== null, `accessing position of node with id ${this.id}, which has not been computed`);\n    return this.position as [number,number];\n  }\n\n  toString(): string {\n    return this.unit.toString();\n  }\n\n  toHTMLString(currentTime: number): string {\n    const isActive = this.activeTime !== null && this.activeTime <= currentTime;\n    return this.unit.toHTMLString(isActive);\n  }\n}","import {assert} from './util'\nimport {Literal} from './literal'\n\n// a unit is either a Formula or a clause.\n// units are also used internally by Vampire.\n// we fully parse clauses, but we keep formulas as string.\n// fully parsing formulas is more involved, in particular if one wants to support a reasonably complete subset of tptp.\nexport type Unit = Formula | Clause;\n\nexport class Formula {\n  readonly type: \"Formula\" | \"Clause\";\n  readonly formula: string;\n  \n  constructor(formula: string) {\n    this.type = \"Formula\";\n    this.formula = formula;\n  }\n\n  toString(): string {\n    return this.formula;\n  }\n\n  toHTMLString(isActive: boolean): string {\n    return this.formula;\n  }\n}\n\nexport class Clause {\n  readonly type: \"Formula\" | \"Clause\";\n  premiseLiterals: Literal[];\n  conclusionLiterals: Literal[];\n  contextLiterals: Literal[];\n  \n  // in order to compute literal flows we need to save the order in which literals occured in the clause\n  // at the timepoints of the new-event and the active-event\n  // the referenced literals are not only equal, but the same as the literals in premiseLiterals and conclusionLiterals\n  literalsNewEvent: Literal[] | null;\n  literalsActiveEvent: Literal[] | null;\n\n  constructor(conclusionLiterals: Array<Literal>){\n    this.type = \"Clause\";\n    this.premiseLiterals = [];\n    this.conclusionLiterals = conclusionLiterals;\n    this.contextLiterals = [];\n    this.literalsNewEvent = null;\n    this.literalsActiveEvent = null;\n  }\n\n  changeLiteralOrientation(oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) {\n\n    // remove literal from old position\n    let removedLiterals: Array<Literal> | null = null;\n    if (oldPosition[0] === \"premise\") {\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.premiseLiterals.length);\n      removedLiterals = this.premiseLiterals.splice(oldPosition[1], 1);\n    } else if (oldPosition[0] === \"conclusion\"){\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.conclusionLiterals.length);\n      removedLiterals = this.conclusionLiterals.splice(oldPosition[1], 1);\n    } else {\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.contextLiterals.length);\n      removedLiterals = this.contextLiterals.splice(oldPosition[1], 1);\n    }\n    assert(removedLiterals.length === 1);\n    const removedLiteral = removedLiterals[0];\n\n    // add literal to new position\n    if (newPosition[0] === \"premise\") {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.premiseLiterals.length);\n      this.premiseLiterals.splice(newPosition[1], 0, removedLiteral);\n    } else if (newPosition[0] === \"conclusion\") {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.conclusionLiterals.length);\n      this.conclusionLiterals.splice(newPosition[1], 0, removedLiteral);\n    } else {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.contextLiterals.length);\n      this.contextLiterals.splice(newPosition[1], 0, removedLiteral);\n    }\n    removedLiteral.orientationReason = \"user\";\n  }\n\n  toString(): string {\n    if (this.premiseLiterals.length === 0 && this.conclusionLiterals.length === 0 && this.contextLiterals.length === 0) {\n      return \"$false\"; // empty clause\n    }\n    const literals = this.premiseLiterals.concat(this.conclusionLiterals, this.contextLiterals);\n    return literals.map(literal => literal.toString(false)).join(\" | \");\n  }\n\n  toHTMLString(isActive: boolean): string {\n    let premiseString = this.premiseLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(true) + \"</b>\") : literal.toString(true))\n      .join(\" & \");\n    let conclusionString = this.conclusionLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(false) + \"</b>\") : literal.toString(false))\n      .join(\" | \");\n    let contextString = this.contextLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(false) + \"</b>\") : literal.toString(false))\n      .join(\" | \");\n    let premiseStringWithoutBoldness = this.premiseLiterals\n      .map(literal => literal.toString(true))\n      .join(\" & \");\n    let conclusionStringWithoutBoldness = this.conclusionLiterals\n      .map(literal => literal.toString(false))\n      .join(\" | \");\n    let contextStringWithoutBoldness = this.contextLiterals\n      .map(literal => literal.toString(false))\n      .join(\" | \");\n    if(this.conclusionLiterals.length === 0) {\n      conclusionString = \"$false\";\n      conclusionStringWithoutBoldness = \"$false\";\n    }\n\n    // simple heuristic to estimate the length of the separating line between premise and conclusion.\n    const estimatedLengthOfLine = Math.ceil(Math.max(premiseStringWithoutBoldness.length, conclusionStringWithoutBoldness.length, contextStringWithoutBoldness.length) * 0.8);\n    const line = \"\\u2013\".repeat(estimatedLengthOfLine);\n\n    // don't use bold strings if clause is not activated yet\n    if (!isActive) {\n      premiseString = premiseStringWithoutBoldness;\n      conclusionString = conclusionStringWithoutBoldness;\n      contextString = contextStringWithoutBoldness;\n    }\n\n    const implication = this.premiseLiterals.length === 0 ? conclusionString : (premiseString + \"\\n\\u2192\\n\" + conclusionString);\n\n    return this.contextLiterals.length === 0 ? implication : (implication + \"\\n\" + line + \"\\n\" + contextString);\n  }\n}","import { assert } from \"./util\";\n\nexport class Literal {\n\treadonly name: string;\n\treadonly args: Term[];\n\treadonly negated: boolean;\n\tisSelected: boolean;\n\trepresentation: number;\n\thideBracketsAssoc: boolean;\n\tnonStrictForNegatedStrictInequalities: boolean;\n\tliteralInParent: Literal | null;\n\torientationReason: \"user\" | \"inherited\" | \"heuristic\" | \"none\";\n\n\tconstructor(name:string, args: Term[], negated: boolean){\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.negated = negated;\n\t\tthis.isSelected = false;\n\t\tthis.representation = 0; // 0 represents standard representation. Some literals may define other representations\n\t\tthis.hideBracketsAssoc = true;\n\t\tthis.nonStrictForNegatedStrictInequalities = true;\n\t\tthis.literalInParent = null;\n\t\tthis.orientationReason = \"none\";\n\t}\n\n\tsetLiteralInParent(literalInParent: Literal) {\n\t\tthis.literalInParent = literalInParent;\n\t}\n\n\tswitchToNextRepresentation() {\n\t\tif (this.name === \"$less\" || this.name === \"Sub\" || this.name === \"=\") {\n\t\t\tif (this.representation === 0) {\n\t\t\t\tthis.representation = 1;\n\t\t\t} else {\n\t\t\t\tthis.representation = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(negateLiteral: boolean) : string {\n\t\tconst occursNegated = negateLiteral ? !this.negated : this.negated;\n\n\t\tif (this.name === \"=\") {\n\t\t\tassert(this.args.length === 2, \"equalities must have exactly two arguments\");\n\t\t\tconst switchSides = this.representation === 1;\n\t\t\tconst lhs = this.args[switchSides ? 1 : 0].toString(this.hideBracketsAssoc);\n\t\t\tconst rhs = this.args[switchSides ? 0 : 1].toString(this.hideBracketsAssoc);\n\t\t\treturn lhs + (occursNegated ? \" != \" : \" = \") + rhs;\n\t\t}\n\t\tif (this.name === \"$less\" || this.name === \"Sub\") {\n\t\t\tassert(this.args.length === 2, \"inequalities must have exactly two arguments\");\n\t\t\tconst switchSides = this.representation === 1;\n\t\t\tconst lhs = this.args[switchSides ? 1 : 0].toString(this.hideBracketsAssoc);\n\t\t\tconst rhs = this.args[switchSides ? 0 : 1].toString(this.hideBracketsAssoc);\n\t\t\tlet symbol;\n\t\t\tif (switchSides) {\n\t\t\t\tsymbol = occursNegated ? (this.nonStrictForNegatedStrictInequalities ? \" <= \" : \" !> \") : \" > \";\n\t\t\t} else {\n\t\t\t\tsymbol = occursNegated ? (this.nonStrictForNegatedStrictInequalities ? \" >= \" : \" !< \") : \" < \";\n\t\t\t}\n\t\t\treturn lhs + symbol + rhs;\n\t\t}\n\n\t\t// could also use logical-not-symbol: \"\\u00AC\"\n\t\treturn (occursNegated ? \"!\" : \"\") + this.name + \"(\" + this.args.map(arg => arg.toString(this.hideBracketsAssoc)).join(\",\") + \")\";\n\t}\n}\n\nexport class Term {\n\treadonly name: string;\n\treadonly args: Term[];\n\treadonly isVariable: boolean;\n\t\n\tconstructor(name: string, args: Term[]) {\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tconst isVariable = name.startsWith(\"X\")\n\t\tthis.isVariable = isVariable;\n\t\tif(isVariable) {\n\t\t\tassert(this.args.length === 0);\n\t\t}\n\t}\n\n\ttoString(hideBracketsAssoc: boolean): string {\n\t\tlet name = this.name;\n\t\tif(this.name === \"$sum\") {\n\t\t\tname = \"+\";\n\t\t} else if(this.name === \"$uminus\") {\n\t\t\tname = \"-\";\n\t\t}\n\n\t\tif(this.args.length === 0){\n\t\t\treturn name;\n\t\t} else {\n\t\t\tif (name === \"+\"){\n\t\t\t\tconst inner = this.args.map(arg => arg.toString(hideBracketsAssoc)).join(\"+\");\n\t\t\t\tif (hideBracketsAssoc) {\n\t\t\t\t\treturn inner;\n\t\t\t\t} else {\n\t\t\t\t\treturn \"(\" + inner + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn name + \"(\" + this.args.map(arg => arg.toString(hideBracketsAssoc)).join(\",\") + \")\";\n\t\t}\n\t}\n}\n\n\n\n","import {assert} from './util'\nimport {Unit, Formula, Clause} from './unit'\nimport {Literal, Term} from './literal'\n\n// class for parsing Units, Formulas, Clauses, Literals and Terms\nexport class UnitParser {\n\n\tstatic parsePreprocessingUnit(string: string): Unit {\n\t\t// heuristic to determine whether unit is a clause:\n\t\t// if unit only contains certain symbols, it has to be a clause\n\t\t// otherwise, treat it as a formula.\n\t\tconst symbolsAllowedInClauses = /^[a-zA-Z0-9()=,~!$ |']+$/;\n\t\tlet isClause = string.match(symbolsAllowedInClauses);\n\t\n\t\tif(isClause) {\n\t\t  return UnitParser.parseClause(string);\n\t\t} else {\n\t\t  return new Formula(string);\n\t\t}\n\t}\n\n\tstatic parseClause(string: string): Clause {\n\t\tif(string === \"$false\") {\n\t\t\treturn new Clause([]); // empty clause\n\t\t}\n\t\tconst literalStrings = string.split(\" | \")\n\n\t\tconst literals = new Array<Literal>();\n\t\tfor (let i = 0; i < literalStrings.length; i++) {\n\t\t\tliterals.push(UnitParser.parseLiteral(literalStrings[i]));\n\t\t}\n\t\t\n\t\treturn new Clause(literals);\n\t}\n\n\tstatic parseLiteral(string: string): Literal {\n\t\t// need to handle equality separately, since it is written in infix-notation\n\t\t// all other predicates are written in prefix-notation\n\t\tlet equalityPosition = string.search(\"=\");\n\t\tif(equalityPosition !== -1)\n\t\t{\n\t\t\t// Vampire's printing of FOOL-formulas is quite hacky,\n\t\t\t// in particular FOOL-equalities always occur inside brackets, even for top-level literals\n\t\t\t// where the brackets are unnecessary\n\t\t\tif(string[0] === \"(\") {\n\t\t\t\tassert(string[string.length - 1] === \")\");\n\t\t\t\tstring = string.substring(1, string.length - 1);\n\t\t\t\tassert(equalityPosition > 0);\n\t\t\t\tequalityPosition -= 1;\n\t\t\t}\n\t\t\tif(string[equalityPosition - 1] === \"!\") {\n\t\t\t\tassert(string[equalityPosition - 2] === \" \", `negated equality not surrounded by spaces in string ${string}`);\n\t\t\t\tassert(string[equalityPosition + 1] === \" \", `negated equality not surrounded by spaces in string ${string}`);\n\t\t\t\tconst lhsString = string.substring(0, equalityPosition - 2);\n\t\t\t\tconst rhsString = string.substring(equalityPosition + 2, string.length);\n\t\t\t\tconst lhs = UnitParser.parseTerm(lhsString);\n\t\t\t\tconst rhs = UnitParser.parseTerm(rhsString);\n\t\t\t\treturn new Literal(\"=\", [lhs, rhs], true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(string[equalityPosition - 1] === \" \", `equality not surrounded by spaces in string ${string}`);\n\t\t\t\tassert(string[equalityPosition + 1] === \" \", `equality not surrounded by spaces in string ${string}`);\n\t\t\t\tconst lhsString = string.substring(0, equalityPosition - 1);\n\t\t\t\tconst rhsString = string.substring(equalityPosition + 2, string.length);\n\t\t\t\tconst lhs = UnitParser.parseTerm(lhsString);\n\t\t\t\tconst rhs = UnitParser.parseTerm(rhsString);\n\t\t\t\t\n\t\t\t\treturn new Literal(\"=\", [lhs, rhs], false);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst negated = (string[0] === \"~\");\n\t\t\tconst atomString = negated ? string.substring(1) : string;\n\n\t\t\t// parse atom as term first and then convert it to literal\n\t\t\tconst literalTerm = UnitParser.parseTerm(atomString);\n\t\t\treturn new Literal(literalTerm.name, literalTerm.args, negated);\n\t\t}\n\t}\n\n\tstatic parseTerm(string:string): Term {\n\t\t// Part 1: lex tokens\n\t\tlet tokens: string[] = [];\n\t\tlet stringPos = 0;\n\t\twhile(stringPos < string.length) {\n\t\t\tconst char = string[stringPos];\n\t\t\t\n\t\t\tif (char === \"(\" || char === \")\" || char === \",\") {\n\t\t\t\ttokens.push(char);\n\t\t\t\tstringPos = stringPos + 1;\n\t\t\t} else {\n\t\t\t\tlet tokenEnd = stringPos;\n\t\t\t\twhile(tokenEnd < string.length \n\t\t\t\t\t&& string[tokenEnd] !== \"(\" \n\t\t\t\t\t&& string[tokenEnd] !== \")\" \n\t\t\t\t\t&& string[tokenEnd] !== \",\") {\n\t\t\t\t\ttokenEnd = tokenEnd + 1;\n\t\t\t\t}\n\t\t\t\ttokens.push(string.substring(stringPos,tokenEnd));\n\t\t\t\tstringPos = tokenEnd;\n\t\t\t}\n\t\t}\n\n\t\t// Part 2: add brackets after each string token which is not succeeded by brackets (that is, for each constant)\n\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tif(token !== \"(\" && token !== \")\" && token !== \",\"){\n\t\t\t\tif(i+1 === tokens.length || tokens[i+1] !== \"(\") {\n\t\t\t\t\ttokens.splice(i+1,0,\"(\");\n\t\t\t\t\ttokens.splice(i+2,0,\")\");\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\t// Part 3: parse token array\n\t\tlet stack: Array<Array<string|Term>> = [[]];\n\n\t\tfor (let pos = 0; pos < tokens.length; pos++) {\n\t\t\tconst token = tokens[pos];\n\n\t\t\tif(token !== \"(\" && token !== \")\" && token !== \",\")\n\t\t\t{\n\t\t\t\tstack[stack.length - 1].push(token);\n\t\t\t} \n\t\t\telse if (token === \"(\") \n\t\t\t{\n\t\t\t\tstack.push([]);\n\t\t\t}\n\t\t\telse if (token === \")\") \n\t\t\t{\n\t\t\t\tconst args = stack.pop() as Array<string | Term>;\n\t\t\t\tconst name = stack[stack.length - 1].pop();\n\t\t\t\tconst f = new Term(name as string, args as Array<Term>);\n\t\t\t\tstack[stack.length - 1].push(f);\n\t\t\t}\n\t\t}\n\n\t\tassert(stack.length === 1, \"invar violated for string: \" + string);\n\t\t// assert(stack[0].length === 1, \"invar violated for string:\" + string + \":\");\n\t\treturn stack[0][0] as Term;\n\t}\n}","\nimport { assert } from \"./util\";\nimport { Dag } from \"./dag\";\nimport SatNode from \"./sat-node\";\n\n// iterator for traversing DAG, where each node is visited only after all parents are visited\n// implements standard iterative depth-first postorder traversal\nexport class DFPostOrderTraversal {\n\t\n\treadonly dag: Dag;\n\ttodo: Array<number>;\n\tvisited: Set<number>;\n\t\n\tconstructor(dag: Dag) {\n\t\tthis.dag = dag;\n\t\tthis.todo = Array.from(dag.leaves);\n\t\tthis.visited = new Set();\n\t}\n\n\thasNext(): boolean {\n\t\twhile (this.todo.length > 0) {\n\t\t\tconst last = this.todo[length - 1];\n\t\t\tif (this.visited.has(last)) {\n\t\t\t\tthis.todo.pop();\n\t\t\t} else {\n\t\t\t\t// there exists at least one unvisited node\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// returns the next node (the actual node, not its id) for traversal\n\t// note: only call this method after checking for has_next\n\tgetNext(): SatNode {\n\t\twhile (this.todo.length > 0) {\n\t\t\tconst currentId = this.todo[this.todo.length - 1];\n\t\t\tconst currentNode = this.dag.get(currentId);\n\n\t\t\t// if we haven't already visited the current unit\n\t\t\tif (!this.visited.has(currentId)) {\n\t\t\t\tlet existsUnvisitedParent = false;\n\t\t\t\t\n\t\t\t\t// add unprocessed parents to stack for DFS.\n\t\t\t\t// If there is at least one unprocessed parent, don't compute the result\n\t\t\t\t// for current_id now, but wait until those unprocessed parents are processed.\n\t\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\t\t// if we haven't visited the parent yet\n\t\t\t\t\tif (! this.visited.has(parentId)) {\n\t\t\t\t\t\t// add it to the stack\n\t\t\t\t\t\tthis.todo.push(parentId);\n\t\t\t\t\t\texistsUnvisitedParent = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if we already visited all parents, we can visit the node too\n\t\t\t\tif (!existsUnvisitedParent) {\n\t\t\t\t\tthis.visited.add(currentId);\n\t\t\t\t\tthis.todo.pop();\n\t\t\t\t\treturn currentNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.todo.pop();\n\t\t\t}\n\t\t}\n\t\tassert(false, \"We have already iterated through all the inferences, so getNext() should not been called\");\n\t\treturn null as unknown as SatNode;\n\t}\n}\n\n// iterator for traversing DAG, where each node is visited before any parent node is visited\n// implemented as reversed postorder traversal\nexport class ReversePostOrderTraversal {\n\tpostOrder: Array<SatNode>;\n\n\tconstructor(dag: Dag) {\n\t\t// compute post order and save result in postOrder\n\t\tconst it = new DFPostOrderTraversal(dag);\n\t\tthis.postOrder = [];\n\t\twhile (it.hasNext()) {\n\t\t\tthis.postOrder.push(it.getNext() as SatNode);\n\t\t}\n\t}\n\n\thasNext(): boolean {\n\t\treturn this.postOrder.length > 0;\n\t}\n\n\tgetNext(): SatNode {\n\t\tassert(this.hasNext(), \"We have already iterated through all the inferences, so getNext() should not have been called\");\n\t\treturn this.postOrder.pop() as SatNode;\n\t}\n\n}","import { Literal, Term } from \"./literal\";\nimport { assert } from \"./util\";\n\nexport type Substitution = Map<string, Term>;\n\nexport function literalsMatch(literal1: Literal, literal2: Literal, allowSubstitutions: boolean) {\n\tif (allowSubstitutions) {\n\t\treturn isSubstitution(literal1, literal2);\n\t} else {\n\t\treturn isEqual(literal1, literal2);\n\t}\n}\n\nexport function isEqual(literal1: Literal, literal2: Literal): boolean {\n\tif (literal1.name !== literal2.name || literal1.negated !== literal2.negated || literal1.args.length !== literal2.args.length) {\n\t\treturn false;\n\t}\n\tlet success = true;\n\tfor (let i = 0; i < literal1.args.length; i++) {\n\t\tconst arg1 = literal1.args[i];\n\t\tconst arg2 = literal2.args[i];\n\t\tif (!termsAreEqual(arg1,arg2)) {\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// support commutativity of equalities\n\tif (!success && literal1.name === \"=\") {\n\t\tassert(literal1.args.length === 2);\n\t\tsuccess = \n\t\t\ttermsAreEqual(literal1.args[0], literal2.args[1]) &&\n\t\t\ttermsAreEqual(literal1.args[1], literal2.args[0]);\n\t}\n\n\treturn success;\n}\n\nexport function termsAreEqual(f1: Term, f2: Term) {\n\tif (f1.name !== f2.name || f1.args.length !== f2.args.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < f1.args.length; i++) {\n\t\tconst arg1 = f1.args[i];\n\t\tconst arg2 = f2.args[i];\n\t\tif (!termsAreEqual(arg1,arg2)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// returns true if literal1 can be obtained from literal2 by substitution\nexport function isSubstitution(literal1: Literal, literal2: Literal): boolean {\n\tif (literal1.name !== literal2.name || literal1.negated !== literal2.negated || literal1.args.length !== literal2.args.length) {\n\t\treturn false;\n\t}\n\tlet success = true;\n\tconst substitution = new Map<string, Term>();\n\tfor (let i = 0; i < literal1.args.length; i++) {\n\t\tconst arg1 = literal1.args[i];\n\t\tconst arg2 = literal2.args[i];\n\t\tsuccess = computeSubstitution(arg1,arg2, substitution);\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// support commutativity of equalities\n\tif (!success && literal1.name === \"=\") {\n\t\tassert(literal1.args.length === 2);\n\t\tconst substitutionEq = new Map<string, Term>();\n\t\tsuccess = computeSubstitution(literal1.args[0], literal2.args[1], substitutionEq);\n\t\tif (success) {\n\t\t\tsuccess = computeSubstitution(literal1.args[1], literal2.args[0], substitutionEq);\n\t\t}\n\t}\n\t\n\treturn success;\n}\n\n// compute whether f1 can be obtained from f2 using a substitution compatible with substitution\n// if yes, returns true and updates the substitution\n// if no, returns false, and there are no guarantees on the state of substitution\nexport function computeSubstitution(f1: Term, f2: Term, substitution: Substitution): boolean {\n\tif (f1.name === f2.name && f1.args.length === f2.args.length) {\n\t\tfor (let i = 0; i < f1.args.length; i++) {\n\t\t\tconst arg1 = f1.args[i];\n\t\t\tconst arg2 = f2.args[i];\n\t\t\tconst success = computeSubstitution(arg1,arg2, substitution);\n\t\t\tif (!success) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (f2.isVariable) {\n\t\tconst substitutedVariable = substitution.get(f2.name);\n\t\tif (substitutedVariable === undefined) {\n\t\t\tsubstitution.set(f2.name, f1);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn computeSubstitution(f1, substitutedVariable, substitution);\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}","import SatNode from './sat-node';\nimport { assert } from './util';\nimport { UnitParser } from './unit-parser';\nimport { ReversePostOrderTraversal, DFPostOrderTraversal } from \"./traversal\";\nimport { Clause } from './unit';\nimport { literalsMatch } from './substitution';\nimport { Literal } from './literal';\n\nexport class ParsedLine {\n  readonly type: \"preprocessing\" | \"new\" | \"active\" | \"forward reduce\" | \"backward reduce\" | \"replaced by\" | \"using\";\n  readonly id: number;\n  readonly unitString: string;\n  readonly inferenceRule: string;\n  parents: Array<number>;\n  readonly statistics: Map<any, any>; \n\n  constructor(type: \"preprocessing\" | \"new\" | \"active\" | \"forward reduce\" | \"backward reduce\" | \"replaced by\" | \"using\", id: number, unitString: string, inferenceRule: string, parents: Array<number>, statistics: Map<any, any>) {\n    this.type = type;\n    this.id = id;\n    this.unitString = unitString;\n    this.inferenceRule = inferenceRule;\n    this.parents = parents;\n    this.statistics = statistics;\n  }\n}\n\nexport type SatNodeStyle = \"passive\" | \"deleted\" | \"activated\" | \"activated-deleted\" | \"boundary\" | \"boundary-deleted\" | \"preprocessing\" | \"preprocessing-deleted\" | \"theory-axiom\" | 'theory-axiom-deleted' | \"conjecture\";\nexport class Dag {\n\n  // TODO: it seems that the result of Graphviz depends on the order of node- and edge declarations.\n  //       the order of these declarations depends on the order in which the nodes occur in the nodes-Map.\n  //       therefore it could make sense to normalize the order of nodes in the nodes-Map at construction time of the Dag.\n  readonly nodes: Map<number,SatNode>;\n  readonly leaves: Set<number>;\n  readonly mergeMap: Map<number, Array<number>> | null;\n  \n  // invar: if isPassiveDag, then styleMap !== null\n  readonly isPassiveDag: boolean;\n  readonly styleMap: Map<number, SatNodeStyle> | null;\n  readonly activeNodeId: number | null; // the id of the node for which passiveDag was computed\n\n  constructor(nodes: Map<number,SatNode>, mergeMap: Map<number, Array<number>> | null = null, isPassiveDag: boolean = false, styleMap: Map<number, SatNodeStyle> | null = null, activeNodeId: number | null = null) {\n    this.nodes = nodes;\n    this.mergeMap = mergeMap;\n\n    assert(!isPassiveDag || styleMap !== null);\n    assert(!isPassiveDag || activeNodeId !== null);\n    assert(!isPassiveDag || nodes.has(activeNodeId as number));\n\n    this.isPassiveDag = isPassiveDag;\n    this.styleMap = styleMap;\n    this.activeNodeId = activeNodeId;\n\n    // sanity check: key and id of node need to match\n    for (const [nodeId, node] of nodes) {\n      assert(nodeId === node.id, `key ${nodeId} and id ${node.id} of node ${node} don't match!`);\n    }\n\n    // sanity check: each parentId needs to occur in the derivation as node\n    for (const [nodeId, node] of nodes) {\n      for (const parentId of node.parents) {\n        assert(nodes.has(parentId), `node ${nodeId} has parent ${parentId} which does not occur as node in the dag!`);\n      }\n    }\n    // compute leaves\n    const leaves: Set<number> = new Set();\n    const nonLeaves: Set<number> = new Set();\n    \n    for (const node of nodes.values()) {\n      for (const parentId of node.parents) {\n        nonLeaves.add(parentId);\n      }\n    }\n\n    for (const nodeId of nodes.keys()) {\n      if(!nonLeaves.has(nodeId)) {\n        leaves.add(nodeId);\n      }\n    }\n\n    this.leaves = leaves;\n  }\n\n  get(nodeId: number): SatNode {\n    const node = this.nodes.get(nodeId);\n    assert(node !== undefined, \"node doesn't occur in Dag\");\n    return node as SatNode;\n  }\n\n  maximalActiveTime(): number {\n    let max = 0;\n    for (const node of this.nodes.values()) {\n      if (node.activeTime !== null && node.activeTime > max) {\n        max = node.activeTime;\n      }\n    }\n    return max;\n  }\n\n  isEmpty(): boolean {\n    return this.nodes.size === 0;\n  }\n\n  getChildren(nodeId: number): Array<number> {\n    if(!this.nodes.has(nodeId)) {\n      assert(false, \"Node with id \" + nodeId + \" does not occur in Dag\");\n    }\n\n    const children = new Array<number>();\n    for (const node of this.nodes.values()) {\n      for (const parentId of node.parents) {\n        if (parentId === nodeId) {\n          children.push(node.id);\n        }\n      }\n    }\n    return children;\n  }\n\n  numberOfTransitiveActivatedChildren(nodeId: number, currentTime: number) {\n    let counter = 0;\n\n        // use new set to avoid mutating relevantIds\n    const transitiveChildrenIds = new Set<number>([nodeId]);\n\n    // add all transitive children of ids in transitiveChildren to transitiveChildren\n    const iterator = new DFPostOrderTraversal(this);\n    while (iterator.hasNext()) {\n      let currentNode = iterator.getNext();\n\n      // check if currentNode occurs in transitiveChildren or\n      // has a parent which occurs in transitiveChildren\n      let existsRelevantParent = false;\n      for (const parentId of currentNode.parents) {\n        if (transitiveChildrenIds.has(parentId)) {\n          existsRelevantParent = true;\n          break;\n        }\n      }\n      const isRelevant = existsRelevantParent || transitiveChildrenIds.has(currentNode.id);\n      const alreadyGenerated = currentNode.isFromPreprocessing || (currentNode.newTime !== null && currentNode.newTime <= currentTime);\n      if (isRelevant && alreadyGenerated) {\n        // add its id to the set of relevant ids\n        transitiveChildrenIds.add(currentNode.id);\n\n        const alreadyActivated = currentNode.activeTime !== null && currentNode.activeTime <= currentTime;\n        if (currentNode.id !== nodeId && alreadyActivated) {\n          counter = counter + 1;\n        }\n      }\n    }\n\n    return counter;\n  }\n\n  /* we can partition all nodes of the derivation into three sets\n   * 1) inputNodes: the nodes given to Vampire's preprocessing as input\n   * 2) preprocessingResultNodes: the nodes remaining at the end of Vampire's preprocessing, (which are then used as input for saturation)\n   * 3) otherNodes: the nodes generated by saturation\n   *\n   * this function decides for a given node whether it should be treated as input node, using the following idea:\n   * 1) input nodes occur before saturation is started and are therefore tagged with \"isFromPreprocessing\"\n   * 2) preprocessingResultNodes are used as input for saturation, so their newTime is set\n   */ \n  nodeIsInputNode(nodeId: number): boolean {\n    const node = this.get(nodeId);\n\n    if (!node.isFromPreprocessing) {\n      return false;\n    }\n    if(node.newTime !== null) {\n      return false;\n    }\n    return true;\n  }\n\n  // heuristics to determine whether a node is a theory axiom\n  // note: Vampire uses \"theory axiom\" for some of the internal theory axioms\n  // the internal theory axioms added for term algebras do not follow this convention\n  // even more, one of those term algebra axioms (the exhaustiveness axiom) is added as formula (in contrast to all other axioms which are added as clauses)\n  // in particular, the exhaustiveness axiom consists of a formula labelled \"term algebras exhaustiveness\" and a child node which is labelled cnf transformation\n  nodeIsTheoryAxiom(nodeId: number): boolean {\n    const node = this.get(nodeId);\n\n    if (!node.isFromPreprocessing) {\n      return false;\n    }\n    if (node.inferenceRule === \"theory axiom\" || \n        node.inferenceRule === \"term algebras injectivity\" || \n        node.inferenceRule === \"term algebras distinctness\" ||\n        node.inferenceRule === \"term algebras exhaustiveness\" ||\n        (node.parents.length === 1 && this.get(node.parents[0]).inferenceRule ===  \"term algebras exhaustiveness\")) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // either 1) create a new dag given an array of parsed lines and no existing dag,\n  // or     2) extend an existing dag with an array of parsed lines\n  // In case 2) we assume that all the parsedLines are generated during Saturation, i.e. no additional preprocessing occurs.\n  static fromParsedLines(parsedLines: Array<ParsedLine>, existingDag: Dag | null): Dag {\n    const nodes = (existingDag === null) ? new Map<number, SatNode>() : new Map<number, SatNode>(existingDag.nodes);\n\n    let currentNode: SatNode | null = null;\n    let currentTime = (existingDag === null) ? 0 : existingDag.maximalActiveTime();\n\n    let emptyClauseNode: SatNode | null = null;\n\n    for (const line of parsedLines) {\n\n      // some preprocessing nodes have potentially been merged, and there could be parsedLines which still reference the ids of these nodes.\n      // we therefore convert those ids using the merge-map\n      if (existingDag !== null && existingDag.mergeMap !== null) {\n        assert(existingDag.mergeMap.get(line.id) === undefined, `found line with id ${line.id} of node deleted during merge of preprocessing nodes!`);\n        const parentsAfterMerge = new Array<number>();\n        for (const parentId of line.parents) {\n          const mergedParentsOrUndefined = existingDag.mergeMap.get(parentId);\n          if (mergedParentsOrUndefined !== undefined) {\n            parentsAfterMerge.push(...mergedParentsOrUndefined);\n          } else {\n            parentsAfterMerge.push(parentId);\n          }\n        }\n        line.parents = parentsAfterMerge;\n      }\n\n      if (line.type === \"preprocessing\") {\n        // line represents the generation of a clause during preprocessing\n        assert(existingDag === null, \"no new preprocessing lines should occur while extending existing dag with new nodes from saturation\")\n        assert(!nodes.has(line.id), \"each clause must be generated by preprocessing only once\");\n        const unit = UnitParser.parsePreprocessingUnit(line.unitString);\n\n        // hack: Vampire treats a conjecture as input clause, followed by an inference, which transforms the input into a negated conjecture.\n        // we want only the negated conjecture, so we delete the (single) premise of such an inference if it occurs.\n        if (line.inferenceRule === \"negated conjecture\") {\n          assert(line.parents.length === 1);\n          // remove parent from nodes\n          const parent = nodes.get(line.parents[0]);\n          assert(parent !== undefined);\n          assert((parent as SatNode).inferenceRule === \"input\");\n          const success = nodes.delete(line.parents[0]);\n          assert(success);\n          // update parents of current line\n          line.parents = [];\n        }\n\n        currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, true, null, null, null, [], false);\n        nodes.set(currentNode.id, currentNode);\n      }\n      else if (line.type === \"new\") {\n        if (!nodes.has(line.id)) {\n          // line represents the generation of a new clause (which wasn't generated in preprocessing) during saturation\n          \n          // create new node\n          const unit = UnitParser.parseClause(line.unitString);\n          unit.literalsNewEvent = unit.conclusionLiterals;\n          currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, false, currentTime, null, null, [], false);\n          nodes.set(currentNode.id, currentNode);\n\n          if(line.unitString === \"$false\") {\n            emptyClauseNode = currentNode;\n          }\n        } else {\n          // line represents a final clause from preprocessing, which now is added into saturation\n          assert(existingDag === null, \"no new final clauses from preprocessing should occur during the extension of an existing dag\")\n          currentNode = nodes.get(line.id) as SatNode;\n          assert(currentNode.isFromPreprocessing, \"a newly added clause can only already exist if it was generated during preprocessing\");\n          assert(line.inferenceRule === currentNode.inferenceRule, \"inference rule differs between line and existing node\");\n          const unit = UnitParser.parseClause(line.unitString);\n          unit.literalsNewEvent = unit.conclusionLiterals;\n          currentNode.unit = unit;\n          currentNode.newTime = currentTime;\n        }\n      }\n      else if (line.type === \"active\") {\n        // line represents the addition of that clause to active\n        // an active-event gives us the following information about a clause:\n        // - the node was activated at the current time.\n        // - the number of selected literals in the clause, saved in the statistics-object (\"nSel\") of the active-event\n        // - the literals in the clause which are selected: the clause of the active-event satisfies the invariant that the selected literals occur first.\n        // - some statistics about the clause and its derivation, saved in the statistics-object of the active-event\n        assert(nodes.has(line.id), `Found clause with id ${line.id}, which was added to active, but wasn't added to new before. Maybe you forgot to output the new clauses?`);\n        currentNode = nodes.get(line.id) as SatNode;\n        assert(line.id === currentNode.id, \"id differs between line and existing node\");\n        assert(line.inferenceRule === currentNode.inferenceRule, \"inference rule differs between line and existing node\");\n        assert(line.parents.length === currentNode.parents.length, \"number of parents differs between line and existing node\");\n        for (let i = 0; i < line.parents.length; i++) {\n          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);\n        }\n        assert(currentNode.newTime !== null, \"for each event [SA] active ... there has to be an earlier event of the form [SA] new ... with the same clause!\")\n        assert(currentNode.activeTime === null, \"there must only be 1 event of the form [SA] active ... for each clause\");\n        assert(currentNode.unit.type === \"Clause\");\n        const clause = currentNode.unit as Clause;\n        assert(clause.literalsNewEvent !== null);\n\n        // note that the literals in clauseAfterActivation potentially occur in a different order than in clause,\n        // since clauseAfterActivation satisfies the invariant that the selected literals occur first.\n        const clauseAfterActivation = UnitParser.parseClause(line.unitString);\n        assert(clauseAfterActivation.premiseLiterals.length === 0);\n\n        // mpa each literal to a literal in the existing clause\n        // for each selected literal also mark the literal in the existing clause as selected.\n        const nSel = line.statistics.get(\"nSel\");\n        assert(nSel !== undefined && nSel !== null);\n\n        const existingLiteralsActiveOrder = new Array<Literal>();\n        for (let i = 0; i < clauseAfterActivation.conclusionLiterals.length; i++) {\n          const literal = clauseAfterActivation.conclusionLiterals[i];\n          let foundMatch = false;\n          for (const existingLiteral of clause.literalsNewEvent!) {\n            if (literalsMatch(literal, existingLiteral, false)) {\n              existingLiteralsActiveOrder.push(existingLiteral);\n              foundMatch = true;\n              if (i < nSel) {\n                existingLiteral.isSelected = true;\n              }\n              break;\n            }\n          }\n          assert(foundMatch);\n        }\n        clause.literalsActiveEvent = existingLiteralsActiveOrder;\n\n        currentTime = currentTime + 1;\n        currentNode.activeTime = currentTime;\n        currentNode.statistics = line.statistics\n      }\n      else if (line.type === \"forward reduce\" || line.type === \"backward reduce\") {\n        // line represents the removal of a clause from saturation\n        assert(nodes.has(line.id), `Found clause with id ${line.id}, which was deleted, but wasn't added as new before. Maybe you forgot to output the new clauses?`);\n        currentNode = nodes.get(line.id) as SatNode;\n        currentNode.deletionTime = currentTime;\n      }\n      else if (line.type === \"replaced by\" || line.type === \"using\") {\n        // line represents one of the clauses which allowed to remove the clause represented by currentNode from saturation\n        assert(currentNode !== null, \"invar\");\n        (currentNode as SatNode).deletionParents.push(line.id);\n      }\n      else {\n        assert(false, `invalid line: ${line.unitString}`);\n      }\n    }\n\n    // hack: pretend that empty clause was added to passive and then activated\n    // note that this can only be done after all lines are parsed, since a new-event with the empty clause often triggers a deletion-event\n    if (emptyClauseNode !== null) {\n      currentTime = currentTime + 1;\n      emptyClauseNode.activeTime = currentTime;\n      nodes.set(emptyClauseNode.id, emptyClauseNode);\n    }\n\n    const extendedDag = new Dag(nodes, existingDag === null ? null : existingDag.mergeMap);\n\n    return extendedDag;\n  }\n\n  // note: includes nodes which have been activated, but have also been deleted\n  computeActiveNodes(currentTime: number) : Set<number> {\n    const activeNodeIds = new Set<number>();\n    for (const [nodeId, node] of this.nodes) {\n      const nodeIsActive = (node.activeTime !== null && node.activeTime <= currentTime);\n      if (nodeIsActive) {\n        activeNodeIds.add(nodeId);\n      }\n    }\n\n    return activeNodeIds;\n  }\n\n  // Definition: the active dag contains all nodes which occur in the derivation of an already activated node, and all preprocessing nodes\n  computeNodesInActiveDag(currentTime: number) : Set<number> {\n    const nodeIds = this.computeActiveNodes(currentTime);\n\n\t  // add all transitive parents of nodeIds to nodeIds\n\t  const iterator = new ReversePostOrderTraversal(this);\n\t  while (iterator.hasNext()) {\n\t\t  const currentNode = iterator.getNext();\n      const currentNodeId = currentNode.id;\n    \n      if (nodeIds.has(currentNodeId)) {\n        for (const parentId of currentNode.parents) {\n          nodeIds.add(parentId);\n        }\n      }    \n    }\n\n    // add all preprocessing nodes\n    for (const node of this.nodes.values()) {\n      if (node.isFromPreprocessing) {\n        nodeIds.add(node.id);\n      }\n    }\n    \n    return nodeIds;\n  }\n\n  isRefutation(): boolean {\n    for (const node of this.nodes.values()) {\n      if(node.unit.type == \"Clause\" && \n          (node.unit as Clause).premiseLiterals.length == 0 && \n          (node.unit as Clause).conclusionLiterals.length == 0) {\n            return true;\n          }\n    }\n    return false;\n  }\n}","import { assert } from \"./util\";\nimport { Dag, SatNodeStyle } from \"./dag\";\nimport SatNode from \"./sat-node\";\nimport { ReversePostOrderTraversal, DFPostOrderTraversal } from \"./traversal\";\n\n// returns a new dag containing only the nodes which either\n// have an id in relevantIds or\n// are transitive parents of a node with id in relevantIds\nexport function filterNonParents(dag: Dag, relevantIds: Set<number>) {\n\t// use new set to avoid mutating relevantIds\n\tconst transitiveParentIds = new Set(relevantIds);\n\n\t// need to compute remaining nodes\n\tconst remainingNodes = new Map<number, SatNode>();\n\n\t// add all transitive parents of transitive_parents to transitiveParents\n\tconst iterator = new ReversePostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst currentNode = iterator.getNext();\n\t\tconst currentNodeId = currentNode.id;\n\n\t\t// if currentNode is relevant\n\t\tif (transitiveParentIds.has(currentNodeId)) {\n\t\t\t\n\t\t\t// mark parents relevant\n\t\t\tcurrentNode.parents.forEach(parentId => transitiveParentIds.add(parentId));\n\n\t\t\t// add node to remainingNodes\n\t\t\tremainingNodes.set(currentNodeId,currentNode);\n\t\t}\n\t}\n\n\t// create deep copy of nodes\n\t// needed so that layout computation for the transformed dag does not overwrite the layout of the original dag\n\tconst remainingNodesDeepCopy = new Map<number, SatNode>();\n\tfor (const [nodeId,node] of remainingNodes) {\n\t\tremainingNodesDeepCopy.set(nodeId, node.copy());\n\t}\n\treturn new Dag(remainingNodesDeepCopy);\n}\n\n// returns a new dag containing only the nodes which either\n// have an id in relevant_ids or\n// are transitive children of a node with id in relevant_ids.\n// additionally keeps boundary nodes\nexport function filterNonConsequences(dag: Dag, relevantIds: Set<number>) {\n\t// use new set to avoid mutating relevantIds\n\tconst transitiveChildrenIds = new Set<number>(relevantIds);\n\n\t// need to compute remaining nodes\n\tconst remainingNodes = new Map<number, SatNode>();\n\n\t// add all transitive children of ids in transitiveChildren to transitiveChildren\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tlet currentNode = iterator.getNext();\n\n\t\t// check if currentNode occurs in transitiveChildren or\n\t\t// has a parent which occurs in transitiveChildren\n\t\tlet existsRelevantParent = false;\n\t\tfor (const parentId of currentNode.parents) {\n\t\t\tif (transitiveChildrenIds.has(parentId)) {\n\t\t\t\texistsRelevantParent = true;\n\t\t\t}\n\t\t}\n\t\tconst isRelevant = transitiveChildrenIds.has(currentNode.id) || existsRelevantParent;\n\n\t\tif (isRelevant) {\n\t\t\t// add its id to the set of relevant ids\n\t\t\ttransitiveChildrenIds.add(currentNode.id);\n\n\t\t\t// if there exists at least one relevant parent, \n\t\t\tif (existsRelevantParent) {\n\t\t\t\t// introduce a boundary nodes for all nonrelevant parents\n\t\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\t\tif (!transitiveChildrenIds.has(parentId)) {\n\t\t\t\t\t\tconst boundaryNode = createBoundaryNode(dag.get(parentId));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// boundaryNode has currentNode as child and is therefore no leaf\n\t\t\t\t\t\tassert(!dag.leaves.has(boundaryNode.id), \"invar violated. Boundary nodes should only occur as parents of nodes\");\n\t\t\t\t\t\tremainingNodes.set(boundaryNode.id, boundaryNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// otherwise ignore all parents: introduce a copy of the node which has no parents\n\t\t\t\tcurrentNode = createBoundaryNode(currentNode);\n\t\t\t}\n\n\t\t\t// add currentNode to remainingNodes\n\t\t\tremainingNodes.set(currentNode.id, currentNode);\n\t\t} \n\t}\n\n\t// create deep copy of nodes\n\t// needed so that layout computation for the transformed dag does not overwrite the layout of the original dag\n\tconst remainingNodesDeepCopy = new Map<number, SatNode>();\n\tfor (const [nodeId,node] of remainingNodes) {\n\t\tremainingNodesDeepCopy.set(nodeId, node.copy());\n\t}\n\treturn new Dag(remainingNodesDeepCopy);\n}\n\nfunction createBoundaryNode(node: SatNode): SatNode {\n\treturn new SatNode(node.id, node.unit, node.inferenceRule, [], node.statistics, node.isFromPreprocessing, node.newTime, node.activeTime, node.deletionTime, node.deletionParents, node.isBoundary);\n}\n\n// vampire performs preprocessing in multiple steps\n// we are only interested in\n// 1) the input-formulas (and axioms added by Vampire)\n// 2) the clauses resulting from them\n// We therefore merge together all preprocessing steps into single steps\n// from input-formulas/vapire-added-axioms to final-preprocessing-clauses\n// additionally remove all choice axiom parents, since we treat them as part of the background theory\nexport function mergePreprocessing(dag: Dag): Dag {\n\tconst nodes = new Map<number, SatNode>(dag.nodes);\n\tconst nodeIdsToRemove = new Set<number>(); // nodes which should be removed. note that we can't remove them upfront due to the fact that the derivation is a dag and not a tree\n\tconst mergeMap = new Map<number, Array<number>>(); // maps merged nodes to the replacing nodes, needed for extending the dag later\n\n\tconst postOrderTraversal = new DFPostOrderTraversal(dag);\n\twhile (postOrderTraversal.hasNext()) {\n\t\t// note: the ids are still valid, but the nodes may have been replaced by new node\n\t\tconst currentNodeId = postOrderTraversal.getNext().id;\n\t\tconst currentNode = nodes.get(currentNodeId) as SatNode;\n\n\t\t// if there is a preprocessing node n1 with a parent node n2 which has itself a parent node n3,\n\t\t// then replace n2 by n3 in the parents of n1 and add n2 to the nodes which should be removed\n\t\tif (currentNode.isFromPreprocessing) {\n\t\t\tconst updatedParents = new Array<number>();\n\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\tconst parentNode = nodes.get(parentId) as SatNode;\n\t\t\t\tassert(parentNode.isFromPreprocessing, \"invariant violated\");\n\n\t\t\t\tif (parentNode.parents.length === 0) {\n\t\t\t\t\t// small optimization: remove choice axioms, which should not been added to the proof by Vampire in the first place\n\t\t\t\t\tif (parentNode.inferenceRule === \"choice axiom\") {\n\t\t\t\t\t\tnodeIdsToRemove.add(parentId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdatedParents.push(parentId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (const parent2Id of parentNode.parents) {\n\t\t\t\t\t\tconst parent2Node = nodes.get(parent2Id) as SatNode;\n\t\t\t\t\t\tassert(parent2Node.isFromPreprocessing, \"invariant violated\");\n\t\t\t\t\t\tupdatedParents.push(parent2Id);\n\t\t\t\t\t}\n\t\t\t\t\tnodeIdsToRemove.add(parentId);\n\t\t\t\t\tmergeMap.set(parentId, parentNode.parents);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst updatedNode = new SatNode(currentNode.id, currentNode.unit, currentNode.inferenceRule, updatedParents, currentNode.statistics, currentNode.isFromPreprocessing, currentNode.newTime, currentNode.activeTime, currentNode.deletionTime, currentNode.deletionParents, currentNode.isBoundary);\n\t\t\tnodes.set(currentNodeId, updatedNode);\n\t\t}\n\t}\n\n\t// remove merged nodes\n\tfor (const nodeIdToRemove of nodeIdsToRemove) {\n\t\tconst success = nodes.delete(nodeIdToRemove);\n\t\tassert(success, \"invar violated\");\n\t}\n\n\treturn new Dag(nodes, mergeMap);\n}\n\n// preconditions:\n// - selectionIds contains only ids from nodes which either 1) have already been activated or 2) are final preprocessing clauses\n// - selectionIds must contain at least one element\nexport function passiveDagForSelection(dag: Dag, selectionIds: Array<number>, currentTime: number): Dag {\n\tassert(selectionIds.length > 0);\n\tconst selectionIdsSet = new Set(selectionIds);\n\n\t// Part 1: for each passive node n, we consider the transitive parents p_1,...p_k occuring in the activeDag, \n\t// such that for each parent p_i no other node inbetween n and p_i occurs in the activeDag. If selectionId \n\t// is a subset of {p_1,...,p_k}, then n is added to foundNodes\n\tconst foundNodes = new Set<number>();\n\n\tconst idToActiveDagParents = new Map<number, Set<number>>();\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst node = iterator.getNext();\n\t\tconst nodeId = node.id;\n\n\t\tconst activeDagParents = new Set<number>();\n\n\t\tconst nodeIsInActiveDag = ((node.activeTime !== null && node.activeTime <= currentTime) || node.isFromPreprocessing);\n\t\tif(nodeIsInActiveDag) {\n\t\t\tif (selectionIdsSet.has(nodeId)) {\n\t\t\t\tactiveDagParents.add(nodeId);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const parentId of node.parents) {\n\t\t\t\tconst activeDagParentsParent = idToActiveDagParents.get(parentId);\n\t\t\t\tassert(activeDagParentsParent !== undefined);\n\t\t\t\tfor (const activeDagParent of activeDagParentsParent!) {\n\t\t\t\t\tactiveDagParents.add(activeDagParent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if node is passive and each clause from selection occurs in activeDagParents, then add node to foundNodes\n\t\t\tconst nodeIsInPassive = ((node.newTime !== null && node.newTime <= currentTime) && !(node.activeTime !== null && node.activeTime <= currentTime) && !(node.deletionTime !== null && node.deletionTime <= currentTime));\n\t\t\tif (nodeIsInPassive) {\n\t\t\t\tif (activeDagParents.size === selectionIdsSet.size) {\n\t\t\t\t\tfoundNodes.add(nodeId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tidToActiveDagParents.set(nodeId, activeDagParents);\n\t}\n\t\n\t// Part 2:\n\t// we now know the set of passive nodes, so\n\t// - collect all nodes participating in the derivation of the passive nodes from nodes in the current activeDag\n\t// - compute for each such node its style\n\tconst passiveDagNodes = new Map<number, SatNode>();\n\tconst nodePartition = new Map<number, SatNodeStyle>();\n\n\tconst relevantNodes = new Set<number>(foundNodes);\n\n\t// additionally display each node from selection, even if no passive node is generated by the node\n\tfor (const nodeId of selectionIds) {\n\t\trelevantNodes.add(nodeId);\n\t}\n\n\tconst iterator2 = new ReversePostOrderTraversal(dag);\n\twhile (iterator2.hasNext()) {\n\t\tconst node = iterator2.getNext();\n\t\tconst nodeId = node.id;\n\n\t\tif (relevantNodes.has(nodeId)) {\n\t\t\tconst isDeleted = (node.deletionTime !== null && node.deletionTime <= currentTime);\n\n\t\t\t// compute whether the derivation should be extended with the parents of the node, and compute the style of the node\n\t\t\tlet isBoundary;\n\t\t\tlet style;\n\t\t\tif (foundNodes.has(nodeId)) {\n\t\t\t\tassert(!isDeleted);\n\t\t\t\tif (node.isFromPreprocessing) {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = \"passive\";\n\t\t\t\t} else {\n\t\t\t\t\tisBoundary = false;\n\t\t\t\t\tstyle = \"passive\";\n\t\t\t\t}\n\t\t\t} else if (dag.nodeIsTheoryAxiom(nodeId)) {\n\t\t\t\tisBoundary = true;\n\t\t\t\tstyle = isDeleted ? \"theory-axiom-deleted\" : \"theory-axiom\";\n\t\t\t} else if (node.isFromPreprocessing) {\n\t\t\t\tif (node.inferenceRule === \"negated conjecture\") {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = \"conjecture\";\n\t\t\t\t} else {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = isDeleted ? \"preprocessing-deleted\" : \"preprocessing\";\n\t\t\t\t}\n\t\t\t} else if (node.activeTime !== null && node.activeTime <= currentTime) {\n\t\t\t\tisBoundary = true;\n\t\t\t\tstyle = isDeleted ? \"activated-deleted\" : \"activated\";\n\t\t\t} else {\n\t\t\t\tisBoundary = false;\n\t\t\t\tstyle = \"deleted\";\n\t\t\t}\n\n\t\t\tif (isBoundary) {\n\t\t\t\tpassiveDagNodes.set(nodeId, createBoundaryNode(node));\n\t\t\t} else {\n\t\t\t\tpassiveDagNodes.set(nodeId, node.copy()); // copy node so that positioning passiveDag will not change positioning of original dag\n\t\t\t\tfor (const parent of node.parents) {\n\t\t\t\t\trelevantNodes.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodePartition.set(nodeId, style);\n\t\t}\n\t}\n\n\tconst passiveDag = new Dag(passiveDagNodes, null, true, nodePartition, selectionIds[0]);\n\treturn passiveDag;\n}\n\n  // returns null if node was not derived using simplification\n  // returns id of original node if node was derived using simplification\n  // TODO: we don't know the complete set of simplifying inference rules, since the current set could be extended in the future. Nonetheless we know the standard simplifying and generating inference rules, so we could use that knowledge to speed up the computation of this function.\n  function nodeWasDerivedUsingSimplification(dag: Dag, node: SatNode): SatNode | null {\n    // one of the parents p of node n needs to satisfy the following four properties (independently from the currentTime):\n    for (const parentId of node.parents) {\n      const parent = dag.get(parentId);\n      // 1) n has been added to saturation and p has been deleted\n      // 2) the deletionTime of p matches the newTime of n.\n      // 3) the first deletion parent of p is n\n      // 4) let P be the set of parents of n other than p. Then the deletion parents of p are n and P.\n      if (node.newTime !== null && parent.deletionTime !== null && parent.deletionTime === node.newTime && parent.deletionParents[0] === node.id && node.parents.length === parent.deletionParents.length) {\n        const set1 = new Set<number>(node.parents);\n        set1.delete(parentId);\n        const set2 = new Set<number>(parent.deletionParents);\n        set2.delete(parent.deletionParents[0]);\n        let otherParentsMatch = true;\n        for (const e of set1) {\n          if (!set2.has(e)) {\n            otherParentsMatch = false;\n          }\n        }\n        if (otherParentsMatch) {\n          return parent;\n        }\n      }\n    }\n    return null;\n  }","import Viz from 'viz.js';\nimport {Module, render} from 'viz.js/full.render.js';\n\nexport async function runViz(dotString) {\n\tlet viz = new Viz({Module, render});\n\n\treturn viz\n\t\t.renderString(dotString, {format: 'plain'})\n\t\t.then((result) => {\n\t\treturn result;\n\t\t})\n\t\t.catch((error) => {\n\t\tviz = new Viz({Module, render});\n\t\tconsole.error(error);\n\t\t});\n};","import { assert } from '../model/util';\nimport { Dag } from '../model/dag';\nimport { runViz } from './callViz';\nimport SatNode from './sat-node';\n\nconst PLAIN_PATTERN = /^(\\d+) ([0-9.]+) ([0-9.]+).*$/g;\n\nexport class VizWrapper {\n\n  // first computes the positions for the nodes while ignoring the position given as parameter.\n  // then, all node positions are shifted by the same amount so that one of the nodes \n  // occurs closely under the position given as parameter\n  static async layoutNodesAtPosition(nodes: Map<number, SatNode>, position: [number, number]) {\n    // 1) layout new nodes while ignoring existing nodes\n    await VizWrapper.layoutNodes(nodes);\n\n    // 2) find a source node of the dag of newly generated nodes\n    let sourceNode: SatNode | null = null;\n    for (const node of nodes.values()) {\n      let isSourceNode = true;\n      for (const parentId of node.parents) {\n        if (nodes.has(parentId)) {\n          isSourceNode = false;\n          break;\n        }\n      }\n      if (isSourceNode) {\n        sourceNode = node;\n        break;\n      }\n    }\n    assert(sourceNode !== null);\n    assert((sourceNode as SatNode).position !== null);\n\n    // 3) shift subgraph of newly generated nodes, so that the source node of the subgraph\n    //    is shifted to a position closely under the position indicated by the positioning hint.\n    const [posSelectedX, posSelectedY] = position;\n    const [posSourceX, posSourceY] = (sourceNode as SatNode).position as [number, number];\n    const deltaX = posSelectedX-posSourceX;\n    const deltaY = (posSelectedY - posSourceY) - 1;\n    for (const node of nodes.values()) {\n      assert(node.position != null);\n      const position = node.position as [number, number];\n      node.position = [position[0] + deltaX, position[1] + deltaY];\n    }\n  }\n\n  static async layoutDag(dag: Dag, onlyActiveDag: boolean) {\n    // generate dot string\n    const dotString = VizWrapper.dagToDotString(dag, onlyActiveDag);\n    \n    // use viz to compute layout for dag given as dotstring\n    // note that viz returns the layout as a string\n    const layoutString = await runViz(dotString);\n\n    // parse the layout string into array of network-nodes\n    VizWrapper.parseLayoutString(layoutString, dag.nodes);\n  };\n\n  static async layoutNodes(nodes: Map<number, SatNode>) {\n    // generate dot string\n    const dotString = VizWrapper.nodesToDotString(nodes);\n\n    // use viz to compute layout for nodes given as dotstring\n    // note that viz returns the layout as a string\n    const layoutString = await runViz(dotString);\n\n    // parse the layout string into array of network-nodes\n    VizWrapper.parseLayoutString(layoutString, nodes);\n  }\n\n  // encodes layout-problem into dot-language\n  // the solution to the layout-problem contains a position for each node, which either\n  // - is a preprocessing node\n  // - occurs in the derivation of at least one activated clause\n  static dagToDotString(dag: Dag, onlyActiveDag: boolean): string {\n    const nodesInActiveDag = onlyActiveDag ? dag.computeNodesInActiveDag(Number.MAX_SAFE_INTEGER) : null;\n\n    const inputStrings = new Array<string>();\n    const preprocessingStrings = new Array<string>();\n    const otherStrings = new Array<string>();    \n    for (const node of dag.nodes.values()) {\n      assert(node.position === null, \"the dag has already been layouted!\");\n      if (node.isFromPreprocessing) {\n        if(dag.nodeIsInputNode(node.id)) {\n          inputStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        } else {\n          preprocessingStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        }\n      } else  {\n        if (!onlyActiveDag || (nodesInActiveDag as Set<number>).has(node.id)) {\n          otherStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        }\n      }\n    }\n\n    const edgeStrings = new Array<string>();\n    for (const node of dag.nodes.values()) {\n      if (!onlyActiveDag || (nodesInActiveDag as Set<number>).has(node.id)) {\n        for (const parentId of node.parents) {\n          edgeStrings.push(`${parentId} -> ${node.id}`)\n        }\n      }\n    }\n\n    const inputString = \"   subgraph inputgraph {\\n      rank=source;\\n      \" + inputStrings.join(\";\\n      \") + \"\\n   }\";\n    const preprocessingString = \"   subgraph preprocessinggraph {\\n      rank=same;\\n      \" + preprocessingStrings.join(\";\\n      \") + \"\\n   }\";\n    const otherstring = \"   subgraph othergraph {\\n      \" + otherStrings.join(\";\\n      \") + \"\\n   }\";\n    const edgeString = edgeStrings.join(\";\\n   \");\n\n    const dotString =  \"digraph {\\n\\n\" + inputString + \"\\n\\n\" + preprocessingString + \"\\n\\n\" + otherstring + \"\\n\\n   \" + edgeString + \"\\n}\";\n    \n    return dotString;\n  };\n\n  static nodesToDotString(nodes: Map<number, SatNode>): string {\n    const nodeStrings = new Array<string>();\n    for (const node of nodes.values()) {\n      assert(node.position === null, \"the node has already been layouted!\");\n      nodeStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n    }\n\n    const edgeStrings = new Array<string>();\n    for (const node of nodes.values()) {\n      for (const parentId of node.parents) {\n        if (nodes.has(parentId)) {\n          edgeStrings.push(`${parentId} -> ${node.id}`)\n        }\n      }\n    }\n\n    const dotString =  \"digraph {\\n   \" + nodeStrings.join(\";\\n   \") + \"\\n\\n   \" + edgeStrings.join(\";\\n   \") + \"\\n}\";\n    return dotString;\n  };\n\n  static parseLayoutString(layoutString: string, nodes: Map<number, SatNode>) {\n    let firstEdgeLineIndex = layoutString.includes('\\nedge') ? layoutString.indexOf('\\nedge') : layoutString.length;\n    // split layoutString to array of strings describing positions of nodes\n    const parsedNodeLines = layoutString\n      .substr(0, firstEdgeLineIndex) // ignore remaining part of string describing edges\n      .split('\\nnode ') //split lines\n      .slice(1) // ignore first line describing graph\n      .map(line => line.substr(0, line.indexOf('\"'))) // ignore remaining part of line causing problems with line breaks\n      .map((line) => line.matchAll(PLAIN_PATTERN).next().value); // parse each remaining line\n    parsedNodeLines.forEach(line => {\n      assert(line !== undefined); // check that each remaining line was successfully parsed\n\t  });\n\t\n    // update SatNode for each nodeString\n    for (const parsedNodeLine of parsedNodeLines) {\n      const [, idString, xString, yString] = parsedNodeLine;\n      const id = parseInt(idString, 10);\n      const x = parseFloat(xString);\n      const y = parseFloat(yString);\n      const node = nodes.get(id) as SatNode;\n      node.position = [x,y];\n    }\n  }\n}","import { Dag } from \"./dag\";\nimport { Clause } from \"./unit\";\nimport { Literal } from \"./literal\";\nimport { assert } from \"./util\";\nimport { literalsMatch } from \"./substitution\";\nimport { DFPostOrderTraversal } from \"./traversal\";\n\n// inferences, where\n// 1) clause and parent clause have same number of literals\n// 2) rewritten literals occur in the same position as the corresponding literal in the parent clause\nfunction computeParentLiteralsCase1(literals: Array<Literal>, parentLiterals: Array<Literal>) {\n\tassert(literals.length === parentLiterals.length);\n\n\tfor (let i = 0; i < literals.length; i++) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i];\n\t\t\n\t\tliteral.setLiteralInParent(parentLiteral);\n\t}\n}\n\n// inferences which remove exactly one literal, where the order of the remaining literals is not changed\n// need to find the position where the literals were removed\n// note: this may compute a wrong matching if a literal in the side-part of the clause matches a deleted literal\n//       in this case the wrongly matched literals in the parent are pairwise unifiable, so a sane user would assign to all of them the same orientation.\n//       in particular the wrong matching should not affect the orientation-heuristic in practice\nfunction computeParentLiteralsCase2(literals: Array<Literal>, parentLiterals: Array<Literal>, allowSubstitutions: boolean, allowMultipleRemovals: boolean) {\n\tassert(allowMultipleRemovals ? (literals.length < parentLiterals.length) : (literals.length + 1 === parentLiterals.length));\n\n\tlet foundRemovedLit = false;\n\tlet i = 0;\n\tlet j = 0;\n\twhile (i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[j];\n\n\t\tconst success = literalsMatch(literal, parentLiteral, allowSubstitutions);\n\n\t\tif (success) {\n\t\t\tliteral.setLiteralInParent(parentLiteral);\n\t\t\ti = i + 1;\n\t\t\tj = j + 1;\n\t\t} else {\n\t\t\tassert(!foundRemovedLit || allowMultipleRemovals, `case 2 error:\\n${literals.toString()}\\n${parentLiterals.toString()}`);\n\t\t\tfoundRemovedLit = true;\n\t\t\tj = j + 1;\n\t\t}\n\t}\n}\n\n// inferences, which rewrite exactly one literal, and shift that literal to the first position in literals\n// need to find the position where the literal was rewritten\n// note: this may compute a wrong matching if a literal in the side-part of the clause matches the rewritten literal in the parent\n//       in this case the wrongly matched literals in the parent are pairwise unifiable, so a sane user would assign to all of them the same orientation.\n//       in particular the wrong matching should not affect the orientation-heuristic in practice\nfunction computeParentLiteralsCase3(literals: Array<Literal>, parentLiterals: Array<Literal>, allowSubstitutions: boolean) {\n\tassert(literals.length === parentLiterals.length);\n\n\tlet foundRewrittenLiteral = false;\n\tlet i = 1;\n\t// first shifted matchings can occur\n\twhile(i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i - 1];\n\n\t\tif (literalsMatch(literal, parentLiteral, allowSubstitutions)) {\n\t\t\tliteral.setLiteralInParent(parentLiteral);\n\t\t\ti = i + 1;\n\t\t} else {\n\t\t\t// shifted matching failed, so parentLiterals[i - 1] must be rewrittenLiteral\n\t\t\tliterals[0].setLiteralInParent(parentLiterals[i - 1]);\n\t\t\tfoundRewrittenLiteral = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// corner case where rewritten literal is last element of parent clause and therefore has no failing shifted matching\n\tif (!foundRewrittenLiteral) {\n\t\tassert(i === literals.length);\n\t\tliterals[0].setLiteralInParent(parentLiterals[parentLiterals.length - 1]);\n\t}\n\t// now nonshifted matchings can occur\n\twhile(i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i];\n\t\tassert(literalsMatch(literal, parentLiteral, allowSubstitutions));\n\t\tliteral.setLiteralInParent(parentLiteral);\n\t\ti = i + 1;\n\t}\n}\n\n\nexport function computeParentLiterals(dag: Dag) {\n\tfor (const node of dag.nodes.values()) {\n\t\tif (!node.isBoundary && node.unit.type === \"Clause\") {\n\t\t\tconst clause = node.unit as Clause;\n\n\t\t\tif (node.inferenceRule === \"evaluation\" ||\n\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras injectivity\" && node.parents.length == 1) ||\n\t\t\t\tnode.inferenceRule === \"subsumption resolution\" ||\n\t\t\t\tnode.inferenceRule === \"equality resolution\" ||\n\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras distinctness\" && node.parents.length == 1) ||\n\t\t\t\tnode.inferenceRule === \"forward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"equality factoring\") {\n\t\t\t\tassert(node.parents.length > 0);\n\n\t\t\t\t// hack to deal with the inconsistent implementation of Vampire:\n\t\t\t\t// backward demodulation is the only simplifying inference where the main premise does not occur as first parent\n\t\t\t\tconst hasSwitchedParents = node.inferenceRule === \"backward demodulation\"\n\t\t\t\tconst parent = dag.get(node.parents[hasSwitchedParents ? 1 : 0]);\n\n\t\t\t\t// only compute literal matchings for clauses\n\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\n\t\t\t\t\t// compute literal ordering at the timepoint where clause was generated\n\t\t\t\t\t// note that the active-event can change the order of literals (since at this point the selected literals are computed and shifted to the front)\n\t\t\t\t\tassert(node.newTime !== null);\n\t\t\t\t\tassert(parent.newTime !== null);\n\t\t\t\t\tconst parentWasAlreadyActivated = parent.activeTime !== null && parent.activeTime <= node.newTime!;\n\t\t\t\t\tconst parentLiterals = parentWasAlreadyActivated ? parentClause.literalsActiveEvent! : parentClause.literalsNewEvent!;\n\t\t\t\t\tconst literals = clause.literalsNewEvent!;\n\t\t\t\t\tassert(parentLiterals !== null);\n\t\t\t\t\tassert(literals !== null);\n\n\t\t\t\t\t// compute the literal-matchings\n\t\t\t\t\t// in full generality, this computation would be computationally expensive and a lot of implementation effort\n\t\t\t\t\t// instead, we hardcode computations of matchings for the most important inference rules implemented in Vampire, and don't compute matchings for other inferences\n\t\t\t\t\tif ((node.inferenceRule === \"evaluation\" && literals.length === parentLiterals.length) || \n\t\t\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"term algebras injectivity\") {\n\n\t\t\t\t\t\tcomputeParentLiteralsCase1(literals, parentLiterals);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"subsumption resolution\" || \n\t\t\t\t\t\tnode.inferenceRule === \"equality resolution\" || \n\t\t\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"term algebras distinctness\" ||\n\t\t\t\t\t\t(node.inferenceRule === \"evaluation\" && literals.length + 1 === parentLiterals.length)) {\n\n\t\t\t\t\t\tconst allowSubstitutions = node.inferenceRule === \"equality resolution\" || node.inferenceRule === \"factoring\";\n\t\t\t\t\t\tconst allowMultipleRemovals = node.inferenceRule === \"trivial inequality removal\" || node.inferenceRule === \"duplicate literal removal\";\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals, parentLiterals, allowSubstitutions, allowMultipleRemovals);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"forward demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"equality factoring\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst allowSubstitutions = node.inferenceRule === \"equality factoring\";\n\t\t\t\t\t\tcomputeParentLiteralsCase3(literals, parentLiterals, allowSubstitutions);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.inferenceRule === \"resolution\" ||\n\t\t\t\tnode.inferenceRule === \"superposition\") {\n\t\t\t\tassert(node.parents.length == 2);\n\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\n\t\t\t\t// only compute literal matchings for clauses\n\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\n\t\t\t\t\t// compute literal ordering at the timepoint where clause was generated\n\t\t\t\t\t// note again that the active-event can change the order of literals (since at this point the selected literals are computed and shifted to the front)\n\t\t\t\t\tassert(node.newTime !== null);\n\t\t\t\t\tassert(leftNode.newTime !== null);\n\t\t\t\t\tassert(rightNode.newTime !== null);\n\t\t\t\t\tconst leftWasAlreadyActivated = leftNode.activeTime !== null && leftNode.activeTime <= node.newTime!;\n\t\t\t\t\tconst rightWasAlreadyActivated = rightNode.activeTime !== null && rightNode.activeTime <= node.newTime!;\n\t\t\t\t\tconst leftLiterals = leftWasAlreadyActivated ? leftClause.literalsActiveEvent! : leftClause.literalsNewEvent!;\n\t\t\t\t\tconst rightLiterals = rightWasAlreadyActivated ? rightClause.literalsActiveEvent! : rightClause.literalsNewEvent!;\n\t\t\t\t\tconst literals = clause.literalsNewEvent!;\n\t\t\t\t\tassert(leftLiterals !== null);\n\t\t\t\t\tassert(rightLiterals !== null);\n\t\t\t\t\tassert(literals !== null);\n\t\t\t\t\tassert(leftLiterals.length > 0);\n\t\t\t\t\tassert(rightLiterals.length > 0);\n\n\t\t\t\t\tif (node.inferenceRule === \"resolution\") {\n\t\t\t\t\t\tassert(literals.length + 2 === leftLiterals.length + rightLiterals.length);\n\n\t\t\t\t\t\t// compute matchings separately for literals coming from leftLiterals resp. rightLiterals\n\t\t\t\t\t\t// split denotes the first position in literals with a literal coming from rightLiterals\n\t\t\t\t\t\tconst split = leftLiterals.length - 1;\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(0, split), leftLiterals, true, false);\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(split, literals.length), rightLiterals, true, false);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"superposition\") {\n\t\t\t\t\t\tassert(literals.length + 1 === leftLiterals.length + rightLiterals.length);\n\n\t\t\t\t\t\t// compute matchings separately for literals coming from leftLiterals resp. rightLiterals\n\t\t\t\t\t\t// split denotes the first position in literals with a literal coming from rightLiterals\n\t\t\t\t\t\tconst split = leftLiterals.length;\n\t\t\t\t\t\tcomputeParentLiteralsCase3(literals.slice(0, split), leftLiterals, true);\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(split, literals.length), rightLiterals, true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// update in the given dag:\n// - literal orientations\n// - literal representations\n// - ordering of literals in premises and conclusions\n// if changedClauseId is null, update all nodes in the dag\n// if changedClauseId is the id of a clause, update the node and all children of the node\n// Precondition: computeParentLiterals was already called on the current dag\nexport function computeClauseRepresentation(dag: Dag, changedClauseId: number | null): Set<number> {\n\tassert(changedClauseId === null || dag.nodes.has(changedClauseId));\n\n\tconst changedClauses = new Set<number>();\n\tif (changedClauseId !== null) {\n\t\tchangedClauses.add(changedClauseId);\n\t}\n\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tlet node = iterator.getNext();\n\n\t\tif (!node.isBoundary && node.unit.type === \"Clause\") {\n\t\t\tconst clause = node.unit as Clause;\n\n\t\t\t// compute whether clause should be updated. This is the case if\n\t\t\t// 1) all nodes should be updated (since changedClauseId === null)\n\t\t\t// 2) the node is changedClauseId\n\t\t\t// 3) a parent of node was changed\n\t\t\tlet update = changedClauseId === null || node.id === changedClauseId;\n\t\t\tif (!update) {\n\t\t\t\tfor (const parentId of node.parents) {\n\t\t\t\t\tif (changedClauses.has(parentId)) {\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Part 1: partition literals into premise and conclusion and compute literal-representation\n\t\t\t// Hack: Vampire by default uses \"equality resolution with deletion\" as inference rule during preprocessing.\n\t\t\t//       Unfortunately the produced inference is named \"equalityresolution\" and therefore clashes with\n\t\t\t//       inferences produced by the generating inference rule with the same name.\n\t\t\t//       We therefore check that inferences with name \"equality resolution\" are not \"equality resolution with deletion\"-inferences.\n\t\t\tconst isEqualityResolutionWithDeletion = node.inferenceRule === \"equality resolution\" && dag.get(node.parents[0]).isFromPreprocessing === true;\n\t\t\tconst propagateSingleParent = node.inferenceRule === \"subsumption resolution\" ||\n\t\t\t\t(node.inferenceRule === \"equality resolution\" && !isEqualityResolutionWithDeletion) ||\n\t\t\t\tnode.inferenceRule === \"equality factoring\" ||\n\t\t\t\tnode.inferenceRule === \"forward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\tnode.inferenceRule === \"evaluation\" ||\n\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras injectivity\" && node.parents.length == 1) ||\n\t\t\t\t(node.inferenceRule === \"term algebras distinctness\" && node.parents.length == 1);\n\t\t\tconst propagateTwoParents = node.inferenceRule === \"resolution\" ||\n\t\t\t\tnode.inferenceRule === \"superposition\";\n\n\t\t\tconst premiseLiterals = new Array<Literal>();\n\t\t\tconst conclusionLiterals = new Array<Literal>();\n\t\t\tconst contextLiterals = new Array<Literal>();\n\t\t\tfor (const literal of clause.premiseLiterals.concat(clause.conclusionLiterals, clause.contextLiterals)) {\n\n\t\t\t\tlet orientation: \"premise\" | \"conclusion\" | \"context\" | null = null;\n\n\t\t\t\tconst parentLiteral = literal.literalInParent;\n\t\t\t\tif (literal.orientationReason !== \"user\" && (propagateSingleParent || propagateTwoParents)) {\n\t\t\t\t\tassert(parentLiteral !== null);\n\t\t\t\t\t// propagate orientation and representation from parent literal\n\t\t\t\t\tliteral.representation = parentLiteral!.representation;\n\t\t\t\t\tif (propagateSingleParent) {\n\t\t\t\t\t\tassert(node.parents.length > 0);\n\t\t\t\t\t\tconst hasSwitchedParents = node.inferenceRule === \"backward demodulation\"\n\t\t\t\t\t\tconst parent = dag.get(node.parents[hasSwitchedParents ? 1 : 0]);\n\n\t\t\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\t\t\t\t\t\t\t// figure out whether parentLiteral occurs in premise or conclusion and set orientation accordingly\n\t\t\t\t\t\t\tif (parentClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (parentClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert(parentClause.contextLiterals.find(l => l === parentLiteral));\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (propagateTwoParents) {\n\t\t\t\t\t\tassert(node.parents.length == 2);\n\t\t\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\t\t\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\t\t\t\t\t\t\t// figure out whether parentLiteral occurs in premise or conclusion of left or right premise and set orientation accordingly\n\t\t\t\t\t\t\tif (leftClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (leftClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else if (leftClause.contextLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t} else if (rightClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (rightClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert(rightClause.contextLiterals.find(l => l === parentLiteral));\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tliteral.orientationReason = \"inherited\"\n\t\t\t\t}\n\n\t\t\t\t// otherwise decide whether current orientation should be kept or whether it should be computed using a heuristic\n\t\t\t\telse if (literal.orientationReason !== \"none\" ) {\n\t\t\t\t\tif (clause.premiseLiterals.find(l => l === literal)) {\n\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t} else if (clause.conclusionLiterals.find(l => l === literal)) {\n\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(clause.contextLiterals.find(l => l === literal))\n\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// use heuristic to compute orientation\n\t\t\t\t\tif (literal.negated && literal.name !== \"=\") {\n\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t}\n\t\t\t\t\tliteral.orientationReason = \"heuristic\";\n\t\t\t\t}\n\n\t\t\t\tif (orientation === \"premise\") {\n\t\t\t\t\tpremiseLiterals.push(literal);\n\t\t\t\t} else if (orientation === \"conclusion\") {\n\t\t\t\t\tconclusionLiterals.push(literal);\n\t\t\t\t} else {\n\t\t\t\t\tassert(orientation === \"context\");\n\t\t\t\t\tcontextLiterals.push(literal);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Part 2: order literals according to the order of literals in the parents\n\t\t\t// only sort if no manually oriented literal in clause\n\t\t\tlet existsUserOrientedLiteral = false;\n\t\t\tfor (const literal of clause.premiseLiterals.concat(clause.conclusionLiterals, clause.contextLiterals)) {\n\t\t\t\tif (literal.orientationReason === \"user\") {\n\t\t\t\t\texistsUserOrientedLiteral = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!existsUserOrientedLiteral && propagateSingleParent) {\n\t\t\t\tconst hasSwitchedParents = node.inferenceRule === \"backward demodulation\"\n\t\t\t\tconst parent = dag.get(node.parents[hasSwitchedParents ? 1 : 0]);\n\t\t\t\t\n\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\n\t\t\t\t\t// generate map parentLiteral -> indexInPremise\n\t\t\t\t\tconst premiseIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map parentLiteral -> indexInConclusion\n\t\t\t\t\tconst conclusionIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map parentLiteral -> indexInContext\n\t\t\t\t\tconst contextIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// sort premise, conclusion and context\n\t\t\t\t\tpremiseLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = premiseIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = premiseIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tconclusionLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = conclusionIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = conclusionIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tcontextLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = contextIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = contextIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (!existsUserOrientedLiteral && propagateTwoParents) {\n\t\t\t\tassert(node.parents.length == 2);\n\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInPremise\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst premiseIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i + leftClause.premiseLiterals.length);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInConclusion\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst conclusionIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i + leftClause.conclusionLiterals.length);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInContext\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst contextIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i + leftClause.contextLiterals.length);\n\t\t\t\t\t}\n\n\t\t\t\t\t// sort premise, conclusion and context\n\t\t\t\t\tpremiseLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = premiseIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = premiseIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tconclusionLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = conclusionIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = conclusionIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tcontextLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = contextIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = contextIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Part 3: update literals\n\t\t\tclause.premiseLiterals = premiseLiterals;\n\t\t\tclause.conclusionLiterals = conclusionLiterals;\n\t\t\tclause.contextLiterals = contextLiterals;\n\n\t\t\t// Part 4: mark clause to be changed\n\t\t\tchangedClauses.add(node.id);\n\t\t}\n\t}\n\n\treturn changedClauses;\n}\n\n\n\n\n\n","import * as React from 'react';\nimport {Component} from 'react';\n\nimport Main from './Main';\nimport Aside from './Aside';\nimport { Dag, ParsedLine } from '../model/dag';\nimport SatNode from '../model/sat-node';\nimport './App.css';\nimport { assert } from '../model/util';\nimport { filterNonParents, filterNonConsequences, mergePreprocessing, passiveDagForSelection } from '../model/transformations';\nimport { findCommonConsequences } from '../model/find-node';\nimport { VizWrapper } from '../model/viz-wrapper';\nimport { Clause } from '../model/unit';\nimport { Literal } from '../model/literal';\nimport { computeClauseRepresentation, computeParentLiterals } from '../model/clause-orientation';\n\ntype Props = {\n  problem: string,\n  vampireUserOptions: string,\n  mode: \"proof\" | \"saturation\" | \"manualcs\"\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean, \n  orientClauses: boolean,\n};\n\n/* Invariant: the state is always in one of the following phases\n *    \"loaded\": A dag is loaded. Clause selection is not possible. dags, nodeSelection and currentTime hold meaningful values.\n *    \"loaded selected\": Same as \"loaded\", but clause selection is possible.\n *    \"waiting\": Waiting for answer from Vampire server. message holds a meaningful value.\n *    \"layouting\": Layouting a dag. message holds a meaningful value.\n *    \"error\": Some error occured. message holds a meaningful value.\n */\ntype State = {\n  state: \"loaded\" | \"loaded select\" | \"waiting\" | \"layouting\" | \"error\",\n  dags: Dag[],\n  nodeSelection: number[],\n  currentTime: number,\n  changedNodesEvent?: Set<number>, // update to trigger refresh of node in graph. Event is of the form [eventId, nodeId]\n  message: string,\n  passiveDag: Dag | null,\n  nodeIdToActivate: number | null\n}\n\nclass App extends Component<Props, State> {\n\n  state: State = {\n    state: \"waiting\",\n    dags: [],\n    nodeSelection: [],\n    currentTime: 0,\n    changedNodesEvent: undefined,\n    message: \"\",\n    passiveDag: null,\n    nodeIdToActivate: null\n  }\n\n  render() {\n    const {\n      state,\n      dags,\n      nodeSelection,\n      currentTime,\n      changedNodesEvent,\n      message,\n      passiveDag\n    } = this.state;\n    \n    let dag;\n    let main;\n    if (state === \"loaded\" || state === \"loaded select\") {\n      assert(dags.length > 0);\n      dag = dags[dags.length-1];\n      main = (\n        <Main\n          dag={dag}\n          passiveDag={passiveDag}\n          nodeSelection={nodeSelection}\n          changedNodesEvent={changedNodesEvent}\n          historyLength={dags[0].maximalActiveTime()}\n          currentTime={currentTime}\n          onNodeSelectionChange={this.updateNodeSelection.bind(this)}\n          onCurrentTimeChange={this.updateCurrentTime.bind(this)}\n          onDismissPassiveDag={this.dismissPassiveDag.bind(this)}\n          onUpdateNodePositions={this.updateNodePositions.bind(this)}\n        />\n      );\n    } else {\n      dag = null;\n      main = (\n        <main>\n          <section className=\"graph-placeholder\">{message}</section>\n          <section className=\"slider-placeholder\"/>\n        </main>\n      );\n    }\n\n    return (\n      <div className=\"app\">\n        {main}\n        <Aside\n          dag={passiveDag === null ? dag : passiveDag}\n          currentTime={currentTime}\n          nodeSelection={nodeSelection}\n          multipleVersions={passiveDag === null && dags.length > 1}\n          onUpdateNodeSelection={this.updateNodeSelection.bind(this)}\n          onUndo={this.undoLastStep.bind(this)}\n          onRenderParentsOnly={this.renderParentsOnly.bind(this)}\n          onRenderChildrenOnly={this.renderChildrenOnly.bind(this)}\n          onShowPassiveDag={this.showPassiveDag.bind(this)}\n          onDismissPassiveDag={this.dismissPassiveDag.bind(this)}\n          onSelectParents={this.selectParents.bind(this)}\n          onSelectChildren={this.selectChildren.bind(this)}\n          onSelectCommonConsequences={this.selectCommonConsequences.bind(this)}\n          onLiteralOrientationChange={this.changeLiteralOrientation.bind(this)}\n          onLiteralRepresentationChange={this.changeLiteralRepresentation.bind(this)}\n        />\n      </div>\n    );\n\n  }\n\n  async componentDidMount() {\n\n    // call Vampire on given input problem\n    await this.runVampire(this.props.problem, this.props.vampireUserOptions, this.props.mode);\n\n    if (this.state.state === \"loaded select\" && this.props.mode === \"manualcs\") {\n      this.selectFinalPreprocessingClauses();\n    }\n  }\n\n\n  // NETWORK ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  updateNodeSelection(nodeSelection: number[]) {\n    this.setState({nodeSelection: nodeSelection});\n  }\n\n  updateCurrentTime(currentTime: number) {\n    const dags = this.state.dags\n    assert(dags.length > 0);\n    const dag = dags[dags.length - 1];\n\n    const nodesInActiveDag = dag.computeNodesInActiveDag(currentTime);\n    const nodeSelection = new Array<number>();\n    for (const nodeId of this.state.nodeSelection) {\n      if (nodesInActiveDag.has(nodeId)) {\n        nodeSelection.push(nodeId);\n      }\n    }\n    this.setState({\n      nodeSelection: nodeSelection,\n      currentTime: currentTime\n    });\n  }\n\n\n  // FILE UPLOAD ///////////////////////////////////////////////////////////////////////////////////////////////////////\n  jsonToParsedLines(json: any): Array<ParsedLine> {\n    const parsedLines = new Array<ParsedLine>();\n    for (const line of json.lines) {\n      const statistics = new Map<string,number>();\n      for (const key in line.statistics) {\n        const val = line.statistics[key];\n        if (typeof val === \"number\"){\n          statistics.set(key, val);\n        }\n      }\n      parsedLines.push(new ParsedLine(line.lineType, line.unitId, line.unitString, line.inferenceRule, line.parents, statistics));\n    }\n    return parsedLines;\n  }\n\n  async runVampire(problem: string, vampireUserOptions: string, mode: \"proof\" | \"saturation\" | \"manualcs\") {\n    this.setState({\n      state: \"waiting\",\n      message: \"Waiting for Vampire...\",\n      dags: [],\n      nodeSelection: [],\n      currentTime: 0\n    });\n\n    const fetchedJSON = await fetch(mode === \"manualcs\" ? 'http://localhost:5000/vampire/startmanualcs' : 'http://localhost:5000/vampire/start', {\n      method: 'POST',\n      mode: 'cors',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        file: problem, \n        vampireUserOptions: vampireUserOptions\n      })\n    });\n\n    // try {\n      const json = await fetchedJSON.json();\n\n      if (json.status === \"success\") {\n        assert(json.vampireState === \"running\" ||\n          json.vampireState === \"refutation\" ||\n          json.vampireState === \"saturation\" ||\n          json.vampireState === \"timeout\");\n\n        if (mode === \"proof\") {\n          assert(json.vampireState !== \"running\")\n          if (json.vampireState === \"saturation\") {\n            this.setState({\n              state: \"error\",\n              message: \"Saturation: Vampire saturated, so there exists no proof!\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n          if (json.vampireState === \"timeout\") {\n            this.setState({\n              state: \"error\",\n              message: \"Timeout: Vampire could not find a proof in the given time!\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n        }\n        const parsedLines = this.jsonToParsedLines(json);\n\n        let dag = Dag.fromParsedLines(parsedLines, null);\n        dag = mergePreprocessing(dag);\n\n        if (mode === \"proof\") {\n          assert(dag.isRefutation);\n          // find empty clause\n          for (const node of dag.nodes.values()) {\n            if (node.unit.type === \"Clause\") {\n              const clause = node.unit as Clause;\n              if (clause.premiseLiterals.length === 0 && clause.conclusionLiterals.length === 0) {\n\n                // filter all non-parents of empty clause\n                const relevantIds = new Set<number>();\n                relevantIds.add(node.id);\n                dag = filterNonParents(dag, relevantIds);\n                break;\n              }\n            }\n          }\n        }\n  \n        await VizWrapper.layoutDag(dag, true);\n\n        if (this.props.orientClauses) {\n          computeParentLiterals(dag);\n          computeClauseRepresentation(dag, null);\n        }\n        this.setLiteralOptions(dag);\n\n        const state = (mode == \"manualcs\" && json.vampireState === \"running\") ? \"loaded select\" : \"loaded\";\n        this.setState({\n          state: state,\n          dags: [dag],\n          nodeSelection: [],\n          currentTime: dag.maximalActiveTime()\n        });\n      } else {\n        assert(json.status === \"error\");\n        const errorMessage = json.message;\n        assert(errorMessage !== undefined && errorMessage !== null);\n        this.setState({\n          state: \"error\",\n          message: errorMessage,\n          dags: [],\n          nodeSelection: [],\n          currentTime: 0\n        });\n      }\n    // } catch (error) {\n    //   if (error.name === \"SatVisAssertionError\") {\n    //     throw error;\n    //   }\n    //   this.setState({\n    //     state: \"error\",\n    //     message: `Error: ${error[\"message\"]}`,\n    //     dags: [],\n    //     nodeSelection: [],\n    //     currentTime: 0\n    //   });\n    // }\n  }\n\n  // select the clause with id 'selectedId', then compute incremental layout for resulting dag\n  async selectClause(selectedId: number, positioningHint: [number, number]) {\n    assert(this.state.dags.length >= 1);\n    const currentDag = this.state.dags[this.state.dags.length-1];\n    const currentDagActiveNodes = currentDag.computeNodesInActiveDag(currentDag.maximalActiveTime()); // needs to be computed before dag is extended, since nodes are shared\n    assert(currentDag.mergeMap !== null);\n\n    // ask server to select clause and await resulting saturation events\n    const fetchedJSON = await fetch('http://localhost:5000/vampire/select', {\n      method: 'POST',\n      mode: 'cors',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({id: selectedId})\n    });\n\n    try {\n      const json = await fetchedJSON.json();\n      if (json.status === \"success\") {\n        const parsedLines = this.jsonToParsedLines(json);\n\n        // extend existing dag with new saturation events from server\n        const newDag = Dag.fromParsedLines(parsedLines, currentDag);\n\n        // compute which nodes have been newly generated\n        const newDagActiveNodes = newDag.computeNodesInActiveDag(newDag.maximalActiveTime());\n        const newNodes = new Map<number, SatNode>();\n        for (const [nodeId, node] of newDag.nodes) {\n          if(!currentDagActiveNodes.has(nodeId) && newDagActiveNodes.has(nodeId)) {\n            newNodes.set(nodeId, node);\n          }\n        }\n\n        if (newNodes.size > 0) {\n          await VizWrapper.layoutNodesAtPosition(newNodes, positioningHint);\n        }\n\n        if (this.props.orientClauses) {\n          computeParentLiterals(newDag);\n          computeClauseRepresentation(newDag, null);\n        }\n        this.setLiteralOptions(newDag);\n  \n        const state = json.vampireState === \"running\" ? \"loaded select\" : \"loaded\";\n        const nodeSelection = new Array<number>();\n        for (const nodeId of newNodes.keys()) {\n          nodeSelection.push(nodeId);\n        }\n        this.setState({\n          state: state,\n          dags: [newDag],\n          nodeSelection: nodeSelection,\n          currentTime: newDag.maximalActiveTime(),\n        });\n      } else {\n        assert(json.status === \"error\");\n        const errorMessage = json.message;\n        assert(errorMessage !== undefined && errorMessage !== null);\n        this.setState({\n          state: \"error\",\n          message: errorMessage,\n          dags: [],\n          nodeSelection: [],\n          currentTime: 0\n        });\n      }\n    } catch (error) {\n      if (error.name === \"SatVisAssertionError\") {\n        throw error;\n      }\n      this.setState({\n        state: \"error\",\n        message: `Error: ${error[\"message\"]}`,\n        dags: [],\n        nodeSelection: [],\n        currentTime: 0\n      });\n    }\n  }\n\n  async selectFinalPreprocessingClauses() {\n    // iterate as long as the server waits for clause selections and as long as a suitable clause is found\n    let stop = false;\n    while (this.state.state === \"loaded select\" && !stop) {\n      const dag = this.state.dags[0];\n\n      // find a final preprocessing clause which can be selected\n      stop = true;\n      for (const [nodeId, node] of dag.nodes) {\n        if (node.isFromPreprocessing && node.newTime !== null) {\n          if (node.activeTime === null && node.deletionTime === null) {\n            // select that clause\n            assert(node.position !== null);\n            await this.selectClause(nodeId, node.position as [number, number]);\n            stop = false;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // SUBGRAPH SELECTION ////////////////////////////////////////////////////////////////////////////////////////////////\n\n  undoLastStep() {\n    this.popDag();\n  }\n\n  async renderParentsOnly() {\n    const {dags, nodeSelection} = this.state;\n    const currentDag = dags[dags.length - 1];\n\n    const newDag = filterNonParents(currentDag, new Set(nodeSelection));\n    await VizWrapper.layoutDag(newDag, true);\n\n    this.pushDag(newDag);\n  }\n\n  async renderChildrenOnly() {\n    const {dags, nodeSelection} = this.state;\n    const currentDag = dags[dags.length - 1];\n\n    const newDag = filterNonConsequences(currentDag, new Set(nodeSelection));\n    await VizWrapper.layoutDag(newDag, true);\n\n    this.pushDag(newDag);\n  }\n\n  // PASSIVE DAG ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  async showPassiveDag() {\n    assert(this.state.passiveDag === null);\n    assert(this.state.nodeSelection.length > 0);\n\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const currentDag = dags[dags.length - 1];\n\n    // generate passive dag\n    const passiveDag = passiveDagForSelection(currentDag, this.state.nodeSelection, this.state.currentTime);\n    \n    // layout node positions of passive dag\n    await VizWrapper.layoutDag(passiveDag, false);\n\n    // shift dag so that selected node occurs at same screen position as in currentDag\n    const [posCurrentX, posCurrentY] = currentDag.get(this.state.nodeSelection[0]).getPosition();\n    const [posPassiveX, posPassiveY] = passiveDag.get(this.state.nodeSelection[0]).getPosition();\n    const deltaX = posCurrentX-posPassiveX;\n    const deltaY = posCurrentY-posPassiveY;\n    for (const [nodeId, node] of passiveDag.nodes) {\n      assert(node.position != null);\n      const position = node.position as [number, number];\n      node.position = [position[0] + deltaX, position[1] + deltaY];\n    }\n\n    this.setState({ passiveDag: passiveDag });\n  }\n\n  async dismissPassiveDag(performActivation: boolean) {\n    assert(this.state.dags.length >= 1);\n    assert(this.state.passiveDag !== null);\n    assert(this.state.passiveDag!.isPassiveDag);\n    assert(this.state.passiveDag!.styleMap !== null);\n    assert(this.state.passiveDag!.activeNodeId !== null);\n\n    if (performActivation && this.state.nodeSelection.length === 1) {\n      const selectedId = this.state.nodeSelection[0];\n\n      const styleMap = this.state.passiveDag!.styleMap!\n      if (styleMap.get(selectedId) === \"passive\") {\n        // compute positioning hint\n      const currentDag = this.state.dags[this.state.dags.length-1];\n      const positioningHint = currentDag.get(this.state.passiveDag!.activeNodeId as number).position;\n      assert(positioningHint !== null);\n    \n      // remove passive dag\n      this.setState({ passiveDag: null}); // no need to reset node selection, since it will be set by selectClause()\n\n      // switch from currentDag to dag resulting from selecting nodeIdToActivate\n      await this.selectClause(selectedId, positioningHint as [number, number]);\n      }\n    } else {\n      // remove passive dag\n      this.setState({ passiveDag: null, nodeSelection: []}); // reset node selection, since selected nodes are not necessarily present in currentDag\n    }\n  }\n\n\n  // NODE SELECTION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  selectParents() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const newSelection = new Set(nodeSelection);\n    for (const nodeId of nodeSelection) {\n      assert(nodesInActiveDag.has(nodeId));\n      for (const parentId of currentDag.get(nodeId).parents) {\n        if(nodesInActiveDag.has(parentId)) {\n          newSelection.add(parentId);\n        }\n      }\n    }\n\n    this.updateNodeSelection(Array.from(newSelection));\n  }\n\n  selectChildren() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const newSelection = new Set(nodeSelection);\n    for (const nodeId of nodeSelection) {\n      assert(nodesInActiveDag.has(nodeId));\n      for (const childId of currentDag.getChildren(nodeId)) {\n        if(nodesInActiveDag.has(childId)) {\n          newSelection.add(childId);\n        }\n      }\n    }\n    this.updateNodeSelection(Array.from(newSelection));\n  }\n\n  selectCommonConsequences() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const commonConsequences = findCommonConsequences(currentDag, new Set(nodeSelection));\n    const newSelection = new Array<number>();\n    for (const nodeId of commonConsequences) {\n      if (nodesInActiveDag.has(nodeId)) {\n        newSelection.push(nodeId);\n      }\n    }\n    this.updateNodeSelection(newSelection);\n  }\n\n  // LITERALS ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  private changeLiteralOrientation(nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) {\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const dag = dags[0];\n    const currentDag = dags[dags.length - 1];\n    const node = dag.nodes.get(nodeId);\n    assert(node !== undefined);\n    assert(node!.unit.type === \"Clause\");\n    const clause = node!.unit as Clause;\n\n    clause.changeLiteralOrientation(oldPosition, newPosition);\n\n    const changedNodes = computeClauseRepresentation(dag, nodeId);\n    const changedNodesInCurrentDag = new Set<number>();\n    for (const changedNodeId of changedNodes) {\n      if (currentDag.nodes.has(changedNodeId)) {\n        changedNodesInCurrentDag.add(changedNodeId);\n      }\n    }\n    this.setState({changedNodesEvent: changedNodesInCurrentDag});\n  }\n\n  private changeLiteralRepresentation(nodeId: number, literal: Literal) {\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const dag = dags[0];\n    const node = dag.nodes.get(nodeId);\n    assert(node !== undefined);\n\n    literal.switchToNextRepresentation();\n    \n    const changedNodes = computeClauseRepresentation(dag, nodeId);\n\n    this.setState({changedNodesEvent: changedNodes});\n  }\n\n  // HELPERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  updateNodePositions(nodeIds: Array<number>, delta: [number, number]) {\n    const dags = this.state.dags\n    assert(this.state.dags.length > 0);\n    const dag = dags[dags.length - 1];\n    for (const nodeId of nodeIds) {\n      const node = dag.get(nodeId);\n      assert(node.position !== null);\n      node.position = [node.position![0] + delta[0], node.position![1] + delta[1]];\n    }\n  }\n\n  // push a new dag on the stack of dags\n  // Precondition: the layout for newDag has already been computed\n  private pushDag(newDag: Dag) {\n    assert(!newDag.isPassiveDag);\n\n    const {dags, nodeSelection} = this.state;\n    \n    // filter out selected nodes which don't occur in new graph\n    const selectedNodesInNewDag = new Array<number>();\n    for (const nodeId of nodeSelection) {\n      if (newDag.nodes.has(nodeId)) {\n        selectedNodesInNewDag.push(nodeId);\n      }\n    }\n\n    this.setState({\n      dags: dags.concat([newDag]),\n      nodeSelection: selectedNodesInNewDag\n    });\n  }\n\n  private popDag() {\n    assert(this.state.dags.length > 1, \"Undo last step must only be called if there exist at least two dags\");\n\n    this.setState((state, props) => ({\n      dags: state.dags.slice(0, state.dags.length-1)\n    }));\n  }\n\n  setLiteralOptions(dag: Dag) {\n    const hideBracketsAssoc = this.props.hideBracketsAssoc;\n    const nonStrictForNegatedStrictInequalities = this.props.nonStrictForNegatedStrictInequalities;\n\n    for (const node of dag.nodes.values()) {\n      if (node.unit.type === \"Clause\") {\n        const clause = node.unit as Clause;\n        for (const literal of clause.premiseLiterals) {\n          literal.hideBracketsAssoc = hideBracketsAssoc;\n          literal.nonStrictForNegatedStrictInequalities = nonStrictForNegatedStrictInequalities;\n        }\n        for (const literal of clause.conclusionLiterals) {\n          literal.hideBracketsAssoc = hideBracketsAssoc;\n          literal.nonStrictForNegatedStrictInequalities = nonStrictForNegatedStrictInequalities;\n        }\n      }\n    }\n  }\n}\n\nexport default App;\n","import { Dag } from \"./dag\";\nimport { DFPostOrderTraversal } from \"./traversal\";\n\n// return ids of nodes, which have a derivation where each of the nodes in relevantIds occurs\nexport function findCommonConsequences(dag: Dag, relevantIds: Set<number>): Array<number> {\n\n\t// want to compute common consequences\n\tconst commonConsequences = new Array<number>();\n\n\t// create dictionary which maps the id of each node to the subset of relevantIds occuring in the derivation of the node\n\tconst idToRelevantParentIds = new Map<number, Set<number>>();\n\n\t// add all transitive children of ids in transitiveChildren to transitiveChildren\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst currentNode = iterator.getNext();\n\t\tconst currentNodeId = currentNode.id;\n\n\t\tconst relevantParents = new Set<number>();\n\t\t// compute relevant parents and update dictionary\n\t\tif (relevantIds.has(currentNodeId)) {\n\t\t\trelevantParents.add(currentNodeId);\n\t\t}\n\t\tfor (const parentId of currentNode.parents) {\n\t\t\tconst relevantParentIdsFromParent = idToRelevantParentIds.get(parentId) as Set<number>;\n\t\t\t// merge relevantParentIdsFromParent into relevantParents\n\t\t\tfor (const relevantParentId of relevantParentIdsFromParent) {\n\t\t\t\trelevantParents.add(relevantParentId);\n\t\t\t}\n\t\t}\n\t\tidToRelevantParentIds.set(currentNodeId, relevantParents);\n\n\t\t// check whether each relevant id occurs in relevant parents\n\t\tif (relevantIds.size === relevantParents.size) {\n\t\t\tcommonConsequences.push(currentNodeId);\n\t\t}\n\t}\n\t\n\treturn commonConsequences;\n}","import * as React from 'react';\nimport { NavigationBar } from \"./NavigationBar\";\nimport App from \"./App\";\nimport './AppWrapper.css';\n\ntype Props = {\n\tname: string,\n\tproblem: string,\n\tvampireUserOptions: string,\n\tmode: \"proof\" | \"saturation\" | \"manualcs\"\n\thideBracketsAssoc: boolean,\n\tnonStrictForNegatedStrictInequalities: boolean, \n\torientClauses: boolean,\n  };\n  \n  export class AppWrapper extends React.Component<Props, {}> {\n\t\n\trender() {\n\t\treturn (\n\t\t\t<div id=\"appWrapper\">\n\t\t\t\t<NavigationBar \n\t\t\t\t\tname={this.props.name}\n\t\t\t\t/>\n\t\t\t\t<App \n\t\t\t\t\tproblem={this.props.problem}\n\t\t\t\t\tvampireUserOptions={this.props.vampireUserOptions}\n\t\t\t\t\tmode={this.props.mode}\n\t\t\t\t\thideBracketsAssoc={this.props.hideBracketsAssoc}\n\t\t\t\t\tnonStrictForNegatedStrictInequalities={this.props.nonStrictForNegatedStrictInequalities}\n\t\t\t\t\torientClauses={this.props.orientClauses}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t)\n\t}\n  }\n  ","import * as React from 'react';\nimport {Link} from 'react-router-dom';\nimport './Menu.css';\nimport * as Monaco from 'monaco-editor'\nimport { assert } from '../model/util';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  problem: string,\n  problemName: string,\n  inputSyntax: 'smtlib' | 'tptp',\n  vampireUserOptions: string,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean\n  orientClauses: boolean,\n  onChangeProblem: (problem: string) => void,\n  onChangeProblemName: (problemName: string) => void,\n  onChangeInputSyntax: (syntax: 'smtlib' | 'tptp') => void\n  onChangeVampireUserOptions: (vampireUserOptions: string) => void,\n  onChangeHideBracketsAssoc: (newValue: boolean) => void,\n  onChangeNonStrictForNegatedStrictInequalities: (newValue: boolean) => void,\n  onChangeOrientClauses: (newValue: boolean) => void\n}\n\nexport class Menu extends React.Component<Props, {}> {\n  private isChromeOrFirefox = navigator.userAgent.indexOf('Chrome') > -1 || navigator.userAgent.indexOf('Firefox') > -1;\n  private fileUpload = React.createRef<HTMLInputElement>();\n  monacoDiv = React.createRef<HTMLDivElement>();\n  monaco: Monaco.editor.IStandaloneCodeEditor | null = null\n\n  componentDidMount() {\n    if (!this.isChromeOrFirefox) {\n      return;\n    }\n    // generate instance of Monaco Editor\n    this.monaco = Monaco.editor.create(this.monacoDiv.current!, {\n      lineNumbers: 'off',\n      roundedSelection: false,\n      scrollBeyondLastLine: false,\n      scrollBeyondLastColumn: 0,\n      minimap: {\n        enabled: false\n      },\n      renderLineHighlight: 'none',\n      hideCursorInOverviewRuler: true,\n      links: false,\n      overviewRulerBorder: false,\n      automaticLayout: true,\n      lineDecorationsWidth: 0,\n      lineNumbersMinChars: 0,\n      wordWrap: 'wordWrapColumn'\n      // fontFamily: \"Monaco\" TODO: decide which font to use. By default, multiple fonts are loaded, which is quite slow\n    });\n    this.monaco.setValue(this.props.problem);\n    this.monaco.getModel()!.onDidChangeContent(() => {\n      this.props.onChangeProblem(this.monaco!.getModel()!.getValue());\n    });\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    assert(this.isChromeOrFirefox);\n    if (this.props.problem !== prevProps.problem) {\n      this.monaco!.setValue(this.props.problem);\n    }\n  }\n\n  render() {\n    if (!this.isChromeOrFirefox) {\n      return (\n        <section className=\"unsupported-message\"> Your current browser is not supported. Please use Chrome or Firefox!</section>\n      );\n    }\n\n    return (\n      <section className=\"component-menu\">\n        <h1>Vampire Saturation Visualization</h1>\n\n        <section className=\"editor\">\n          <div className=\"editor-spacer\">\n            <main>\n              <div className=\"headline-wrapper\">\n                <h2>Input</h2>\n                <small className=\"file-name\">{this.props.problemName}</small>\n                <button title=\"Pick a new file\" onClick={this.chooseFile.bind(this)}>\n                  <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n                    <use xlinkHref={`${icons}#graph-upload`}/>\n                  </svg>\n                </button>\n              </div>\n\n              <input\n                ref={this.fileUpload}\n                type=\"file\"\n                onChange={this.uploadEncoding.bind(this)}\n              />\n              <div ref={this.monacoDiv} className=\"monaco\"></div>\n            </main>\n\n            <aside>\n              <fieldset className=\"options-card\">\n                <h3>Vampire Options</h3>\n                <ul>\n                  <li>\n                    <label htmlFor=\"inputSyntax\" className=\"form-label\">Input language</label>\n                    <select id=\"inputSyntax\" onChange={this.changeInputSyntax.bind(this)}\n                            value={this.props.inputSyntax}>\n                      <option value=\"smtlib\">SMTLIB</option>\n                      <option value=\"tptp\">TPTP</option>\n                    </select>\n                  </li>\n                  <li>\n                    <label htmlFor=\"userOptions\" className=\"form-label\">Additional Vampire options</label>\n                    <input id=\"userOptions\" type=\"text\" onChange={this.changeVampireUserOptions.bind(this)}\n                           value={this.props.vampireUserOptions}>\n                    </input>\n                  </li>\n                </ul>\n              </fieldset>\n\n              <fieldset className=\"options-card\">\n                <h3>Visualization Options</h3>\n                <ul>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.hideBracketsAssoc}\n                        onChange={this.changeHideBracketsAssoc.bind(this)}/>\n                      Hide brackets for associative operators\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.nonStrictForNegatedStrictInequalities}\n                        onChange={this.changeNonStrictForNegatedStrictInequalities.bind(this)}/>\n                      Show negated strict inequalities as (positive) nonstrict inequalities\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.orientClauses}\n                        onChange={this.changeOrientClauses.bind(this)}/>\n                      Heuristically orient clauses\n                    </label>\n                  </li>\n                </ul>\n              </fieldset>\n            </aside>\n          </div>\n        </section>\n\n        <section className=\"run-menu\">\n          <Link to=\"/proof/\" className=\"fake-button\">Find proof</Link>\n          <Link to=\"/saturation/\" className=\"fake-button\">Find saturation</Link>\n          <Link to=\"/manualcs/\" className=\"fake-button\">Start manual clause selection</Link>\n        </section>\n      </section>\n    );\n  }\n\n  chooseFile() {\n    if (this.fileUpload.current) {\n      this.fileUpload.current.click();\n    }\n  }\n\n  uploadEncoding(event: React.ChangeEvent<HTMLInputElement>) {\n    if (event.target.files !== null && event.target.files.length > 0) {\n      const file = event.target.files[0];\n\n      const reader = new FileReader();\n      // callback which will be executed when readAsText is called\n      reader.onloadend = () => {\n        const text = (reader.result ? reader.result : '') as string;\n        this.props.onChangeProblem(text);\n        this.props.onChangeProblemName(file.name);\n\n        // guess inputSyntax from file extension:\n        if (file.name.endsWith('.smt') || file.name.endsWith('.smtlib') || file.name.endsWith('.smt2') || file.name.endsWith('.smtlib2')) {\n          this.props.onChangeInputSyntax('smtlib');\n        } else if (file.name.endsWith('.tptp')) {\n          this.props.onChangeInputSyntax('tptp');\n        }\n      };\n      reader.readAsText(file);\n    }\n  }\n\n  changeVampireUserOptions(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.value;\n    this.props.onChangeVampireUserOptions(newValue);\n  }\n\n  changeTextArea(event: React.ChangeEvent<HTMLTextAreaElement>) {\n    const newValue = event.target.value;\n    this.props.onChangeProblem(newValue);\n  }\n\n  changeHideBracketsAssoc(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeHideBracketsAssoc(newValue);\n  }\n\n  changeNonStrictForNegatedStrictInequalities(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeNonStrictForNegatedStrictInequalities(newValue);\n  }\n\n  changeInputSyntax(event: React.ChangeEvent<HTMLSelectElement>) {\n    const newValue = event.target.value as 'smtlib' | 'tptp';\n    this.props.onChangeInputSyntax(newValue);\n  }\n\n  changeOrientClauses(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeOrientClauses(newValue);\n  }\n}\n","import * as React from 'react';\nimport { HashRouter as HashRouter, Route, Link } from \"react-router-dom\";\nimport { AppWrapper } from './AppWrapper'\nimport { Menu } from './Menu'\n\ntype State = {\n\tproblem: string,\n\tproblemName: string,\n\tinputSyntax: \"smtlib\" | \"tptp\",\n\tvampireUserOptions: string,\n\thideBracketsAssoc: boolean,\n\tnonStrictForNegatedStrictInequalities: boolean,\n\torientClauses: boolean\n}\n\nexport class AppRouter extends React.Component<{}, State> {\n\n\tstate: State = {\n\t\tproblem: \"\",\n\t\tproblemName: \"\",\n\t\tinputSyntax: \"smtlib\",\n\t\tvampireUserOptions: \"\",\n\t\thideBracketsAssoc: true,\n\t\tnonStrictForNegatedStrictInequalities: true,\n\t\torientClauses: true\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<HashRouter>\n\t\t\t\t<Route path=\"/\" exact render={() => \n\t\t\t\t\t<Menu \n\t\t\t\t\t\tproblem={this.state.problem}\n\t\t\t\t\t\tproblemName={this.state.problemName}\n\t\t\t\t\t\tinputSyntax={this.state.inputSyntax}\n\t\t\t\t\t\tvampireUserOptions={this.state.vampireUserOptions}\n\t\t\t\t\t\thideBracketsAssoc={this.state.hideBracketsAssoc}\n\t\t\t\t\t\tnonStrictForNegatedStrictInequalities={this.state.nonStrictForNegatedStrictInequalities}\n\t\t\t\t\t\torientClauses={this.state.orientClauses}\n\t\t\t\t\t\tonChangeProblem={this.changeProblem.bind(this)}\n\t\t\t\t\t\tonChangeProblemName={this.changeProblemName.bind(this)}\n\t\t\t\t\t\tonChangeInputSyntax={this.changeInputSyntax.bind(this)}\n\t\t\t\t\t\tonChangeVampireUserOptions={this.changeVampireUserOptions.bind(this)}\n\t\t\t\t\t\tonChangeHideBracketsAssoc={this.changeHideBracketsAssoc.bind(this)}\n\t\t\t\t\t\tonChangeNonStrictForNegatedStrictInequalities={this.changeNonStrictForNegatedStrictInequalities.bind(this)}\n\t\t\t\t\t\tonChangeOrientClauses={this.changeOrientClauses.bind(this)}\n\t\t\t\t\t/>\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/proof/\" render={() => \n\t\t\t\t\tthis.appComponent(\"proof\")\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/saturation/\" render={() => \n\t\t\t\t\tthis.appComponent(\"saturation\")\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/manualcs/\" render={() => \n\t\t\t\t\tthis.appComponent(\"manualcs\")\n\t\t\t\t}/>\n\t\t\t</HashRouter>\n\t\t);\n\t}\n\n\tappComponent(mode: \"proof\" | \"saturation\" | \"manualcs\") {\n\t\tconst inputSyntax = this.state.inputSyntax === \"smtlib\" ? \"smtlib2\" : this.state.inputSyntax;\n\t\tconst vampireUserOptions = `${this.state.vampireUserOptions} --input_syntax ${inputSyntax}`;\n\n\t\treturn <AppWrapper\n\t\t\tname={this.state.problemName}\n\t\t\tmode={mode}\n\t\t\tproblem={this.state.problem!}\n\t\t\tvampireUserOptions={vampireUserOptions}\n\t\t\thideBracketsAssoc={this.state.hideBracketsAssoc}\n\t\t\tnonStrictForNegatedStrictInequalities={this.state.nonStrictForNegatedStrictInequalities}\n\t\t\torientClauses={this.state.orientClauses}\n\t\t/>\n\t}\n\n\tchangeProblem(problem: string) {\n\t\tthis.setState({problem: problem});\n\t}\n\tchangeProblemName(problemName: string) {\n\t\tthis.setState({problemName: problemName});\n\t}\n\tchangeVampireUserOptions(vampireUserOptions: string) {\n\t\tthis.setState({vampireUserOptions: vampireUserOptions});\n\t}\n\tchangeHideBracketsAssoc(newValue: boolean) {\n\t\tthis.setState({hideBracketsAssoc: newValue});\n\t}\n\tchangeNonStrictForNegatedStrictInequalities(newValue: boolean) {\n\t\tthis.setState({nonStrictForNegatedStrictInequalities: newValue});\n\t}\n\tchangeInputSyntax(inputSyntax: \"smtlib\" | \"tptp\") {\n\t\tthis.setState({inputSyntax: inputSyntax});\n\t}\n\tchangeOrientClauses(newValue: boolean) {\n\t\tthis.setState({orientClauses: newValue});\n\t}\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport './index.css';\nimport { AppRouter } from './components/Router';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <AppRouter/>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/all.b38f8a06.svg\";"],"sourceRoot":""}