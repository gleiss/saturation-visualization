{"version":3,"sources":["resources/icons/all.svg","components/NavigationBar.tsx","components/Slider.tsx","model/util.ts","components/Graph.tsx","components/NodeDetails.tsx","components/NodeDetailsWrapper.tsx","components/PassiveDagAside.tsx","model/sat-node.ts","model/unit.ts","model/literal.ts","model/unit-parser.ts","model/traversal.ts","model/substitution.ts","model/dag.ts","model/transformations.ts","model/callViz.js","model/viz-wrapper.ts","components/PassiveDagModal.tsx","components/Main.tsx","components/GraphMenu.tsx","components/NodeMenu.tsx","components/Search.tsx","components/NodeCard.tsx","components/Aside.tsx","model/clause-orientation.ts","model/serialization.ts","components/App.tsx","model/find-node.ts","components/AppWrapper.tsx","components/LoadSavedProblemButton.tsx","components/Menu.tsx","components/Router.tsx","serviceWorker.js","index.tsx"],"names":["module","exports","icons","require","NavigationBar","id","onClick","window","history","back","viewBox","className","xlinkHref","this","props","name","onSave","React","Slider","slider","historyLength","currentTime","onCurrentTimeChange","disabled","ref","type","min","max","value","onChange","getSliderValue","current","parseInt","SatVisAssertionError","message","Error","assert","condition","styleTemplates","Graph","markers","Set","network","networkNodes","DataSet","networkEdges","graphContainer","dragStartEvent","cachedChangeNodesEvent","undefined","generateNetwork","updateNetwork","selectNodes","nodeSelection","fit","prevProps","dag","animateDagChanges","nodes","map","nodeId","toString","animation","incomingEvent","changedNodesEvent","visNodes","Array","has","visNode","label","get","toHTMLString","push","update","Network","edges","physics","interaction","multiselect","on","clickEvent","a","length","clickedNodeId","originalEvent","event","srcEvent","metaKey","ctrlKey","find","onNodeSelectionChange","filter","concat","dragEndEvent","isPassiveDag","deltaX","pointer","canvas","x","deltaY","y","onUpdateNodePositions","onlyUpdateStyles","visEdges","edgeId","nodePartition","styleMap","computeNodePartition","satNodeId","satNode","nodeStyle","hidden","toVisNode","getPosition","parents","parentId","visEdge","toVisEdge","clear","add","nodesInActiveDag","computeNodesInActiveDag","Map","node","isDeleted","deletionTime","nodeIsTheoryAxiom","set","isFromPreprocessing","inferenceRule","activeTime","style","position","styleData","isMarked","labelHighlightBold","shape","color","border","markedStyle","defaultStyle","background","highlight","highlightStyle","font","text","multi","Math","round","parentNodeId","arrows","from","to","smooth","clickPosition","getNodeAt","layerX","layerY","delete","NodeDetails","state","draggable","keep","toList","clause","orientation","literals","premiseLiterals","conclusionLiterals","contextLiterals","options","group","tag","_items","_sortable","onLiteralOrientationChange","oldIndex","newIndex","literal","index","toListItem","key","data-id","onDoubleClick","onLiteralRepresentationChange","currentTarget","innerText","statisticsStrings","numberOfTransitiveActivatedChildren","statistics","includes","infoToggle","title","onToggleInfo","editToggle","onToggleEdit","unit","string","onMouseEnter","setState","onMouseLeave","NodeDetailsWrapper","PassiveDagAside","selectClauseButtonEnabled","onSelectButtonPressed","SatNode","newTime","deletionParents","isBoundary","isActive","Formula","formula","Clause","literalsNewEvent","literalsActiveEvent","oldPosition","newPosition","removedLiterals","splice","removedLiteral","orientationReason","join","premiseString","isSelected","conclusionString","contextString","premiseStringWithoutBoldness","conclusionStringWithoutBoldness","contextStringWithoutBoldness","estimatedLengthOfLine","ceil","line","repeat","implication","Literal","args","negated","representation","hideBracketsAssoc","nonStrictForNegatedStrictInequalities","literalInParent","negateLiteral","occursNegated","switchSides","lhs","rhs","arg","Term","isVariable","startsWith","inner","UnitParser","match","parseClause","parseLiterals","literalStrings","split","i","parseLiteral","equalityPosition","search","substring","lhsString","rhsString","parseTerm","atomString","literalTerm","tokens","stringPos","char","tokenEnd","token","stack","pos","pop","f","DFPostOrderTraversal","todo","visited","leaves","last","currentId","currentNode","existsUnvisitedParent","ReversePostOrderTraversal","postOrder","it","hasNext","getNext","literalsMatch","literal1","literal2","allowSubstitutions","success","substitution","arg1","arg2","computeSubstitution","substitutionEq","isSubstitution","termsAreEqual","isEqual","f1","f2","substitutedVariable","ParsedLine","unitString","Dag","mergeMap","activeNodeId","nonLeaves","values","keys","size","children","counter","transitiveChildrenIds","iterator","existsRelevantParent","isRelevant","alreadyGenerated","alreadyActivated","activeNodeIds","nodeIds","computeActiveNodes","currentNodeId","parsedLines","existingDag","maximalActiveTime","emptyClauseNode","parentsAfterMerge","mergedParentsOrUndefined","parsePreprocessingUnit","parent","literalsAfterActivation","nSel","existingLiteralsActiveOrder","foundMatch","existingLiteral","filterNonParents","relevantIds","transitiveParentIds","remainingNodes","forEach","remainingNodesDeepCopy","copy","filterNonConsequences","boundaryNode","createBoundaryNode","mergePreprocessing","nodeIdsToRemove","postOrderTraversal","updatedParents","parentNode","parent2Id","updatedNode","nodeIdToRemove","passiveDagForSelection","selectionIds","selectionIdsSet","foundNodes","idToActiveDagParents","activeDagParents","activeDagParentsParent","activeDagParent","passiveDagNodes","relevantNodes","iterator2","runViz","dotString","viz","Viz","Module","render","renderString","format","then","result","catch","error","console","PLAIN_PATTERN","VizWrapper","layoutNodes","sourceNode","isSourceNode","posSelectedX","posSelectedY","posSourceX","posSourceY","onlyActiveDag","dagToDotString","layoutString","parseLayoutString","nodesToDotString","Number","MAX_SAFE_INTEGER","inputStrings","preprocessingStrings","otherStrings","nodeIsInputNode","edgeStrings","nodeStrings","firstEdgeLineIndex","indexOf","parsedNodeLines","substr","slice","matchAll","next","parsedNodeLine","idString","xString","yString","parseFloat","ReactModal","setAppElement","PassiveDagModal","passiveDag","nodeSelectionPassiveDag","generatePassiveDag","previousProps","isOpen","contentLabel","onRequestClose","onDismissPassiveDag","nodeSelectionChange","bind","updateNodePositions","onUpdateNodeSelection","selectButtonPressed","selection","delta","layoutDag","posCurrentX","posCurrentY","posPassiveX","posPassiveY","selectedId","positioningHint","Main","modal","showPassiveDag","readOnly","GraphMenu","undoEnabled","onUndo","filterUpEnabled","onRenderParentsOnly","filterDownEnabled","onRenderChildrenOnly","passiveDagButtonEnabled","onShowPassiveDag","NodeMenu","onSelectParents","onSelectChildren","onSelectCommonConsequences","Search","searchField1","searchField2","searchField3","getDisabledListItem","placeholder","onKeyUp","searchString1","searchString2","searchString3","candidates","foundLiteral","sort","node1","node2","clause1","clause2","NodeCard","Aside","multipleVersions","graphMenuEnabled","filtersEnabled","computeParentLiteralsCase1","parentLiterals","parentLiteral","setLiteralInParent","computeParentLiteralsCase2","allowMultipleRemovals","foundRemovedLit","j","computeParentLiteralsCase3","allowSimultanousSuperposition","foundRewrittenLiteral","computeParentLiterals","parentClause","leftNode","rightNode","leftClause","rightClause","leftWasAlreadyActivated","rightWasAlreadyActivated","leftLiterals","rightLiterals","computeClauseRepresentation","changedClauseId","changedClauses","isEqualityResolutionWithDeletion","propagateSingleParent","propagateTwoParents","l","existsUserOrientedLiteral","premiseIndexMap","conclusionIndexMap","contextIndexMap","lit1","lit2","index1","index2","AppMode","Serializer","version","problem","vampireUserOptions","obj","JSON","stringify","convertToIndices","encodedLiterals","encodedPremiseLiterals","encodedConclusionLiterals","encodedContextLiterals","encodedLiteralsActiveEvent","entries","json","res","parse","reconstructDag","pairIdNode","reconstructSatNode","reconstructUnit","pair","reconstructLiteral","n","term","reconstructTerm","App","dags","nodeIdToActivate","main","mode","saved","updateNodeSelection","updateCurrentTime","dismissPassiveDag","changeLiteralOrientation","changeLiteralRepresentation","toggleInfo","toggleEdit","undoLastStep","renderParentsOnly","renderChildrenOnly","selectParents","selectChildren","selectCommonConsequences","deserializeAppState","loadedProblem","runVampire","manualcs","selectFinalPreprocessingClauses","serializeAppState","logging","log","lines","val","lineType","unitId","url","fetch","method","headers","body","file","fetchedJSON","status","vampireState","proof","jsonToParsedLines","fromParsedLines","isRefutation","orientClauses","setLiteralOptions","errorMessage","currentDag","currentDagActiveNodes","newDag","newDagActiveNodes","newNodes","layoutNodesAtPosition","stop","selectClause","popDag","pushDag","newSelection","getChildren","childId","commonConsequences","idToRelevantParentIds","relevantParents","relevantParentIdsFromParent","relevantParentId","findCommonConsequences","changedNodes","switchToNextRepresentation","selectedNodesInNewDag","Component","AppWrapper","app","loadedProblemName","save","saveData","serialize","element","document","createElement","Blob","href","URL","createObjectURL","download","generateFilename","appendChild","click","prefix","LoadSavedProblemButton","useHistory","fileUpload","target","files","reader","FileReader","onloadend","onLoadSavedProblemData","readAsText","Menu","isChromeOrFirefox","navigator","userAgent","monacoDiv","monaco","Monaco","create","lineNumbers","roundedSelection","scrollBeyondLastLine","scrollBeyondLastColumn","minimap","enabled","renderLineHighlight","hideCursorInOverviewRuler","links","overviewRulerBorder","automaticLayout","lineDecorationsWidth","lineNumbersMinChars","wordWrap","setValue","getModel","onDidChangeContent","onChangeProblem","getValue","problemName","chooseFile","uploadEncoding","htmlFor","changeInputSyntax","inputSyntax","changeVampireUserOptions","checked","changeHideBracketsAssoc","changeNonStrictForNegatedStrictInequalities","changeOrientClauses","changeLogging","onChangeProblemName","endsWith","onChangeInputSyntax","newValue","onChangeVampireUserOptions","onChangeHideBracketsAssoc","onChangeNonStrictForNegatedStrictInequalities","onChangeOrientClauses","onChangeLogging","AppRouter","path","exact","changeProblem","changeProblemName","loadSavedProblem","appComponent","saturation","problemData","filename","Boolean","location","hostname","ReactDOM","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a7aebae3.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/all.0974d87f.svg\";","import * as React from 'react';\nimport './NavigationBar.css';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  name: string,\n  onSave: () => void\n}\n\nexport class NavigationBar extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <nav id=\"navigationBar\">\n        <button onClick={() => window.history.back()}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#nav-back`}/>\n          </svg>\n          <span>Back</span>\n        </button>\n        <small>{this.props.name}</small>\n        <button id=\"saveButton\" onClick={() => this.props.onSave()}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#save-download`}/>\n          </svg>\n          <span>Save</span>\n        </button>\n      </nav>\n    )\n  }\n}","import * as React from 'react';\n\nimport './Slider.css';\n\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  historyLength: number,\n  currentTime: number,\n  onCurrentTimeChange: (newState: number) => void,\n};\nexport default class Slider extends React.Component<Props, {}> {\n\n  private slider = React.createRef<HTMLInputElement>();\n\n  render() {\n    const {historyLength, currentTime, onCurrentTimeChange} = this.props;\n\n    return (\n      <section className=\"component-slider\">\n\n        <button disabled={currentTime <= 0} onClick={() => onCurrentTimeChange(currentTime - 1)}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#history-back`}/>\n          </svg>\n        </button>\n\n        <section className=\"wrapper\">\n          <input\n            ref={this.slider}\n            type=\"range\"\n            min={0}\n            max={historyLength}\n            value={currentTime}\n            onChange={() => onCurrentTimeChange(this.getSliderValue())}\n          />\n        </section>\n\n        <button disabled={currentTime >= historyLength} onClick={() => onCurrentTimeChange(currentTime + 1)}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#history-forward`}/>\n          </svg>\n        </button>\n\n      </section>\n    );\n  }\n\n  // HELPERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  getSliderValue(): number {\n    return this.slider.current ? parseInt(this.slider.current.value, 10) : 0;\n  }\n\n}\n","class SatVisAssertionError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = \"SatVisAssertionError\";\n    }\n  }\n\nexport function assert(condition, message=\"\") {\n    if (!condition)\n        throw new SatVisAssertionError('Assertion failed: ' + (message || ''));\n};","import * as React from 'react';\nimport {DataSet, Network, IdType, Node, Edge} from 'vis'\n\nimport './Graph.css'\nimport { assert } from '../model/util';\n\nimport { Dag } from '../model/dag';\nimport SatNode from '../model/sat-node';\n\nconst styleTemplates = require('../resources/styleTemplates');\n\ntype Props = {\n  dag: Dag,\n  nodeSelection: number[],\n  changedNodesEvent?: Set<number>,\n  currentTime: number,\n  animateDagChanges: boolean,\n  onNodeSelectionChange: (selection: number[]) => void,\n  onUpdateNodePositions: (nodeIds: Array<number>, delta: [number, number]) => void\n};\n\nexport default class Graph extends React.Component<Props, {}> {\n\n  markers = new Set<number>();\n  network: Network | null = null;\n  networkNodes = new DataSet<Node>([]);\n  networkEdges = new DataSet<Edge>([]);\n  graphContainer = React.createRef<HTMLDivElement>();\n  dragStartEvent: any = null;\n  cachedChangeNodesEvent?: Set<number> = undefined;\n\n  componentDidMount() {\n    this.generateNetwork();\n    this.updateNetwork(false);\n    this.network!.selectNodes(this.props.nodeSelection);\n    this.network!.fit();\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (this.props.dag !== prevProps.dag) {\n      this.updateNetwork(false);\n      this.network!.selectNodes(this.props.nodeSelection);\n      if (this.props.animateDagChanges) {\n        // center the view to selected nodes\n        this.network!.fit({\n          nodes: this.props.nodeSelection.map(nodeId => nodeId.toString()), \n          animation: true\n        });\n      } else {\n        // set the view so that the whole graph is visible\n        this.network!.fit();\n      }\n    } else {\n      if (this.props.nodeSelection !== prevProps.nodeSelection) {\n        this.network!.selectNodes(this.props.nodeSelection);\n      }\n      if (this.props.currentTime !== prevProps.currentTime) {\n        this.updateNetwork(true);\n      }\n      const incomingEvent = this.props.changedNodesEvent;\n      if (incomingEvent !== prevProps.changedNodesEvent) {\n        assert(incomingEvent !== undefined);\n        if (incomingEvent !== this.cachedChangeNodesEvent) {\n          this.cachedChangeNodesEvent = incomingEvent;\n\n          // update all nodes from event which occur in the dag\n          const visNodes = new Array<Node>();\n          for (const nodeId of incomingEvent!) {\n            if (this.props.dag.nodes.has(nodeId)) {\n              const visNode = {\n                id : nodeId,\n                label : this.props.dag.get(nodeId).toHTMLString(this.props.currentTime)\n              };\n              visNodes.push(visNode);\n            }\n          }\n          this.networkNodes.update(visNodes);\n        }\n      }\n    }\n  }\n\n  render() {\n    return (\n      <section className=\"component-graph\" ref={this.graphContainer}>\n        <canvas/>\n      </section>\n    );\n  }\n\n\n  // DISPLAY NETWORK ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  generateNetwork() {\n    assert(this.graphContainer.current);\n    assert(!this.network); // should only be called once\n\n    this.network = new Network(this.graphContainer.current!, {\n      nodes: this.networkNodes,\n      edges: this.networkEdges\n    }, {\n      physics: false,\n      interaction: {\n        multiselect: false\n      },\n    });\n\n    this.network.on('click', async (clickEvent) => {\n      if (clickEvent.nodes.length > 0) {\n        assert(clickEvent.nodes.length === 1);\n        const clickedNodeId = clickEvent.nodes[0];\n        \n        const originalEvent = clickEvent.event.srcEvent;\n        assert(originalEvent !== undefined && originalEvent !== null);\n\n        if (originalEvent.metaKey || originalEvent.ctrlKey) {\n          // note standard conventions:\n          // - on macOS, the command key (which maps on macOS to metaKey) is used for selecting multiple elements\n          // - on windows and linux, the ctrl key is used for selecting multiple elements\n          // we therefore check whether any of these keys is pressed\n          // this has the following side-effects, which we don't care about, at least for now: \n          // - one can use the ctrl key on macOS too for selecting multiple elements\n          // - one can use the windows key (which maps on windows to metaKey) too for selecting multiple elements\n          if (this.props.nodeSelection.find((nodeId: number) => nodeId === clickedNodeId) !== undefined) {\n            this.props.onNodeSelectionChange(this.props.nodeSelection.filter((nodeId: number) => nodeId !== clickedNodeId));\n          } else {\n            this.props.onNodeSelectionChange(this.props.nodeSelection.concat(clickEvent.nodes));\n          }\n        } else {\n          this.props.onNodeSelectionChange(clickEvent.nodes);\n        }\n      } else {\n        this.props.onNodeSelectionChange([]);\n      }\n    });\n\n    this.network.on('dragStart', (dragStartEvent) => {\n      assert(dragStartEvent !== undefined && dragStartEvent !== null);\n      assert(dragStartEvent.nodes !== undefined && dragStartEvent.nodes !== null);\n      this.dragStartEvent = dragStartEvent;\n      if (dragStartEvent.nodes.length > 0) {\n        this.props.onNodeSelectionChange(dragStartEvent.nodes);\n      }\n    });\n\n    this.network.on('dragEnd', (dragEndEvent) => {\n      assert(this.dragStartEvent !== undefined && this.dragStartEvent !== null);\n      assert(this.dragStartEvent.nodes !== undefined && this.dragStartEvent.nodes !== null);\n      assert(dragEndEvent !== undefined && dragEndEvent !== null);\n      assert(dragEndEvent.nodes !== undefined && dragEndEvent.nodes !== null);\n      if (dragEndEvent.nodes.length > 0 && !this.props.dag.isPassiveDag) {\n        const deltaX = dragEndEvent.pointer.canvas.x - this.dragStartEvent.pointer.canvas.x;\n        const deltaY = dragEndEvent.pointer.canvas.y - this.dragStartEvent.pointer.canvas.y;\n        this.props.onUpdateNodePositions(dragEndEvent.nodes as Array<number>, [deltaX / (-70), deltaY / (-120)]);\n      }\n    });\n  }\n\n  // updates the network displayed by Vis.js\n  // if onlyUpdateStyles is false, all nodes and edges are newly generated.\n  // if onlyUpdateStyles is true, only the attributes of the nodes and edges are updated\n  updateNetwork(onlyUpdateStyles: boolean) {\n    const {dag, currentTime} = this.props;\n\n    const visNodes = new Array<Node>();\n    const visEdges = new Array<Edge>();\n    let edgeId = 0;\n\n    // partition nodes:\n    // for standard dags, compute node partition\n    // for passive dags use style map cached in dag\n    const nodePartition = dag.isPassiveDag ? (dag.styleMap as Map<number, string>) : this.computeNodePartition(dag, currentTime);\n\n    // update network nodes\n    for (const [satNodeId, satNode] of dag.nodes) {\n      const nodeStyle = nodePartition.get(satNodeId);\n      assert(nodeStyle !== undefined, \"invar\");\n      if (nodeStyle === \"hidden\") {\n        const visNode = {id : satNodeId, hidden : true};\n        visNodes.push(visNode);\n      } else {\n        const visNode = this.toVisNode(satNode, nodeStyle, satNode.getPosition());\n        visNodes.push(visNode);\n      }\n\n      for (const parentId of satNode.parents) {\n        const visEdge = this.toVisEdge(edgeId, parentId, satNode.id, nodeStyle === \"hidden\");\n        edgeId = edgeId + 1;\n        visEdges.push(visEdge);\n      }\n    }\n\n    if(onlyUpdateStyles) {\n      // QUESTION: it seems that using a single call to update is faster than separately updating each node. is this true?\n      this.networkNodes.update(visNodes);\n      this.networkEdges.update(visEdges);\n    } else {\n      // QUESTION: it seems that using a single call to add is faster than separately adding each node. is this true?\n      this.networkNodes.clear();\n      this.networkNodes.add(visNodes);\n      this.networkEdges.clear();\n      this.networkEdges.add(visEdges);\n    }\n  }\n\n  computeNodePartition(dag: Dag, currentTime: number): Map<number, any> {\n\n    const nodesInActiveDag = dag.computeNodesInActiveDag(currentTime);\n\n    const nodePartition = new Map<number, any>();\n    for (const [nodeId, node] of dag.nodes) {\n\n      const isDeleted = (node.deletionTime !== null && node.deletionTime <= currentTime);\n\n      if (dag.nodeIsTheoryAxiom(nodeId)) {\n        nodePartition.set(nodeId, isDeleted ? \"theory-axiom-deleted\" : \"theory-axiom\");\n        continue;\n      }\n      if (node.isFromPreprocessing) {\n        if (node.inferenceRule === \"negated conjecture\") {\n          nodePartition.set(nodeId, \"conjecture\");\n        } else {\n          nodePartition.set(nodeId, isDeleted ? \"preprocessing-deleted\" : \"preprocessing\");\n        }\n        continue;\n      }\n\n      const isActivated = (node.activeTime !== null && node.activeTime <= currentTime);\n      if (isActivated) {\n        nodePartition.set(nodeId, isDeleted ? \"activated-deleted\" : \"activated\");\n        continue;\n      }\n\n      if (nodesInActiveDag.has(nodeId)) {\n        nodePartition.set(nodeId, \"deleted\");\n        continue;\n      } \n\n      nodePartition.set(nodeId, \"hidden\");\n    }\n\n    return nodePartition;\n  }\n\n  toVisNode(node: SatNode, style: string, position: [number, number]): any {\n    const styleData = styleTemplates[style];\n    const isMarked = this.markers.has(node.id);\n\n    return {\n      id : node.id,\n      label : node.toHTMLString(this.props.currentTime),\n      labelHighlightBold : false,\n      shape : \"box\",\n      color : {\n        border : isMarked ? styleData.markedStyle.border : styleData.defaultStyle.border,\n        background : isMarked ? styleData.markedStyle.background : styleData.defaultStyle.background,\n        highlight : {\n          border : styleData.highlightStyle.border,\n          background : styleData.highlightStyle.background\n        }\n      },\n      font : {\n        color : styleData.text,\n        multi : true\n      },\n      hidden : false,\n      x : Math.round(position[0] * -70),\n      y : Math.round(position[1] * -120)\n    };\n\n  }\n\n  toVisEdge(edgeId: number, parentNodeId: number, nodeId: number, hidden: boolean) {\n    return {\n      id : edgeId,\n      arrows : \"to\",\n      color : {\n        color : \"#dddddd\",\n        highlight : \"#f8cfc1\",\n      },\n      from : parentNodeId,\n      to : nodeId,\n      smooth : false,\n      hidden : hidden\n    }\n  }\n\n\n  // INTERACTION ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  findNodeAt(clickPosition: {layerX: number, layerY: number}): IdType  {\n    return this.network!.getNodeAt({\n      x: clickPosition.layerX,\n      y: clickPosition.layerY\n    });\n  }\n\n  // MARKERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  toggleMarker(nodeId: number) {\n    assert(this.networkNodes);\n\n    if (this.markers.has(nodeId)) {\n      this.markers.delete(nodeId);\n    } else {\n      this.markers.add(nodeId);\n    }\n    this.updateNetwork(true);\n  }\n\n}\n","import * as React from 'react';\n\nimport './NodeDetails.css';\nimport Sortable from 'react-sortablejs';\nimport {Clause} from '../model/unit';\nimport {Literal} from '../model/literal';\nimport SatNode from '../model/sat-node';\nimport {assert} from '../model/util';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  node: SatNode,\n  numberOfTransitiveActivatedChildren: number,\n  infoToggle: boolean,\n  editToggle: boolean,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\nexport default class NodeDetails extends React.Component<Props, {}> {\n  state = {\n    draggable: false\n  };\n\n  keep=true; // hack to skip each second event generated by Sortable\n\n  render() {\n    const statisticsStrings = new Array<string>();\n    statisticsStrings.push(\"Childs: \" + this.props.numberOfTransitiveActivatedChildren.toString());\n    for (let [key, value] of this.props.node.statistics) {\n      if (!['nSel', 'inD'].includes(key)) {\n        if (key === \"a\") {\n          key = \"Age\";\n        } else if (key === \"w\") {\n          key = \"Weight\";\n        }\n        statisticsStrings.push(`${key}: ${value}`);\n      }\n    }\n\n    return (\n      <section\n        className={'component-node-details details'}\n      >\n        <article>\n          <h2>Node <strong>{this.props.node.id}</strong></h2>\n\n          <div className=\"button-bar\">\n            <button\n              className={'toggle-button' + (this.props.infoToggle ? ' toggled': '')}\n              title={ this.props.infoToggle ? 'Hide statistics': 'Show statistics' }\n              onClick={this.props.onToggleInfo}\n            >\n              <svg viewBox=\"0 0 24 24\" className=\"icon\">\n                <use xlinkHref={`${icons}#toggle-info`}/>\n              </svg>\n            </button>\n            <button\n              className={'toggle-button' + (this.props.editToggle ? ' toggled': '')}\n              title={ this.props.editToggle ? 'Terminate edit mode': 'Enter edit mode' }\n              onClick={this.props.onToggleEdit}\n              disabled={this.props.node.unit.type !== 'Clause'}\n            >\n              <svg viewBox=\"0 0 24 24\" className=\"icon\">\n                <use xlinkHref={`${icons}#toggle-edit`}/>\n              </svg>\n            </button>\n          </div>\n\n          <h3>\n            {this.props.node.inferenceRule}\n          </h3>\n          {\n            this.props.infoToggle && <ul className=\"stats\">{ statisticsStrings.map((string, key) => <li key={key}>{string}</li>) }</ul>\n          }\n\n          {\n            (this.props.node.unit.type === 'Clause' && this.props.editToggle) ? (\n              <section\n                className={'literal-wrapper' + (this.state.draggable ? ' drag' : '')}\n                onMouseEnter={() => this.setState({draggable: true})}\n                onMouseLeave={() => this.setState({draggable: false})}\n              >\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"premise\")\n                }\n                <span className={'separator separator-arrow count-' + (this.props.node.unit as Clause).premiseLiterals.length}>{'\\u2192'}</span>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"conclusion\")\n                }\n                <span className={'separator separator-line count-' + (this.props.node.unit as Clause).contextLiterals.length}>&nbsp;</span>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"context\")\n                }\n              </section>\n            ) : (\n              <section className={'literal-wrapper read-mode'}>\n                {\n                  this.props.node.unit.toHTMLString(false)\n                }\n              </section>\n            )\n          }\n        </article>\n      </section>\n    );\n  }\n\n  toList = (nodeId: number, clause: Clause, orientation: \"premise\" | \"conclusion\" | \"context\") => {\n    const literals = orientation === \"premise\" ? clause.premiseLiterals : (orientation === \"conclusion\" ? clause.conclusionLiterals : clause.contextLiterals);\n\n    return (\n      <Sortable\n        options={{\n          group: 'shared'\n        }}\n        tag={\"ul\"}\n        id={orientation === \"premise\" ? \"id1\" : (orientation === \"conclusion\" ? \"id2\" : \"id3\")}\n        onChange={(_items, _sortable, event)=>{\n          // Hack: If from and to are different, then Sortable generates two identical events (one for each modified list), \n          // so we ignore the latter one using the flag this.keep\n          const from = event.from.id === \"id1\" ? \"premise\" : event.from.id === \"id2\" ? \"conclusion\" : \"context\";\n          const to = event.to.id === \"id1\" ? \"premise\" : event.to.id === \"id2\" ? \"conclusion\" : \"context\";\n          if (from === to) {\n            assert(this.keep);\n          }\n          if (this.keep) {\n            this.props.onLiteralOrientationChange(nodeId, [from, event.oldIndex], [to, event.newIndex]);\n          }\n          if (from !== to) {\n            this.keep = !this.keep;\n          }\n        }}\n      >\n        {\n          literals.map((literal, index) => this.toListItem(literal, index, orientation))\n        }\n      </Sortable>\n      )\n    };\n\n  toListItem = (literal: Literal, index: number, orientation: \"premise\" | \"conclusion\" | \"context\") => {\n    return <li key={index} data-id={index} onDoubleClick={(event) => {\n      this.props.onLiteralRepresentationChange(this.props.node.id, literal);\n      event.currentTarget.innerText = literal.toString(orientation === \"premise\");\n    }}>{literal.toString(orientation === \"premise\")}</li>\n  };\n}\n","import * as React from 'react';\nimport { Dag } from '../model/dag';\n\nimport NodeDetails from '../components/NodeDetails'\nimport { Literal } from '../model/literal';\n\ntype Props = {\n  dag: Dag | null,\n  nodeSelection: number[],\n  currentTime: number,\n  infoToggle: boolean,\n  editToggle: boolean,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: ['premise' | 'conclusion' | 'context', number], newPosition: ['premise' | 'conclusion' | 'context', number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\nexport class NodeDetailsWrapper extends React.Component<Props, {}> {\n\n  render() {\n    if (this.props.nodeSelection.length === 1) {\n      const node = this.props.dag!.get(this.props.nodeSelection[0]);\n      return (\n        <NodeDetails\n          node={node}\n          numberOfTransitiveActivatedChildren={this.props.dag!.numberOfTransitiveActivatedChildren(node.id, this.props.currentTime)}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n          onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n          onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n        />\n      )\n    } else {\n      return (\n        <section className={'component-node-details overview'}>\n          <small id=\"nodeInfo\"><strong>{`${this.props.nodeSelection.length} nodes`}</strong> selected</small>\n        </section>\n      )\n    }\n  }\n}","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport { Literal } from '../model/literal';\nimport { assert } from '../model/util';\nimport { NodeDetailsWrapper } from './NodeDetailsWrapper';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\n\ntype Props = {\n  dag: Dag,\n  currentTime: number,\n  nodeSelection: number[],\n  infoToggle: boolean,\n  editToggle: boolean,\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void\n  onSelectButtonPressed: () => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\nexport class PassiveDagAside extends React.Component<Props, {}> {\n\n  render() {\n    assert(this.props.dag.isPassiveDag);\n    assert(this.props.dag.styleMap !== null);\n    const selectClauseButtonEnabled = this.props.nodeSelection.length === 1 && this.props.dag.styleMap!.get(this.props.nodeSelection[0]) === \"passive\";\n\n    return (\n      <aside className=\"component-passive-aside\">\n        <section className=\"component-graph-menu\">\n          <button title=\"Select clauses\"\n                  disabled={!selectClauseButtonEnabled}\n                  onClick={() => { this.props.onSelectButtonPressed();}}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-s`}/>\n            </svg>\n          </button>\n        </section>\n        <NodeDetailsWrapper\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          currentTime={this.props.currentTime}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n          onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n          onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n        />\n      </aside>\n    );\n  }\n\n}\n","import { assert } from './util'\nimport { Unit } from './unit'\n\nexport default class SatNode {\n\n  readonly id: number;\n  unit: Unit;\n  readonly inferenceRule: string;\n  readonly parents: number[];\n  statistics: Map<string,number>;\n  readonly isFromPreprocessing: boolean;\n  newTime: number | null;\n  activeTime: number | null;\n  deletionTime: number | null;\n  deletionParents: number[];\n  position: [number,number] | null;\n  isBoundary: boolean;\n\n  constructor(\n    id: number,\n    unit: Unit,\n    inferenceRule: string,\n    parents: number[],\n    statistics: Map<string,number>,\n    isFromPreprocessing: boolean,\n    newTime: number | null,\n    activeTime: number | null,\n    deletionTime: number | null,\n    deletionParents: number[],\n    isBoundary: boolean\n  ) {\n    this.id = id;\n    this.unit = unit;\n    this.inferenceRule = inferenceRule;\n    this.parents = parents;\n    this.statistics = statistics;\n    this.isFromPreprocessing = isFromPreprocessing;\n    this.newTime = newTime;\n    this.activeTime = activeTime;\n    this.deletionTime = deletionTime;\n    this.deletionParents = deletionParents;\n    this.position = null;\n    this.isBoundary = isBoundary;\n  }\n\n  // return a copy of this node, where the position is null\n  copy(): SatNode {\n    return new SatNode(this.id, this.unit, this.inferenceRule, this.parents, this.statistics, this.isFromPreprocessing, this.newTime, this.activeTime, this.deletionTime, this.deletionParents, this.isBoundary);\n  }\n\n  getPosition(): [number,number] {\n    assert(this.position !== null, `accessing position of node with id ${this.id}, which has not been computed`);\n    return this.position as [number,number];\n  }\n\n  toString(): string {\n    return this.unit.toString();\n  }\n\n  toHTMLString(currentTime: number): string {\n    const isActive = this.activeTime !== null && this.activeTime <= currentTime;\n    return this.unit.toHTMLString(isActive);\n  }\n}","import {assert} from './util'\nimport {Literal} from './literal'\n\n// a unit is either a Formula or a clause.\n// units are also used internally by Vampire.\n// we fully parse clauses, but we keep formulas as string.\n// fully parsing formulas is more involved, in particular if one wants to support a reasonably complete subset of tptp.\nexport type Unit = Formula | Clause;\n\nexport class Formula {\n  readonly type: \"Formula\" | \"Clause\";\n  readonly formula: string;\n  \n  constructor(formula: string) {\n    this.type = \"Formula\";\n    this.formula = formula;\n  }\n\n  toString(): string {\n    return this.formula;\n  }\n\n  toHTMLString(isActive: boolean): string {\n    return this.formula;\n  }\n}\n\nexport class Clause {\n  readonly type: \"Formula\" | \"Clause\";\n  readonly literalsNewEvent: Literal[];\n\n  // literalsNewEvent is partitioned into premiseLiterals, conclusionLiterals and contextLiterals\n  // the referenced literals are not only equal, but the same as the literals in literalsNewEvent\n  premiseLiterals: Literal[];\n  conclusionLiterals: Literal[];\n  contextLiterals: Literal[];\n  \n  // in order to compute literal flows we need to save the order in which literals occured in the clause\n  // not only at the timepoints of the new-event but also at the timepoint of the active-event.\n  // the referenced literals are not only equal, but the same as the literals in literalsNewEvent\n  literalsActiveEvent: Literal[] | null;\n\n  constructor(literalsNewEvent: Array<Literal>, premiseLiterals: Array<Literal>, conclusionLiterals: Array<Literal>, contextLiterals: Array<Literal>){\n    this.type = \"Clause\";\n    this.literalsNewEvent = literalsNewEvent;\n    this.premiseLiterals = premiseLiterals;\n    this.conclusionLiterals = conclusionLiterals;\n    this.contextLiterals = contextLiterals;\n    this.literalsActiveEvent = null;\n  }\n\n  changeLiteralOrientation(oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) {\n\n    // remove literal from old position\n    let removedLiterals: Array<Literal> | null = null;\n    if (oldPosition[0] === \"premise\") {\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.premiseLiterals.length);\n      removedLiterals = this.premiseLiterals.splice(oldPosition[1], 1);\n    } else if (oldPosition[0] === \"conclusion\"){\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.conclusionLiterals.length);\n      removedLiterals = this.conclusionLiterals.splice(oldPosition[1], 1);\n    } else {\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.contextLiterals.length);\n      removedLiterals = this.contextLiterals.splice(oldPosition[1], 1);\n    }\n    assert(removedLiterals.length === 1);\n    const removedLiteral = removedLiterals[0];\n\n    // add literal to new position\n    if (newPosition[0] === \"premise\") {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.premiseLiterals.length);\n      this.premiseLiterals.splice(newPosition[1], 0, removedLiteral);\n    } else if (newPosition[0] === \"conclusion\") {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.conclusionLiterals.length);\n      this.conclusionLiterals.splice(newPosition[1], 0, removedLiteral);\n    } else {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.contextLiterals.length);\n      this.contextLiterals.splice(newPosition[1], 0, removedLiteral);\n    }\n    removedLiteral.orientationReason = \"user\";\n  }\n\n  toString(): string {\n    if (this.premiseLiterals.length === 0 && this.conclusionLiterals.length === 0 && this.contextLiterals.length === 0) {\n      return \"$false\"; // empty clause\n    }\n    const literals = this.premiseLiterals.concat(this.conclusionLiterals, this.contextLiterals);\n    return literals.map(literal => literal.toString(false)).join(\" | \");\n  }\n\n  toHTMLString(isActive: boolean): string {\n    let premiseString = this.premiseLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(true) + \"</b>\") : literal.toString(true))\n      .join(\" & \");\n    let conclusionString = this.conclusionLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(false) + \"</b>\") : literal.toString(false))\n      .join(\" | \");\n    let contextString = this.contextLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(false) + \"</b>\") : literal.toString(false))\n      .join(\" | \");\n    let premiseStringWithoutBoldness = this.premiseLiterals\n      .map(literal => literal.toString(true))\n      .join(\" & \");\n    let conclusionStringWithoutBoldness = this.conclusionLiterals\n      .map(literal => literal.toString(false))\n      .join(\" | \");\n    let contextStringWithoutBoldness = this.contextLiterals\n      .map(literal => literal.toString(false))\n      .join(\" | \");\n    if(this.conclusionLiterals.length === 0) {\n      conclusionString = \"$false\";\n      conclusionStringWithoutBoldness = \"$false\";\n    }\n\n    // simple heuristic to estimate the length of the separating line between premise and conclusion.\n    const estimatedLengthOfLine = Math.ceil(Math.max(premiseStringWithoutBoldness.length, conclusionStringWithoutBoldness.length, contextStringWithoutBoldness.length) * 0.8);\n    const line = \"\\u2013\".repeat(estimatedLengthOfLine);\n\n    // don't use bold strings if clause is not activated yet\n    if (!isActive) {\n      premiseString = premiseStringWithoutBoldness;\n      conclusionString = conclusionStringWithoutBoldness;\n      contextString = contextStringWithoutBoldness;\n    }\n\n    const implication = this.premiseLiterals.length === 0 ? conclusionString : (premiseString + \"\\n\\u2192\\n\" + conclusionString);\n\n    return this.contextLiterals.length === 0 ? implication : (implication + \"\\n\" + line + \"\\n\" + contextString);\n  }\n}","import { assert } from \"./util\";\n\nexport class Literal {\n\treadonly name: string;\n\treadonly args: Term[];\n\treadonly negated: boolean;\n\tisSelected: boolean;\n\trepresentation: number;\n\thideBracketsAssoc: boolean;\n\tnonStrictForNegatedStrictInequalities: boolean;\n\tliteralInParent: Literal | null;\n\torientationReason: \"user\" | \"inherited\" | \"heuristic\" | \"none\";\n\n\tconstructor(name:string, args: Term[], negated: boolean){\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.negated = negated;\n\t\tthis.isSelected = false;\n\t\tthis.representation = 0; // 0 represents standard representation. Some literals may define other representations\n\t\tthis.hideBracketsAssoc = true;\n\t\tthis.nonStrictForNegatedStrictInequalities = true;\n\t\tthis.literalInParent = null;\n\t\tthis.orientationReason = \"none\";\n\t}\n\n\tsetLiteralInParent(literalInParent: Literal) {\n\t\tthis.literalInParent = literalInParent;\n\t}\n\n\tswitchToNextRepresentation() {\n\t\tif (this.name === \"$less\" || this.name === \"Sub\" || this.name === \"=\") {\n\t\t\tif (this.representation === 0) {\n\t\t\t\tthis.representation = 1;\n\t\t\t} else {\n\t\t\t\tthis.representation = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(negateLiteral: boolean) : string {\n\t\tconst occursNegated = negateLiteral ? !this.negated : this.negated;\n\n\t\tif (this.name === \"=\") {\n\t\t\tassert(this.args.length === 2, \"equalities must have exactly two arguments\");\n\t\t\tconst switchSides = this.representation === 1;\n\t\t\tconst lhs = this.args[switchSides ? 1 : 0].toString(this.hideBracketsAssoc);\n\t\t\tconst rhs = this.args[switchSides ? 0 : 1].toString(this.hideBracketsAssoc);\n\t\t\treturn lhs + (occursNegated ? \" != \" : \" = \") + rhs;\n\t\t}\n\t\tif (this.name === \"$less\" || this.name === \"Sub\") {\n\t\t\tassert(this.args.length === 2, \"inequalities must have exactly two arguments\");\n\t\t\tconst switchSides = this.representation === 1;\n\t\t\tconst lhs = this.args[switchSides ? 1 : 0].toString(this.hideBracketsAssoc);\n\t\t\tconst rhs = this.args[switchSides ? 0 : 1].toString(this.hideBracketsAssoc);\n\t\t\tlet symbol;\n\t\t\tif (switchSides) {\n\t\t\t\tsymbol = occursNegated ? (this.nonStrictForNegatedStrictInequalities ? \" <= \" : \" !> \") : \" > \";\n\t\t\t} else {\n\t\t\t\tsymbol = occursNegated ? (this.nonStrictForNegatedStrictInequalities ? \" >= \" : \" !< \") : \" < \";\n\t\t\t}\n\t\t\treturn lhs + symbol + rhs;\n\t\t}\n\n\t\t// could also use logical-not-symbol: \"\\u00AC\"\n\t\treturn (occursNegated ? \"!\" : \"\") + this.name + \"(\" + this.args.map(arg => arg.toString(this.hideBracketsAssoc)).join(\",\") + \")\";\n\t}\n}\n\nexport class Term {\n\treadonly name: string;\n\treadonly args: Term[];\n\treadonly isVariable: boolean;\n\t\n\tconstructor(name: string, args: Term[]) {\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tconst isVariable = name.startsWith(\"X\")\n\t\tthis.isVariable = isVariable;\n\t\tif(isVariable) {\n\t\t\tassert(this.args.length === 0);\n\t\t}\n\t}\n\n\ttoString(hideBracketsAssoc: boolean): string {\n\t\tlet name = this.name;\n\t\tif(this.name === \"$sum\") {\n\t\t\tname = \"+\";\n\t\t} else if(this.name === \"$uminus\") {\n\t\t\tname = \"-\";\n\t\t}\n\n\t\tif(this.args.length === 0){\n\t\t\treturn name;\n\t\t} else {\n\t\t\tif (name === \"+\"){\n\t\t\t\tconst inner = this.args.map(arg => arg.toString(hideBracketsAssoc)).join(\"+\");\n\t\t\t\tif (hideBracketsAssoc) {\n\t\t\t\t\treturn inner;\n\t\t\t\t} else {\n\t\t\t\t\treturn \"(\" + inner + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn name + \"(\" + this.args.map(arg => arg.toString(hideBracketsAssoc)).join(\",\") + \")\";\n\t\t}\n\t}\n}\n\n\n\n","import {assert} from './util'\nimport {Unit, Formula, Clause} from './unit'\nimport {Literal, Term} from './literal'\n\n// class for parsing Units, Formulas, Clauses, Literals and Terms\nexport class UnitParser {\n\n\tstatic parsePreprocessingUnit(string: string): Unit {\n\t\t// heuristic to determine whether unit is a clause:\n\t\t// if unit only contains certain symbols, it has to be a clause\n\t\t// otherwise, treat it as a formula.\n\t\tconst symbolsAllowedInClauses = /^[a-zA-Z0-9()=,~!$ |']+$/;\n\t\tlet isClause = string.match(symbolsAllowedInClauses);\n\t\n\t\tif(isClause) {\n\t\t  return UnitParser.parseClause(string);\n\t\t} else {\n\t\t  return new Formula(string);\n\t\t}\n\t}\n\n\tstatic parseClause(string: string): Clause {\n\t\tif(string === \"$false\") {\n\t\t\treturn new Clause([], [], [], []); // empty clause\n\t\t}\n\n\t\tconst literals = this.parseLiterals(string);\n\t\treturn new Clause(literals, [], Array.from(literals), []);\n\t}\n\n\tstatic parseLiterals(string: string): Array<Literal> {\n\t\tconst literalStrings = string.split(\" | \");\n\t\tconst literals = new Array<Literal>();\n\t\tfor (let i = 0; i < literalStrings.length; i++) {\n\t\t\tliterals.push(UnitParser.parseLiteral(literalStrings[i]));\n\t\t}\n\t\treturn literals;\n\t}\n\n\tstatic parseLiteral(string: string): Literal {\n\t\t// need to handle equality separately, since it is written in infix-notation\n\t\t// all other predicates are written in prefix-notation\n\t\tlet equalityPosition = string.search(\"=\");\n\t\tif(equalityPosition !== -1)\n\t\t{\n\t\t\t// Vampire's printing of FOOL-formulas is quite hacky,\n\t\t\t// in particular FOOL-equalities always occur inside brackets, even for top-level literals\n\t\t\t// where the brackets are unnecessary\n\t\t\tif(string[0] === \"(\") {\n\t\t\t\tassert(string[string.length - 1] === \")\");\n\t\t\t\tstring = string.substring(1, string.length - 1);\n\t\t\t\tassert(equalityPosition > 0);\n\t\t\t\tequalityPosition -= 1;\n\t\t\t}\n\t\t\tif(string[equalityPosition - 1] === \"!\") {\n\t\t\t\tassert(string[equalityPosition - 2] === \" \", `negated equality not surrounded by spaces in string ${string}`);\n\t\t\t\tassert(string[equalityPosition + 1] === \" \", `negated equality not surrounded by spaces in string ${string}`);\n\t\t\t\tconst lhsString = string.substring(0, equalityPosition - 2);\n\t\t\t\tconst rhsString = string.substring(equalityPosition + 2, string.length);\n\t\t\t\tconst lhs = UnitParser.parseTerm(lhsString);\n\t\t\t\tconst rhs = UnitParser.parseTerm(rhsString);\n\t\t\t\treturn new Literal(\"=\", [lhs, rhs], true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(string[equalityPosition - 1] === \" \", `equality not surrounded by spaces in string ${string}`);\n\t\t\t\tassert(string[equalityPosition + 1] === \" \", `equality not surrounded by spaces in string ${string}`);\n\t\t\t\tconst lhsString = string.substring(0, equalityPosition - 1);\n\t\t\t\tconst rhsString = string.substring(equalityPosition + 2, string.length);\n\t\t\t\tconst lhs = UnitParser.parseTerm(lhsString);\n\t\t\t\tconst rhs = UnitParser.parseTerm(rhsString);\n\t\t\t\t\n\t\t\t\treturn new Literal(\"=\", [lhs, rhs], false);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst negated = (string[0] === \"~\");\n\t\t\tconst atomString = negated ? string.substring(1) : string;\n\n\t\t\t// parse atom as term first and then convert it to literal\n\t\t\tconst literalTerm = UnitParser.parseTerm(atomString);\n\t\t\treturn new Literal(literalTerm.name, literalTerm.args, negated);\n\t\t}\n\t}\n\n\tstatic parseTerm(string:string): Term {\n\t\t// Part 1: lex tokens\n\t\tlet tokens: string[] = [];\n\t\tlet stringPos = 0;\n\t\twhile(stringPos < string.length) {\n\t\t\tconst char = string[stringPos];\n\t\t\t\n\t\t\tif (char === \"(\" || char === \")\" || char === \",\") {\n\t\t\t\ttokens.push(char);\n\t\t\t\tstringPos = stringPos + 1;\n\t\t\t} else {\n\t\t\t\tlet tokenEnd = stringPos;\n\t\t\t\twhile(tokenEnd < string.length \n\t\t\t\t\t&& string[tokenEnd] !== \"(\" \n\t\t\t\t\t&& string[tokenEnd] !== \")\" \n\t\t\t\t\t&& string[tokenEnd] !== \",\") {\n\t\t\t\t\ttokenEnd = tokenEnd + 1;\n\t\t\t\t}\n\t\t\t\ttokens.push(string.substring(stringPos,tokenEnd));\n\t\t\t\tstringPos = tokenEnd;\n\t\t\t}\n\t\t}\n\n\t\t// Part 2: add brackets after each string token which is not succeeded by brackets (that is, for each constant)\n\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tif(token !== \"(\" && token !== \")\" && token !== \",\"){\n\t\t\t\tif(i+1 === tokens.length || tokens[i+1] !== \"(\") {\n\t\t\t\t\ttokens.splice(i+1,0,\"(\");\n\t\t\t\t\ttokens.splice(i+2,0,\")\");\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\t// Part 3: parse token array\n\t\tlet stack: Array<Array<string|Term>> = [[]];\n\n\t\tfor (let pos = 0; pos < tokens.length; pos++) {\n\t\t\tconst token = tokens[pos];\n\n\t\t\tif(token !== \"(\" && token !== \")\" && token !== \",\")\n\t\t\t{\n\t\t\t\tstack[stack.length - 1].push(token);\n\t\t\t} \n\t\t\telse if (token === \"(\") \n\t\t\t{\n\t\t\t\tstack.push([]);\n\t\t\t}\n\t\t\telse if (token === \")\") \n\t\t\t{\n\t\t\t\tconst args = stack.pop() as Array<string | Term>;\n\t\t\t\tconst name = stack[stack.length - 1].pop();\n\t\t\t\tconst f = new Term(name as string, args as Array<Term>);\n\t\t\t\tstack[stack.length - 1].push(f);\n\t\t\t}\n\t\t}\n\n\t\tassert(stack.length === 1, \"invar violated for string: \" + string);\n\t\t// assert(stack[0].length === 1, \"invar violated for string:\" + string + \":\");\n\t\treturn stack[0][0] as Term;\n\t}\n}","\nimport { assert } from \"./util\";\nimport { Dag } from \"./dag\";\nimport SatNode from \"./sat-node\";\n\n// iterator for traversing DAG, where each node is visited only after all parents are visited\n// implements standard iterative depth-first postorder traversal\nexport class DFPostOrderTraversal {\n\t\n\treadonly dag: Dag;\n\ttodo: Array<number>;\n\tvisited: Set<number>;\n\t\n\tconstructor(dag: Dag) {\n\t\tthis.dag = dag;\n\t\tthis.todo = Array.from(dag.leaves);\n\t\tthis.visited = new Set();\n\t}\n\n\thasNext(): boolean {\n\t\twhile (this.todo.length > 0) {\n\t\t\tconst last = this.todo[this.todo.length - 1];\n\t\t\tif (this.visited.has(last)) {\n\t\t\t\tthis.todo.pop();\n\t\t\t} else {\n\t\t\t\t// there exists at least one unvisited node\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// returns the next node (the actual node, not its id) for traversal\n\t// note: only call this method after checking for has_next\n\tgetNext(): SatNode {\n\t\twhile (this.todo.length > 0) {\n\t\t\tconst currentId = this.todo[this.todo.length - 1];\n\t\t\tconst currentNode = this.dag.get(currentId);\n\n\t\t\t// if we haven't already visited the current unit\n\t\t\tif (!this.visited.has(currentId)) {\n\t\t\t\tlet existsUnvisitedParent = false;\n\t\t\t\t\n\t\t\t\t// add unprocessed parents to stack for DFS.\n\t\t\t\t// If there is at least one unprocessed parent, don't compute the result\n\t\t\t\t// for current_id now, but wait until those unprocessed parents are processed.\n\t\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\t\t// if we haven't visited the parent yet\n\t\t\t\t\tif (! this.visited.has(parentId)) {\n\t\t\t\t\t\t// add it to the stack\n\t\t\t\t\t\tthis.todo.push(parentId);\n\t\t\t\t\t\texistsUnvisitedParent = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if we already visited all parents, we can visit the node too\n\t\t\t\tif (!existsUnvisitedParent) {\n\t\t\t\t\tthis.visited.add(currentId);\n\t\t\t\t\tthis.todo.pop();\n\t\t\t\t\treturn currentNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.todo.pop();\n\t\t\t}\n\t\t}\n\t\tassert(false, \"We have already iterated through all the inferences, so getNext() should not been called\");\n\t\treturn null as unknown as SatNode;\n\t}\n}\n\n// iterator for traversing DAG, where each node is visited before any parent node is visited\n// implemented as reversed postorder traversal\nexport class ReversePostOrderTraversal {\n\tpostOrder: Array<SatNode>;\n\n\tconstructor(dag: Dag) {\n\t\t// compute post order and save result in postOrder\n\t\tconst it = new DFPostOrderTraversal(dag);\n\t\tthis.postOrder = [];\n\t\twhile (it.hasNext()) {\n\t\t\tthis.postOrder.push(it.getNext() as SatNode);\n\t\t}\n\t}\n\n\thasNext(): boolean {\n\t\treturn this.postOrder.length > 0;\n\t}\n\n\tgetNext(): SatNode {\n\t\tassert(this.hasNext(), \"We have already iterated through all the inferences, so getNext() should not have been called\");\n\t\treturn this.postOrder.pop() as SatNode;\n\t}\n\n}","import { Literal, Term } from \"./literal\";\nimport { assert } from \"./util\";\n\nexport type Substitution = Map<string, Term>;\n\nexport function literalsMatch(literal1: Literal, literal2: Literal, allowSubstitutions: boolean) {\n\tif (allowSubstitutions) {\n\t\treturn isSubstitution(literal1, literal2);\n\t} else {\n\t\treturn isEqual(literal1, literal2);\n\t}\n}\n\nexport function isEqual(literal1: Literal, literal2: Literal): boolean {\n\tif (literal1.name !== literal2.name || literal1.negated !== literal2.negated || literal1.args.length !== literal2.args.length) {\n\t\treturn false;\n\t}\n\tlet success = true;\n\tfor (let i = 0; i < literal1.args.length; i++) {\n\t\tconst arg1 = literal1.args[i];\n\t\tconst arg2 = literal2.args[i];\n\t\tif (!termsAreEqual(arg1,arg2)) {\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// support commutativity of equalities\n\tif (!success && literal1.name === \"=\") {\n\t\tassert(literal1.args.length === 2);\n\t\tsuccess = \n\t\t\ttermsAreEqual(literal1.args[0], literal2.args[1]) &&\n\t\t\ttermsAreEqual(literal1.args[1], literal2.args[0]);\n\t}\n\n\treturn success;\n}\n\nexport function termsAreEqual(f1: Term, f2: Term) {\n\tif (f1.name !== f2.name || f1.args.length !== f2.args.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < f1.args.length; i++) {\n\t\tconst arg1 = f1.args[i];\n\t\tconst arg2 = f2.args[i];\n\t\tif (!termsAreEqual(arg1,arg2)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// returns true if literal1 can be obtained from literal2 by substitution\nexport function isSubstitution(literal1: Literal, literal2: Literal): boolean {\n\tif (literal1.name !== literal2.name || literal1.negated !== literal2.negated || literal1.args.length !== literal2.args.length) {\n\t\treturn false;\n\t}\n\tlet success = true;\n\tconst substitution = new Map<string, Term>();\n\tfor (let i = 0; i < literal1.args.length; i++) {\n\t\tconst arg1 = literal1.args[i];\n\t\tconst arg2 = literal2.args[i];\n\t\tsuccess = computeSubstitution(arg1,arg2, substitution);\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// support commutativity of equalities\n\tif (!success && literal1.name === \"=\") {\n\t\tassert(literal1.args.length === 2);\n\t\tconst substitutionEq = new Map<string, Term>();\n\t\tsuccess = computeSubstitution(literal1.args[0], literal2.args[1], substitutionEq);\n\t\tif (success) {\n\t\t\tsuccess = computeSubstitution(literal1.args[1], literal2.args[0], substitutionEq);\n\t\t}\n\t}\n\t\n\treturn success;\n}\n\n// compute whether f1 can be obtained from f2 using a substitution compatible with substitution\n// if yes, returns true and updates the substitution\n// if no, returns false, and there are no guarantees on the state of substitution\nexport function computeSubstitution(f1: Term, f2: Term, substitution: Substitution): boolean {\n\tif (f1.name === f2.name && f1.args.length === f2.args.length) {\n\t\tfor (let i = 0; i < f1.args.length; i++) {\n\t\t\tconst arg1 = f1.args[i];\n\t\t\tconst arg2 = f2.args[i];\n\t\t\tconst success = computeSubstitution(arg1,arg2, substitution);\n\t\t\tif (!success) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (f2.isVariable) {\n\t\tconst substitutedVariable = substitution.get(f2.name);\n\t\tif (substitutedVariable === undefined) {\n\t\t\tsubstitution.set(f2.name, f1);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn computeSubstitution(f1, substitutedVariable, substitution);\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}","import SatNode from './sat-node';\nimport { assert } from './util';\nimport { UnitParser } from './unit-parser';\nimport { ReversePostOrderTraversal, DFPostOrderTraversal } from \"./traversal\";\nimport { Clause } from './unit';\nimport { literalsMatch } from './substitution';\nimport { Literal } from './literal';\n\nexport class ParsedLine {\n  readonly type: \"preprocessing\" | \"new\" | \"active\" | \"forward reduce\" | \"backward reduce\" | \"replaced by\" | \"using\";\n  readonly id: number;\n  readonly unitString: string;\n  readonly inferenceRule: string;\n  parents: Array<number>;\n  readonly statistics: Map<any, any>; \n\n  constructor(type: \"preprocessing\" | \"new\" | \"active\" | \"forward reduce\" | \"backward reduce\" | \"replaced by\" | \"using\", id: number, unitString: string, inferenceRule: string, parents: Array<number>, statistics: Map<any, any>) {\n    this.type = type;\n    this.id = id;\n    this.unitString = unitString;\n    this.inferenceRule = inferenceRule;\n    this.parents = parents;\n    this.statistics = statistics;\n  }\n}\n\nexport type SatNodeStyle = \"passive\" | \"deleted\" | \"activated\" | \"activated-deleted\" | \"boundary\" | \"boundary-deleted\" | \"preprocessing\" | \"preprocessing-deleted\" | \"theory-axiom\" | 'theory-axiom-deleted' | \"conjecture\";\nexport class Dag {\n\n  // TODO: it seems that the result of Graphviz depends on the order of node- and edge declarations.\n  //       the order of these declarations depends on the order in which the nodes occur in the nodes-Map.\n  //       therefore it could make sense to normalize the order of nodes in the nodes-Map at construction time of the Dag.\n  readonly nodes: Map<number,SatNode>;\n  readonly leaves: Set<number>;\n  readonly mergeMap: Map<number, Array<number>> | null;\n  \n  // invar: if isPassiveDag, then styleMap !== null\n  readonly isPassiveDag: boolean;\n  readonly styleMap: Map<number, SatNodeStyle> | null;\n  readonly activeNodeId: number | null; // the id of the node for which passiveDag was computed\n\n  constructor(nodes: Map<number,SatNode>, mergeMap: Map<number, Array<number>> | null = null, isPassiveDag: boolean = false, styleMap: Map<number, SatNodeStyle> | null = null, activeNodeId: number | null = null) {\n    this.nodes = nodes;\n    this.mergeMap = mergeMap;\n\n    assert(!isPassiveDag || styleMap !== null);\n    assert(!isPassiveDag || activeNodeId !== null);\n    assert(!isPassiveDag || nodes.has(activeNodeId as number));\n\n    this.isPassiveDag = isPassiveDag;\n    this.styleMap = styleMap;\n    this.activeNodeId = activeNodeId;\n\n    // sanity check: key and id of node need to match\n    for (const [nodeId, node] of nodes) {\n      assert(nodeId === node.id, `key ${nodeId} and id ${node.id} of node ${node} don't match!`);\n    }\n\n    // sanity check: each parentId needs to occur in the derivation as node\n    for (const [nodeId, node] of nodes) {\n      for (const parentId of node.parents) {\n        assert(nodes.has(parentId), `node ${nodeId} has parent ${parentId} which does not occur as node in the dag!`);\n      }\n    }\n    // compute leaves\n    const leaves: Set<number> = new Set();\n    const nonLeaves: Set<number> = new Set();\n    \n    for (const node of nodes.values()) {\n      for (const parentId of node.parents) {\n        nonLeaves.add(parentId);\n      }\n    }\n\n    for (const nodeId of nodes.keys()) {\n      if(!nonLeaves.has(nodeId)) {\n        leaves.add(nodeId);\n      }\n    }\n\n    this.leaves = leaves;\n  }\n\n  get(nodeId: number): SatNode {\n    const node = this.nodes.get(nodeId);\n    assert(node !== undefined, \"node doesn't occur in Dag\");\n    return node as SatNode;\n  }\n\n  maximalActiveTime(): number {\n    let max = 0;\n    for (const node of this.nodes.values()) {\n      if (node.activeTime !== null && node.activeTime > max) {\n        max = node.activeTime;\n      }\n    }\n    return max;\n  }\n\n  isEmpty(): boolean {\n    return this.nodes.size === 0;\n  }\n\n  getChildren(nodeId: number): Array<number> {\n    if(!this.nodes.has(nodeId)) {\n      assert(false, \"Node with id \" + nodeId + \" does not occur in Dag\");\n    }\n\n    const children = new Array<number>();\n    for (const node of this.nodes.values()) {\n      for (const parentId of node.parents) {\n        if (parentId === nodeId) {\n          children.push(node.id);\n        }\n      }\n    }\n    return children;\n  }\n\n  numberOfTransitiveActivatedChildren(nodeId: number, currentTime: number) {\n    let counter = 0;\n\n        // use new set to avoid mutating relevantIds\n    const transitiveChildrenIds = new Set<number>([nodeId]);\n\n    // add all transitive children of ids in transitiveChildren to transitiveChildren\n    const iterator = new DFPostOrderTraversal(this);\n    while (iterator.hasNext()) {\n      let currentNode = iterator.getNext();\n\n      // check if currentNode occurs in transitiveChildren or\n      // has a parent which occurs in transitiveChildren\n      let existsRelevantParent = false;\n      for (const parentId of currentNode.parents) {\n        if (transitiveChildrenIds.has(parentId)) {\n          existsRelevantParent = true;\n          break;\n        }\n      }\n      const isRelevant = existsRelevantParent || transitiveChildrenIds.has(currentNode.id);\n      const alreadyGenerated = currentNode.isFromPreprocessing || (currentNode.newTime !== null && currentNode.newTime <= currentTime);\n      if (isRelevant && alreadyGenerated) {\n        // add its id to the set of relevant ids\n        transitiveChildrenIds.add(currentNode.id);\n\n        const alreadyActivated = currentNode.activeTime !== null && currentNode.activeTime <= currentTime;\n        if (currentNode.id !== nodeId && alreadyActivated) {\n          counter = counter + 1;\n        }\n      }\n    }\n\n    return counter;\n  }\n\n  /* we can partition all nodes of the derivation into three sets\n   * 1) inputNodes: the nodes given to Vampire's preprocessing as input\n   * 2) preprocessingResultNodes: the nodes remaining at the end of Vampire's preprocessing, (which are then used as input for saturation)\n   * 3) otherNodes: the nodes generated by saturation\n   *\n   * this function decides for a given node whether it should be treated as input node, using the following idea:\n   * 1) input nodes occur before saturation is started and are therefore tagged with \"isFromPreprocessing\"\n   * 2) preprocessingResultNodes are used as input for saturation, so their newTime is set\n   */ \n  nodeIsInputNode(nodeId: number): boolean {\n    const node = this.get(nodeId);\n\n    if (!node.isFromPreprocessing) {\n      return false;\n    }\n    if(node.newTime !== null) {\n      return false;\n    }\n    return true;\n  }\n\n  // heuristics to determine whether a node is a theory axiom\n  // note: Vampire uses \"theory axiom\" for some of the internal theory axioms\n  // the internal theory axioms added for term algebras do not follow this convention\n  // even more, one of those term algebra axioms (the exhaustiveness axiom) is added as formula (in contrast to all other axioms which are added as clauses)\n  // in particular, the exhaustiveness axiom consists of a formula labelled \"term algebras exhaustiveness\" and a child node which is labelled cnf transformation\n  nodeIsTheoryAxiom(nodeId: number): boolean {\n    const node = this.get(nodeId);\n\n    if (!node.isFromPreprocessing) {\n      return false;\n    }\n    if (node.inferenceRule === \"theory axiom\" || \n        node.inferenceRule === \"term algebras injectivity\" || \n        node.inferenceRule === \"term algebras distinctness\" ||\n        node.inferenceRule === \"term algebras exhaustiveness\" ||\n        (node.parents.length === 1 && this.get(node.parents[0]).inferenceRule ===  \"term algebras exhaustiveness\")) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // either 1) create a new dag given an array of parsed lines and no existing dag,\n  // or     2) extend an existing dag with an array of parsed lines\n  // In case 2) we assume that all the parsedLines are generated during Saturation, i.e. no additional preprocessing occurs.\n  static fromParsedLines(parsedLines: Array<ParsedLine>, existingDag: Dag | null): Dag {\n    const nodes = (existingDag === null) ? new Map<number, SatNode>() : new Map<number, SatNode>(existingDag.nodes);\n\n    let currentNode: SatNode | null = null;\n    let currentTime = (existingDag === null) ? 0 : existingDag.maximalActiveTime();\n\n    let emptyClauseNode: SatNode | null = null;\n\n    for (const line of parsedLines) {\n\n      // some preprocessing nodes have potentially been merged, and there could be parsedLines which still reference the ids of these nodes.\n      // we therefore convert those ids using the merge-map\n      if (existingDag !== null && existingDag.mergeMap !== null) {\n        assert(existingDag.mergeMap.get(line.id) === undefined, `found line with id ${line.id} of node deleted during merge of preprocessing nodes!`);\n        const parentsAfterMerge = new Array<number>();\n        for (const parentId of line.parents) {\n          const mergedParentsOrUndefined = existingDag.mergeMap.get(parentId);\n          if (mergedParentsOrUndefined !== undefined) {\n            parentsAfterMerge.push(...mergedParentsOrUndefined);\n          } else {\n            parentsAfterMerge.push(parentId);\n          }\n        }\n        line.parents = parentsAfterMerge;\n      }\n\n      if (line.type === \"preprocessing\") {\n        // line represents the generation of a clause during preprocessing\n        assert(existingDag === null, \"no new preprocessing lines should occur while extending existing dag with new nodes from saturation\")\n        assert(!nodes.has(line.id), \"each clause must be generated by preprocessing only once\");\n        const unit = UnitParser.parsePreprocessingUnit(line.unitString);\n\n        // hack: Vampire treats a conjecture as input clause, followed by an inference, which transforms the input into a negated conjecture.\n        // we want only the negated conjecture, so we delete the (single) premise of such an inference if it occurs.\n        if (line.inferenceRule === \"negated conjecture\") {\n          assert(line.parents.length === 1);\n          // remove parent from nodes\n          const parent = nodes.get(line.parents[0]);\n          assert(parent !== undefined);\n          assert((parent as SatNode).inferenceRule === \"input\");\n          const success = nodes.delete(line.parents[0]);\n          assert(success);\n          // update parents of current line\n          line.parents = [];\n        }\n\n        currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, true, null, null, null, [], false);\n        nodes.set(currentNode.id, currentNode);\n      }\n      else if (line.type === \"new\") {\n        if (!nodes.has(line.id)) {\n          // line represents the generation of a new clause (which wasn't generated in preprocessing) during saturation\n          \n          // create new node\n          const unit = UnitParser.parseClause(line.unitString);\n          currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, false, currentTime, null, null, [], false);\n          nodes.set(currentNode.id, currentNode);\n\n          if(line.unitString === \"$false\") {\n            emptyClauseNode = currentNode;\n          }\n        } else {\n          // line represents a final clause from preprocessing, which now is added into saturation\n          assert(existingDag === null, \"no new final clauses from preprocessing should occur during the extension of an existing dag\")\n          currentNode = nodes.get(line.id) as SatNode;\n          assert(currentNode.isFromPreprocessing, \"a newly added clause can only already exist if it was generated during preprocessing\");\n          assert(line.inferenceRule === currentNode.inferenceRule, \"inference rule differs between line and existing node\");\n          const unit = UnitParser.parseClause(line.unitString);\n          currentNode.unit = unit;\n          currentNode.newTime = currentTime;\n        }\n      }\n      else if (line.type === \"active\") {\n        // line represents the addition of that clause to active\n        // an active-event gives us the following information about a clause:\n        // - the node was activated at the current time.\n        // - the number of selected literals in the clause, saved in the statistics-object (\"nSel\") of the active-event\n        // - the literals in the clause which are selected: the clause of the active-event satisfies the invariant that the selected literals occur first.\n        // - some statistics about the clause and its derivation, saved in the statistics-object of the active-event\n        assert(nodes.has(line.id), `Found clause with id ${line.id}, which was added to active, but wasn't added to new before. Maybe you forgot to output the new clauses?`);\n        currentNode = nodes.get(line.id) as SatNode;\n        assert(line.id === currentNode.id, \"id differs between line and existing node\");\n        assert(line.inferenceRule === currentNode.inferenceRule, \"inference rule differs between line and existing node\");\n        assert(line.parents.length === currentNode.parents.length, \"number of parents differs between line and existing node\");\n        for (let i = 0; i < line.parents.length; i++) {\n          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);\n        }\n        assert(currentNode.newTime !== null, \"for each event [SA] active ... there has to be an earlier event of the form [SA] new ... with the same clause!\")\n        assert(currentNode.activeTime === null, \"there must only be 1 event of the form [SA] active ... for each clause\");\n        assert(currentNode.unit.type === \"Clause\");\n        const clause = currentNode.unit as Clause;\n        assert(clause.literalsNewEvent !== null);\n\n        // note that the literals in literalsAfterActivation potentially occur in a different order than in clause,\n        // since literalsAfterActivation satisfies the invariant that the selected literals occur first.\n        const literalsAfterActivation = UnitParser.parseLiterals(line.unitString);\n\n        // mpa each literal to a literal in the existing clause\n        // for each selected literal also mark the literal in the existing clause as selected.\n        const nSel = line.statistics.get(\"nSel\");\n        assert(nSel !== undefined && nSel !== null);\n\n        const existingLiteralsActiveOrder = new Array<Literal>();\n        for (let i = 0; i < literalsAfterActivation.length; i++) {\n          const literal = literalsAfterActivation[i];\n          let foundMatch = false;\n          for (const existingLiteral of clause.literalsNewEvent!) {\n            if (literalsMatch(literal, existingLiteral, false)) {\n              existingLiteralsActiveOrder.push(existingLiteral);\n              foundMatch = true;\n              if (i < nSel) {\n                existingLiteral.isSelected = true;\n              }\n              break;\n            }\n          }\n          assert(foundMatch);\n        }\n        clause.literalsActiveEvent = existingLiteralsActiveOrder;\n\n        currentTime = currentTime + 1;\n        currentNode.activeTime = currentTime;\n        currentNode.statistics = line.statistics\n      }\n      else if (line.type === \"forward reduce\" || line.type === \"backward reduce\") {\n        // line represents the removal of a clause from saturation\n        assert(nodes.has(line.id), `Found clause with id ${line.id}, which was deleted, but wasn't added as new before. Maybe you forgot to output the new clauses?`);\n        currentNode = nodes.get(line.id) as SatNode;\n        currentNode.deletionTime = currentTime;\n      }\n      else if (line.type === \"replaced by\" || line.type === \"using\") {\n        // line represents one of the clauses which allowed to remove the clause represented by currentNode from saturation\n        assert(currentNode !== null, \"invar\");\n        (currentNode as SatNode).deletionParents.push(line.id);\n      }\n      else {\n        assert(false, `invalid line: ${line.unitString}`);\n      }\n    }\n\n    // hack: pretend that empty clause was added to passive and then activated\n    // note that this can only be done after all lines are parsed, since a new-event with the empty clause often triggers a deletion-event\n    if (emptyClauseNode !== null) {\n      currentTime = currentTime + 1;\n      emptyClauseNode.activeTime = currentTime;\n      nodes.set(emptyClauseNode.id, emptyClauseNode);\n    }\n\n    const extendedDag = new Dag(nodes, existingDag === null ? null : existingDag.mergeMap);\n\n    return extendedDag;\n  }\n\n  // note: includes nodes which have been activated, but have also been deleted\n  computeActiveNodes(currentTime: number) : Set<number> {\n    const activeNodeIds = new Set<number>();\n    for (const [nodeId, node] of this.nodes) {\n      const nodeIsActive = (node.activeTime !== null && node.activeTime <= currentTime);\n      if (nodeIsActive) {\n        activeNodeIds.add(nodeId);\n      }\n    }\n\n    return activeNodeIds;\n  }\n\n  // Definition: the active dag contains all nodes which occur in the derivation of an already activated node, and all preprocessing nodes\n  computeNodesInActiveDag(currentTime: number) : Set<number> {\n    const nodeIds = this.computeActiveNodes(currentTime);\n\n\t  // add all transitive parents of nodeIds to nodeIds\n\t  const iterator = new ReversePostOrderTraversal(this);\n\t  while (iterator.hasNext()) {\n\t\t  const currentNode = iterator.getNext();\n      const currentNodeId = currentNode.id;\n    \n      if (nodeIds.has(currentNodeId)) {\n        for (const parentId of currentNode.parents) {\n          nodeIds.add(parentId);\n        }\n      }    \n    }\n\n    // add all preprocessing nodes\n    for (const node of this.nodes.values()) {\n      if (node.isFromPreprocessing) {\n        nodeIds.add(node.id);\n      }\n    }\n    \n    return nodeIds;\n  }\n\n  isRefutation(): boolean {\n    for (const node of this.nodes.values()) {\n      if(node.unit.type === \"Clause\" && \n          (node.unit as Clause).premiseLiterals.length === 0 && \n          (node.unit as Clause).conclusionLiterals.length === 0) {\n            return true;\n          }\n    }\n    return false;\n  }\n}","import { assert } from \"./util\";\nimport { Dag, SatNodeStyle } from \"./dag\";\nimport SatNode from \"./sat-node\";\nimport { ReversePostOrderTraversal, DFPostOrderTraversal } from \"./traversal\";\n\n// returns a new dag containing only the nodes which either\n// have an id in relevantIds or\n// are transitive parents of a node with id in relevantIds\nexport function filterNonParents(dag: Dag, relevantIds: Set<number>) {\n\t// use new set to avoid mutating relevantIds\n\tconst transitiveParentIds = new Set(relevantIds);\n\n\t// need to compute remaining nodes\n\tconst remainingNodes = new Map<number, SatNode>();\n\n\t// add all transitive parents of transitive_parents to transitiveParents\n\tconst iterator = new ReversePostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst currentNode = iterator.getNext();\n\t\tconst currentNodeId = currentNode.id;\n\n\t\t// if currentNode is relevant\n\t\tif (transitiveParentIds.has(currentNodeId)) {\n\t\t\t\n\t\t\t// mark parents relevant\n\t\t\tcurrentNode.parents.forEach(parentId => transitiveParentIds.add(parentId));\n\n\t\t\t// add node to remainingNodes\n\t\t\tremainingNodes.set(currentNodeId,currentNode);\n\t\t}\n\t}\n\n\t// create deep copy of nodes\n\t// needed so that layout computation for the transformed dag does not overwrite the layout of the original dag\n\tconst remainingNodesDeepCopy = new Map<number, SatNode>();\n\tfor (const [nodeId,node] of remainingNodes) {\n\t\tremainingNodesDeepCopy.set(nodeId, node.copy());\n\t}\n\treturn new Dag(remainingNodesDeepCopy);\n}\n\n// returns a new dag containing only the nodes which either\n// have an id in relevant_ids or\n// are transitive children of a node with id in relevant_ids.\n// additionally keeps boundary nodes\nexport function filterNonConsequences(dag: Dag, relevantIds: Set<number>) {\n\t// use new set to avoid mutating relevantIds\n\tconst transitiveChildrenIds = new Set<number>(relevantIds);\n\n\t// need to compute remaining nodes\n\tconst remainingNodes = new Map<number, SatNode>();\n\n\t// add all transitive children of ids in transitiveChildren to transitiveChildren\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tlet currentNode = iterator.getNext();\n\n\t\t// check if currentNode occurs in transitiveChildren or\n\t\t// has a parent which occurs in transitiveChildren\n\t\tlet existsRelevantParent = false;\n\t\tfor (const parentId of currentNode.parents) {\n\t\t\tif (transitiveChildrenIds.has(parentId)) {\n\t\t\t\texistsRelevantParent = true;\n\t\t\t}\n\t\t}\n\t\tconst isRelevant = transitiveChildrenIds.has(currentNode.id) || existsRelevantParent;\n\n\t\tif (isRelevant) {\n\t\t\t// add its id to the set of relevant ids\n\t\t\ttransitiveChildrenIds.add(currentNode.id);\n\n\t\t\t// if there exists at least one relevant parent, \n\t\t\tif (existsRelevantParent) {\n\t\t\t\t// introduce a boundary nodes for all nonrelevant parents\n\t\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\t\tif (!transitiveChildrenIds.has(parentId)) {\n\t\t\t\t\t\tconst boundaryNode = createBoundaryNode(dag.get(parentId));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// boundaryNode has currentNode as child and is therefore no leaf\n\t\t\t\t\t\tassert(!dag.leaves.has(boundaryNode.id), \"invar violated. Boundary nodes should only occur as parents of nodes\");\n\t\t\t\t\t\tremainingNodes.set(boundaryNode.id, boundaryNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// otherwise ignore all parents: introduce a copy of the node which has no parents\n\t\t\t\tcurrentNode = createBoundaryNode(currentNode);\n\t\t\t}\n\n\t\t\t// add currentNode to remainingNodes\n\t\t\tremainingNodes.set(currentNode.id, currentNode);\n\t\t} \n\t}\n\n\t// create deep copy of nodes\n\t// needed so that layout computation for the transformed dag does not overwrite the layout of the original dag\n\tconst remainingNodesDeepCopy = new Map<number, SatNode>();\n\tfor (const [nodeId,node] of remainingNodes) {\n\t\tremainingNodesDeepCopy.set(nodeId, node.copy());\n\t}\n\treturn new Dag(remainingNodesDeepCopy);\n}\n\nfunction createBoundaryNode(node: SatNode): SatNode {\n\treturn new SatNode(node.id, node.unit, node.inferenceRule, [], node.statistics, node.isFromPreprocessing, node.newTime, node.activeTime, node.deletionTime, node.deletionParents, node.isBoundary);\n}\n\n// vampire performs preprocessing in multiple steps\n// we are only interested in\n// 1) the input-formulas (and axioms added by Vampire)\n// 2) the clauses resulting from them\n// We therefore merge together all preprocessing steps into single steps\n// from input-formulas/vapire-added-axioms to final-preprocessing-clauses\n// additionally remove all choice axiom parents, since we treat them as part of the background theory\nexport function mergePreprocessing(dag: Dag): Dag {\n\tconst nodes = new Map<number, SatNode>(dag.nodes);\n\tconst nodeIdsToRemove = new Set<number>(); // nodes which should be removed. note that we can't remove them upfront due to the fact that the derivation is a dag and not a tree\n\tconst mergeMap = new Map<number, Array<number>>(); // maps merged nodes to the replacing nodes, needed for extending the dag later\n\n\tconst postOrderTraversal = new DFPostOrderTraversal(dag);\n\twhile (postOrderTraversal.hasNext()) {\n\t\t// note: the ids are still valid, but the nodes may have been replaced by new node\n\t\tconst currentNodeId = postOrderTraversal.getNext().id;\n\t\tconst currentNode = nodes.get(currentNodeId) as SatNode;\n\n\t\t// if there is a preprocessing node n1 with a parent node n2 which has itself a parent node n3,\n\t\t// then replace n2 by n3 in the parents of n1 and add n2 to the nodes which should be removed\n\t\tif (currentNode.isFromPreprocessing) {\n\t\t\tconst updatedParents = new Array<number>();\n\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\tconst parentNode = nodes.get(parentId) as SatNode;\n\t\t\t\tassert(parentNode.isFromPreprocessing, \"invariant violated\");\n\n\t\t\t\tif (parentNode.parents.length === 0) {\n\t\t\t\t\t// small optimization: remove choice axioms, which should not been added to the proof by Vampire in the first place\n\t\t\t\t\tif (parentNode.inferenceRule === \"choice axiom\") {\n\t\t\t\t\t\tnodeIdsToRemove.add(parentId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdatedParents.push(parentId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (const parent2Id of parentNode.parents) {\n\t\t\t\t\t\tconst parent2Node = nodes.get(parent2Id) as SatNode;\n\t\t\t\t\t\tassert(parent2Node.isFromPreprocessing, \"invariant violated\");\n\t\t\t\t\t\tupdatedParents.push(parent2Id);\n\t\t\t\t\t}\n\t\t\t\t\tnodeIdsToRemove.add(parentId);\n\t\t\t\t\tmergeMap.set(parentId, parentNode.parents);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst updatedNode = new SatNode(currentNode.id, currentNode.unit, currentNode.inferenceRule, updatedParents, currentNode.statistics, currentNode.isFromPreprocessing, currentNode.newTime, currentNode.activeTime, currentNode.deletionTime, currentNode.deletionParents, currentNode.isBoundary);\n\t\t\tnodes.set(currentNodeId, updatedNode);\n\t\t}\n\t}\n\n\t// remove merged nodes\n\tfor (const nodeIdToRemove of nodeIdsToRemove) {\n\t\tconst success = nodes.delete(nodeIdToRemove);\n\t\tassert(success, \"invar violated\");\n\t}\n\n\treturn new Dag(nodes, mergeMap);\n}\n\n// preconditions:\n// - selectionIds contains only ids from nodes which either 1) have already been activated or 2) are final preprocessing clauses\n// - selectionIds must contain at least one element\nexport function passiveDagForSelection(dag: Dag, selectionIds: Array<number>, currentTime: number): Dag {\n\tassert(selectionIds.length > 0);\n\tconst selectionIdsSet = new Set(selectionIds);\n\n\t// Part 1: for each passive node n, we consider the transitive parents p_1,...p_k occuring in the activeDag, \n\t// such that for each parent p_i no other node inbetween n and p_i occurs in the activeDag. If selectionId \n\t// is a subset of {p_1,...,p_k}, then n is added to foundNodes\n\tconst foundNodes = new Set<number>();\n\n\tconst idToActiveDagParents = new Map<number, Set<number>>();\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst node = iterator.getNext();\n\t\tconst nodeId = node.id;\n\n\t\tconst activeDagParents = new Set<number>();\n\n\t\tconst nodeIsInActiveDag = ((node.activeTime !== null && node.activeTime <= currentTime) || node.isFromPreprocessing);\n\t\tif(nodeIsInActiveDag) {\n\t\t\tif (selectionIdsSet.has(nodeId)) {\n\t\t\t\tactiveDagParents.add(nodeId);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const parentId of node.parents) {\n\t\t\t\tconst activeDagParentsParent = idToActiveDagParents.get(parentId);\n\t\t\t\tassert(activeDagParentsParent !== undefined);\n\t\t\t\tfor (const activeDagParent of activeDagParentsParent!) {\n\t\t\t\t\tactiveDagParents.add(activeDagParent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if node is passive and each clause from selection occurs in activeDagParents, then add node to foundNodes\n\t\t\tconst nodeIsInPassive = ((node.newTime !== null && node.newTime <= currentTime) && !(node.activeTime !== null && node.activeTime <= currentTime) && !(node.deletionTime !== null && node.deletionTime <= currentTime));\n\t\t\tif (nodeIsInPassive) {\n\t\t\t\tif (activeDagParents.size === selectionIdsSet.size) {\n\t\t\t\t\tfoundNodes.add(nodeId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tidToActiveDagParents.set(nodeId, activeDagParents);\n\t}\n\t\n\t// Part 2:\n\t// we now know the set of passive nodes, so\n\t// - collect all nodes participating in the derivation of the passive nodes from nodes in the current activeDag\n\t// - compute for each such node its style\n\tconst passiveDagNodes = new Map<number, SatNode>();\n\tconst nodePartition = new Map<number, SatNodeStyle>();\n\n\tconst relevantNodes = new Set<number>(foundNodes);\n\n\t// additionally display each node from selection, even if no passive node is generated by the node\n\tfor (const nodeId of selectionIds) {\n\t\trelevantNodes.add(nodeId);\n\t}\n\n\tconst iterator2 = new ReversePostOrderTraversal(dag);\n\twhile (iterator2.hasNext()) {\n\t\tconst node = iterator2.getNext();\n\t\tconst nodeId = node.id;\n\n\t\tif (relevantNodes.has(nodeId)) {\n\t\t\tconst isDeleted = (node.deletionTime !== null && node.deletionTime <= currentTime);\n\n\t\t\t// compute whether the derivation should be extended with the parents of the node, and compute the style of the node\n\t\t\tlet isBoundary;\n\t\t\tlet style;\n\t\t\tif (foundNodes.has(nodeId)) {\n\t\t\t\tassert(!isDeleted);\n\t\t\t\tif (node.isFromPreprocessing) {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = \"passive\";\n\t\t\t\t} else {\n\t\t\t\t\tisBoundary = false;\n\t\t\t\t\tstyle = \"passive\";\n\t\t\t\t}\n\t\t\t} else if (dag.nodeIsTheoryAxiom(nodeId)) {\n\t\t\t\tisBoundary = true;\n\t\t\t\tstyle = isDeleted ? \"theory-axiom-deleted\" : \"theory-axiom\";\n\t\t\t} else if (node.isFromPreprocessing) {\n\t\t\t\tif (node.inferenceRule === \"negated conjecture\") {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = \"conjecture\";\n\t\t\t\t} else {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = isDeleted ? \"preprocessing-deleted\" : \"preprocessing\";\n\t\t\t\t}\n\t\t\t} else if (node.activeTime !== null && node.activeTime <= currentTime) {\n\t\t\t\tisBoundary = true;\n\t\t\t\tstyle = isDeleted ? \"activated-deleted\" : \"activated\";\n\t\t\t} else {\n\t\t\t\tisBoundary = false;\n\t\t\t\tstyle = \"deleted\";\n\t\t\t}\n\n\t\t\tif (isBoundary) {\n\t\t\t\tpassiveDagNodes.set(nodeId, createBoundaryNode(node));\n\t\t\t} else {\n\t\t\t\tpassiveDagNodes.set(nodeId, node.copy()); // copy node so that positioning passiveDag will not change positioning of original dag\n\t\t\t\tfor (const parent of node.parents) {\n\t\t\t\t\trelevantNodes.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodePartition.set(nodeId, style);\n\t\t}\n\t}\n\n\tconst passiveDag = new Dag(passiveDagNodes, null, true, nodePartition, selectionIds[0]);\n\treturn passiveDag;\n}","import Viz from 'viz.js';\nimport {Module, render} from 'viz.js/full.render.js';\n\nexport async function runViz(dotString) {\n\tlet viz = new Viz({Module, render});\n\n\treturn viz\n\t\t.renderString(dotString, {format: 'plain'})\n\t\t.then((result) => {\n\t\treturn result;\n\t\t})\n\t\t.catch((error) => {\n\t\tviz = new Viz({Module, render});\n\t\tconsole.error(error);\n\t\t});\n};","import { assert } from '../model/util';\nimport { Dag } from '../model/dag';\nimport { runViz } from './callViz';\nimport SatNode from './sat-node';\n\nconst PLAIN_PATTERN = /^(\\d+) ([0-9.]+) ([0-9.]+).*$/g;\n\nexport class VizWrapper {\n\n  // first computes the positions for the nodes while ignoring the position given as parameter.\n  // then, all node positions are shifted by the same amount so that one of the nodes \n  // occurs closely under the position given as parameter\n  static async layoutNodesAtPosition(nodes: Map<number, SatNode>, position: [number, number]) {\n    // 1) layout new nodes while ignoring existing nodes\n    await VizWrapper.layoutNodes(nodes);\n\n    // 2) find a source node of the dag of newly generated nodes\n    let sourceNode: SatNode | null = null;\n    for (const node of nodes.values()) {\n      let isSourceNode = true;\n      for (const parentId of node.parents) {\n        if (nodes.has(parentId)) {\n          isSourceNode = false;\n          break;\n        }\n      }\n      if (isSourceNode) {\n        sourceNode = node;\n        break;\n      }\n    }\n    assert(sourceNode !== null);\n    assert((sourceNode as SatNode).position !== null);\n\n    // 3) shift subgraph of newly generated nodes, so that the source node of the subgraph\n    //    is shifted to a position closely under the position indicated by the positioning hint.\n    const [posSelectedX, posSelectedY] = position;\n    const [posSourceX, posSourceY] = (sourceNode as SatNode).position as [number, number];\n    const deltaX = posSelectedX-posSourceX;\n    const deltaY = (posSelectedY - posSourceY) - 1;\n    for (const node of nodes.values()) {\n      assert(node.position != null);\n      const position = node.position as [number, number];\n      node.position = [position[0] + deltaX, position[1] + deltaY];\n    }\n  }\n\n  static async layoutDag(dag: Dag, onlyActiveDag: boolean) {\n    // generate dot string\n    const dotString = VizWrapper.dagToDotString(dag, onlyActiveDag);\n    \n    // use viz to compute layout for dag given as dotstring\n    // note that viz returns the layout as a string\n    const layoutString = await runViz(dotString);\n\n    // parse the layout string into array of network-nodes\n    VizWrapper.parseLayoutString(layoutString, dag.nodes);\n  };\n\n  static async layoutNodes(nodes: Map<number, SatNode>) {\n    // generate dot string\n    const dotString = VizWrapper.nodesToDotString(nodes);\n\n    // use viz to compute layout for nodes given as dotstring\n    // note that viz returns the layout as a string\n    const layoutString = await runViz(dotString);\n\n    // parse the layout string into array of network-nodes\n    VizWrapper.parseLayoutString(layoutString, nodes);\n  }\n\n  // encodes layout-problem into dot-language\n  // the solution to the layout-problem contains a position for each node, which either\n  // - is a preprocessing node\n  // - occurs in the derivation of at least one activated clause\n  static dagToDotString(dag: Dag, onlyActiveDag: boolean): string {\n    const nodesInActiveDag = onlyActiveDag ? dag.computeNodesInActiveDag(Number.MAX_SAFE_INTEGER) : null;\n\n    const inputStrings = new Array<string>();\n    const preprocessingStrings = new Array<string>();\n    const otherStrings = new Array<string>();    \n    for (const node of dag.nodes.values()) {\n      assert(node.position === null, \"the dag has already been layouted!\");\n      if (node.isFromPreprocessing) {\n        if(dag.nodeIsInputNode(node.id)) {\n          inputStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        } else {\n          preprocessingStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        }\n      } else  {\n        if (!onlyActiveDag || (nodesInActiveDag as Set<number>).has(node.id)) {\n          otherStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        }\n      }\n    }\n\n    const edgeStrings = new Array<string>();\n    for (const node of dag.nodes.values()) {\n      if (!onlyActiveDag || (nodesInActiveDag as Set<number>).has(node.id)) {\n        for (const parentId of node.parents) {\n          edgeStrings.push(`${parentId} -> ${node.id}`)\n        }\n      }\n    }\n\n    const inputString = \"   subgraph inputgraph {\\n      rank=source;\\n      \" + inputStrings.join(\";\\n      \") + \"\\n   }\";\n    const preprocessingString = \"   subgraph preprocessinggraph {\\n      rank=same;\\n      \" + preprocessingStrings.join(\";\\n      \") + \"\\n   }\";\n    const otherstring = \"   subgraph othergraph {\\n      \" + otherStrings.join(\";\\n      \") + \"\\n   }\";\n    const edgeString = edgeStrings.join(\";\\n   \");\n\n    const dotString =  \"digraph {\\n\\n\" + inputString + \"\\n\\n\" + preprocessingString + \"\\n\\n\" + otherstring + \"\\n\\n   \" + edgeString + \"\\n}\";\n    \n    return dotString;\n  };\n\n  static nodesToDotString(nodes: Map<number, SatNode>): string {\n    const nodeStrings = new Array<string>();\n    for (const node of nodes.values()) {\n      assert(node.position === null, \"the node has already been layouted!\");\n      nodeStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n    }\n\n    const edgeStrings = new Array<string>();\n    for (const node of nodes.values()) {\n      for (const parentId of node.parents) {\n        if (nodes.has(parentId)) {\n          edgeStrings.push(`${parentId} -> ${node.id}`)\n        }\n      }\n    }\n\n    const dotString =  \"digraph {\\n   \" + nodeStrings.join(\";\\n   \") + \"\\n\\n   \" + edgeStrings.join(\";\\n   \") + \"\\n}\";\n    return dotString;\n  };\n\n  static parseLayoutString(layoutString: string, nodes: Map<number, SatNode>) {\n    let firstEdgeLineIndex = layoutString.includes('\\nedge') ? layoutString.indexOf('\\nedge') : layoutString.length;\n    // split layoutString to array of strings describing positions of nodes\n    const parsedNodeLines = layoutString\n      .substr(0, firstEdgeLineIndex) // ignore remaining part of string describing edges\n      .split('\\nnode ') //split lines\n      .slice(1) // ignore first line describing graph\n      .map(line => line.substr(0, line.indexOf('\"'))) // ignore remaining part of line causing problems with line breaks\n      .map((line) => line.matchAll(PLAIN_PATTERN).next().value); // parse each remaining line\n    parsedNodeLines.forEach(line => {\n      assert(line !== undefined); // check that each remaining line was successfully parsed\n\t  });\n\t\n    // update SatNode for each nodeString\n    for (const parsedNodeLine of parsedNodeLines) {\n      const [, idString, xString, yString] = parsedNodeLine;\n      const id = parseInt(idString, 10);\n      const x = parseFloat(xString);\n      const y = parseFloat(yString);\n      const node = nodes.get(id) as SatNode;\n      node.position = [x,y];\n    }\n  }\n}","import * as React from 'react';\nimport ReactModal from 'react-modal';\n\nimport Graph from './Graph'\nimport { Dag } from '../model/dag';\nimport { assert } from '../model/util';\nimport { PassiveDagAside } from './PassiveDagAside';\nimport { Literal } from '../model/literal';\n\nimport { passiveDagForSelection } from '../model/transformations';\nimport { VizWrapper } from '../model/viz-wrapper';\n\nReactModal.setAppElement('#root');\n\ntype Props = {\n\tdag: Dag,\n\tnodeSelection: number[],\n  currentTime: number,\n\t\n\tchangedNodesEvent?: Set<number>,\n  infoToggle: boolean,\n  editToggle: boolean,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void\n\n\tonDismissPassiveDag: (selectedId: number | null, positioningHint: [number, number] | null) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\ntype State = {\n\tpassiveDag: Dag | null;\n  nodeSelectionPassiveDag: number[],\n}\n\nexport class PassiveDagModal extends React.Component<Props, State> {\n\t\n\tstate: State = {\n\t\tpassiveDag: null,\n\t\tnodeSelectionPassiveDag: []\n  }\n\n  async componentDidMount() {\n    const passiveDag = await this.generatePassiveDag();\n    this.setState({\n      passiveDag: passiveDag\n    });\n  }\n\n  async componentDidUpdate(previousProps) {\n\t\tif (this.props.dag !== previousProps.dag || this.props.nodeSelection !== previousProps.nodeSelection || this.props.currentTime !== previousProps.currentTime) {\n\t\t\tconst passiveDag = await this.generatePassiveDag();\n\t\t\tthis.setState({\n\t\t\t\tpassiveDag: passiveDag\n\t\t\t});\n\t\t}\n  }\n\n\trender() {\n\t\tif (this.state.passiveDag === null) {\n\t\t\treturn (\n\t\t\t\t<section>Layouting...</section>\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\t<ReactModal\n\t\t\t\tisOpen={true}\n\t\t\t\tcontentLabel={`Clauses currently in Passive generated by clause with id ${this.state.passiveDag!.activeNodeId!}`}\n\t\t\t\tonRequestClose={() => {\n\t\t\t\t\tthis.props.onDismissPassiveDag(null, null);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<Graph\n\t\t\t\t\tdag={this.state.passiveDag!}\n\t\t\t\t\tnodeSelection={this.state.nodeSelectionPassiveDag}\n\t\t\t\t\tchangedNodesEvent={this.props.changedNodesEvent}\n\t\t\t\t\tcurrentTime={this.props.currentTime}\n\t\t\t\t\tanimateDagChanges={false}\n\t\t\t\t\tonNodeSelectionChange={this.nodeSelectionChange.bind(this)}\n\t\t\t\t\tonUpdateNodePositions={this.updateNodePositions.bind(this)}\n\t\t\t\t/>\n\t\t\t\t<PassiveDagAside\n\t\t\t\t\tdag={this.state.passiveDag!}\n\t\t\t\t\tcurrentTime={this.props.currentTime}\n\t\t\t\t\tnodeSelection={this.state.nodeSelectionPassiveDag}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n\t\t\t\t\tonUpdateNodeSelection={this.nodeSelectionChange.bind(this)}\n\t\t\t\t\tonLiteralOrientationChange={this.props.onLiteralOrientationChange}\n\t\t\t\t\tonLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n\t\t\t\t\tonSelectButtonPressed={this.selectButtonPressed.bind(this)}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n\t\t\t\t/>\n\t\t\t</ReactModal>\n\t\t)\n\t}\t\n\n\tnodeSelectionChange(selection: number[]) {\n\t\tthis.setState({nodeSelectionPassiveDag: selection});\n\t}\n\n\tupdateNodePositions(nodeIds: number[], delta: [number, number]) {\n\t\tassert(this.state.passiveDag !== null);\n    for (const nodeId of nodeIds) {\n      const node = this.state.passiveDag!.get(nodeId);\n      assert(node.position !== null);\n      node.position = [node.position![0] + delta[0], node.position![1] + delta[1]];\n    }\n\t}\n\n\tasync generatePassiveDag() {\n\t\t// generate passive dag\n\t\tconst passiveDag = passiveDagForSelection(this.props.dag, this.props.nodeSelection, this.props.currentTime);\n\n\t\t// layout node positions of passive dag\n\t\tawait VizWrapper.layoutDag(passiveDag, false);\n\n\t\t// shift dag so that selected node occurs at same screen position as in currentDag\n\t\tconst [posCurrentX, posCurrentY] = this.props.dag.get(this.props.nodeSelection[0]).getPosition();\n\t\tconst [posPassiveX, posPassiveY] = passiveDag.get(this.props.nodeSelection[0]).getPosition();\n\t\tconst deltaX = posCurrentX-posPassiveX;\n\t\tconst deltaY = posCurrentY-posPassiveY;\n\t\tfor (const node of passiveDag.nodes.values()) {\n\t\t\tassert(node.position != null);\n\t\t\tconst position = node.position as [number, number];\n\t\t\tnode.position = [position[0] + deltaX, position[1] + deltaY];\n\t\t}\n\n\t\treturn passiveDag;\n\t}\n\n\tselectButtonPressed() {\n\t\tconst passiveDag = this.state.passiveDag;\n\t\tassert(passiveDag !== null);\n\t\tassert(passiveDag!.isPassiveDag);\n\t\tassert(passiveDag!.activeNodeId !== null);\n\t\t\n\t\tassert(this.state.nodeSelectionPassiveDag.length === 1);\n\t\tconst selectedId = this.state.nodeSelectionPassiveDag[0];\n\t\tassert(selectedId !== null);\n\n\t\tconst styleMap = passiveDag!.styleMap!\n\t\tassert(styleMap !== null);\n    assert(styleMap.get(selectedId) === \"passive\");\n\t\t\n\t\t// compute positioning hint\n\t\tconst positioningHint = this.props.dag.get(this.state.passiveDag!.activeNodeId as number).position;\n\t\tassert(positioningHint !== null);\n\n\t\tthis.props.onDismissPassiveDag(selectedId, positioningHint!);\n\t}\n\n}\n","import * as React from 'react';\n\nimport {Dag} from '../model/dag';\nimport {Literal} from '../model/literal'\nimport Slider from './Slider';\nimport Graph from './Graph';\nimport {PassiveDagModal} from './PassiveDagModal';\n\n\ntype Props = {\n  dag: Dag,\n  showPassiveDag: boolean,\n  nodeSelection: number[],\n  changedNodesEvent?: Set<number>,\n  historyLength: number,\n  currentTime: number,\n  animateDagChanges: boolean,\n  infoToggle: boolean,\n  editToggle: boolean,\n  readOnly: boolean,\n  onNodeSelectionChange: (selection: number[]) => void,\n  onCurrentTimeChange: (newState: number) => void,\n  onDismissPassiveDag: (selectedId: number | null, positioningHint: [number, number] | null) => void,\n  onUpdateNodePositions: (nodeIds: Array<number>, delta: [number, number]) => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\nexport default class Main extends React.Component<Props, {}> {\n\n  render() {\n    let modal;\n    if (this.props.showPassiveDag) {\n      modal = \n        <PassiveDagModal\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          currentTime={this.props.currentTime}\n          changedNodesEvent={this.props.changedNodesEvent}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n          onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n          onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n          onDismissPassiveDag={this.props.onDismissPassiveDag}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n        />\n    }\n\n    const slider = this.props.readOnly ? (\n      <section className=\"slider-placeholder\"/>\n    ) : (\n      <Slider\n        historyLength={this.props.historyLength}\n        currentTime={this.props.currentTime}\n        onCurrentTimeChange={this.props.onCurrentTimeChange}\n      />\n    );\n\n    return (\n      <main>\n        <Graph\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          changedNodesEvent={this.props.changedNodesEvent}\n          currentTime={this.props.currentTime}\n          animateDagChanges={this.props.animateDagChanges}\n          onNodeSelectionChange={this.props.onNodeSelectionChange}\n          onUpdateNodePositions={this.props.onUpdateNodePositions}\n        />\n        {modal}\n        {slider}\n      </main>\n    );\n  }\n}\n","import * as React from 'react';\n\nimport './GraphMenu.css';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  undoEnabled: boolean,\n  filterUpEnabled: boolean,\n  filterDownEnabled: boolean,\n  passiveDagButtonEnabled: boolean,\n  onUndo: () => void,\n  onRenderParentsOnly: () => void,\n  onRenderChildrenOnly: () => void,\n  onShowPassiveDag: () => void\n};\n\nexport default class GraphMenu extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <div className=\"component-graph-menu\">\n        <section className=\"component-graph-menu-content\">\n          <button title=\"Undo last graph transformation\" disabled={!this.props.undoEnabled} onClick={this.props.onUndo}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-undo`}/>\n            </svg>\n          </button>\n\n          <button title=\"Render selection only (up)\" disabled={!this.props.filterUpEnabled}\n                  onClick={this.props.onRenderParentsOnly}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-up`}/>\n            </svg>\n          </button>\n\n          <button title=\"Render selection only (down)\" disabled={!this.props.filterDownEnabled}\n                  onClick={this.props.onRenderChildrenOnly}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-down`}/>\n            </svg>\n          </button>\n\n          <button title=\"Select clauses\"\n                  disabled={!this.props.passiveDagButtonEnabled}\n                  onClick={() => {\n                    this.props.onShowPassiveDag();\n                  }}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-s`}/>\n            </svg>\n          </button>\n        </section>\n      </div>\n    );\n  }\n}\n","import * as React from 'react';\n\nimport './NodeMenu.css';\n\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  nodeSelection: number[],\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void\n};\nexport default class NodeMenu extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-node-menu\">\n\n        <button\n          title=\"Select parents of selected nodes\"\n          disabled={!this.props.nodeSelection.length}\n          onClick={this.props.onSelectParents}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-parents`}/>\n          </svg>\n        </button>\n\n        <button\n          title=\"Select children of selected nodes\"\n          disabled={!this.props.nodeSelection.length}\n          onClick={this.props.onSelectChildren}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-children`}/>\n          </svg>\n        </button>\n\n        <button\n          title=\"Find common consequences of selected nodes\"\n          disabled={this.props.nodeSelection.length < 2}\n          onClick={this.props.onSelectCommonConsequences}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-consequences`}/>\n          </svg>\n        </button>\n\n      </section>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport './Search.css';\nimport SatNode from '../model/sat-node';\nimport { assert } from '../model/util';\nimport { Clause } from '../model/unit';\n\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  onUpdateNodeSelection: (selection: number[]) => void\n};\ntype State = {\n  foundNodes: Array<SatNode>\n};\n\nexport default class Search extends React.Component<Props, State> {\n\n  state = {\n    foundNodes: []\n  };\n  private searchField1 = React.createRef<HTMLInputElement>();\n  private searchField2 = React.createRef<HTMLInputElement>();\n  private searchField3 = React.createRef<HTMLInputElement>();\n\n  componentDidUpdate(prevProps) {\n    if (this.props.dag !== prevProps.dag || this.props.currentTime !== prevProps.currentTime) {\n      this.searchField1.current!.value = \"\";\n      this.searchField2.current!.value = \"\";\n      this.searchField3.current!.value = \"\";\n\n      this.setState({foundNodes: []});\n    }\n  }\n\n  render() {\n    const {foundNodes} = this.state;\n\n    return (\n      <section className=\"component-search\">\n        <input\n          type=\"text\"\n          ref={this.searchField1}\n          placeholder=\"Search for nodes including literal\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <input\n          type=\"text\"\n          ref={this.searchField2}\n          placeholder=\"Search for nodes excluding literals\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <input\n          type=\"text\"\n          ref={this.searchField3}\n          placeholder=\"Search for nodes using inference rule\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <ul id=\"searchResults\">\n          {\n            foundNodes.slice(0, 21).map(node => this.toListItem(node))\n          }\n          {\n            foundNodes.length > 20 && this.getDisabledListItem()\n          }\n        </ul>\n      </section>\n    );\n  }\n\n\n  // SEARCH ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  search() {\n    assert(this.props.dag !== null);\n\n    assert(this.searchField1.current!);\n    assert(this.searchField2.current!);\n    assert(this.searchField3.current!);\n    const searchString1 = this.searchField1.current!.value;\n    const searchString2 = this.searchField2.current!.value;\n    const searchString3 = this.searchField3.current!.value;\n\n    // only perform search if at least one search string is non-empty\n    if (searchString1 === \"\" && searchString2 === \"\" && searchString3 === \"\") {\n      this.props.onUpdateNodeSelection([]);\n      this.setState({\n        foundNodes: []\n      });\n      return;\n    }\n\n    let candidates = Array.from(this.props.dag!.nodes.values());\n\n    // find all clauses which contain a literal which matches the first search string\n    if (searchString1 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        if (node.unit.type === \"Clause\") {\n          const clause = node.unit as Clause;\n        \n          let foundLiteral = false;\n          for (const literal of clause.premiseLiterals) {\n            if(literal.toString(true).includes(searchString1)) {\n              foundLiteral = true;\n              break;\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.conclusionLiterals) {\n              if(literal.toString(false).includes(searchString1)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.contextLiterals) {\n              if(literal.toString(false).includes(searchString1)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if(foundLiteral) {\n            foundNodes.push(node);\n          }\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    // find all clauses which don't contain a literal which matches the second search string\n    if (searchString2 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        if (node.unit.type === \"Clause\") {\n          const clause = node.unit as Clause;\n        \n          let foundLiteral = false;\n          for (const literal of clause.premiseLiterals) {\n            if(literal.toString(true).includes(searchString2)) {\n              foundLiteral = true;\n              break;\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.conclusionLiterals) {\n              if(literal.toString(false).includes(searchString2)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.contextLiterals) {\n              if(literal.toString(false).includes(searchString2)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n\n          if(!foundLiteral) {\n            foundNodes.push(node);\n          }\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    // find all clauses which have been derived using an inference rule which matches the third search string\n    if (searchString3 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        // note: using an exact check here instead of includes check\n        // e.g. so that \"resolution\" does not match \"subsumption resolution\"\n        if (node.inferenceRule === searchString3) {\n          foundNodes.push(node);\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    const nodesInActiveDag = this.props.dag!.computeNodesInActiveDag(this.props.currentTime);\n    const foundNodes = new Array<SatNode>();\n    for (const node of candidates) {\n      if (nodesInActiveDag.has(node.id)) {\n        foundNodes.push(node);\n      }\n    }\n    candidates = foundNodes;\n\n    // order found clauses by length\n    candidates.sort((node1: SatNode, node2: SatNode) => {\n      const clause1 = node1.unit as Clause;\n      const clause2 = node2.unit as Clause;\n      return clause1.toString().length - clause2.toString().length\n    });\n\n    // select all found clauses\n    this.props.onUpdateNodeSelection(candidates.map(node => node.id));\n  \n    // present search results\n    this.setState({\n      foundNodes: candidates\n    });\n  }\n\n  toListItem = (node: SatNode) => {\n    return <li key={node.id} onClick={() => this.props.onUpdateNodeSelection([node.id])}>{node.toString()}</li>;\n  };\n\n  getDisabledListItem = () => {\n    return <li className=\"disabled-element\">...</li>;\n  };\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport NodeMenu from './NodeMenu';\nimport Search from './Search';\nimport './NodeCard.css';\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  nodeSelection: number[],\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void\n};\nexport default class NodeCard extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-node-card\">\n        <article>\n          <h2>Select Nodes</h2>\n          <NodeMenu\n            nodeSelection={this.props.nodeSelection}\n            onSelectParents={this.props.onSelectParents}\n            onSelectChildren={this.props.onSelectChildren}\n            onSelectCommonConsequences={this.props.onSelectCommonConsequences}\n          />\n          <Search\n            dag={this.props.dag}\n            currentTime={this.props.currentTime}\n            onUpdateNodeSelection={this.props.onUpdateNodeSelection}\n          />\n        </article>\n      </section>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport GraphMenu from './GraphMenu';\nimport NodeCard from './NodeCard';\nimport {Dag} from '../model/dag';\nimport {Literal} from '../model/literal';\nimport {assert} from '../model/util';\nimport {NodeDetailsWrapper} from './NodeDetailsWrapper';\n\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  nodeSelection: number[],\n  multipleVersions: boolean,\n  infoToggle: boolean,\n  editToggle: boolean,\n  readOnly: boolean,\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onUndo: () => void,\n  onRenderParentsOnly: () => void,\n  onRenderChildrenOnly: () => void,\n  onShowPassiveDag: () => void,\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: ['premise' | 'conclusion' | 'context', number], newPosition: ['premise' | 'conclusion' | 'context', number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\nexport default class Aside extends React.Component<Props, {}> {\n\n  render() {\n    if (this.props.dag === null) {\n      assert(this.props.nodeSelection.length === 0);\n      assert(!this.props.multipleVersions);\n    }\n\n    const graphMenuEnabled = !this.props.readOnly && this.props.dag !== null;\n    const undoEnabled = graphMenuEnabled && this.props.multipleVersions;\n    const filtersEnabled = graphMenuEnabled && this.props.nodeSelection.length > 0 && !this.props.dag!.isPassiveDag;\n    const passiveDagButtonEnabled = graphMenuEnabled && this.props.nodeSelection.length > 0;\n\n    return (\n      <div className=\"scroll\">\n        <aside>\n          <GraphMenu\n            undoEnabled={undoEnabled}\n            filterUpEnabled={filtersEnabled}\n            filterDownEnabled={filtersEnabled}\n            passiveDagButtonEnabled={passiveDagButtonEnabled}\n            onUndo={this.props.onUndo}\n            onRenderParentsOnly={this.props.onRenderParentsOnly}\n            onRenderChildrenOnly={this.props.onRenderChildrenOnly}\n            onShowPassiveDag={this.props.onShowPassiveDag}\n          />\n          <NodeCard\n            dag={this.props.dag}\n            currentTime={this.props.currentTime}\n            nodeSelection={this.props.nodeSelection}\n            onUpdateNodeSelection={this.props.onUpdateNodeSelection}\n            onSelectParents={this.props.onSelectParents}\n            onSelectChildren={this.props.onSelectChildren}\n            onSelectCommonConsequences={this.props.onSelectCommonConsequences}\n          />\n          <NodeDetailsWrapper\n            dag={this.props.dag}\n            nodeSelection={this.props.nodeSelection}\n            currentTime={this.props.currentTime}\n            infoToggle={this.props.infoToggle}\n            editToggle={this.props.editToggle}\n            onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n            onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n            onToggleInfo={this.props.onToggleInfo}\n            onToggleEdit={this.props.onToggleEdit}\n          />\n        </aside>\n      </div>\n    );\n  }\n\n}\n","import { Dag } from \"./dag\";\nimport { Clause } from \"./unit\";\nimport { Literal } from \"./literal\";\nimport { assert } from \"./util\";\nimport { literalsMatch } from \"./substitution\";\nimport { DFPostOrderTraversal } from \"./traversal\";\n\n// inferences, where\n// 1) clause and parent clause have same number of literals\n// 2) rewritten literals occur in the same position as the corresponding literal in the parent clause\nfunction computeParentLiteralsCase1(literals: Array<Literal>, parentLiterals: Array<Literal>) {\n\tassert(literals.length === parentLiterals.length);\n\n\tfor (let i = 0; i < literals.length; i++) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i];\n\t\t\n\t\tliteral.setLiteralInParent(parentLiteral);\n\t}\n}\n\n// inferences which remove exactly one literal, where the order of the remaining literals is not changed\n// need to find the position where the literals were removed\n// note: this may compute a wrong matching if a literal in the side-part of the clause matches a deleted literal\n//       in this case the wrongly matched literals in the parent are pairwise unifiable, so a sane user would assign to all of them the same orientation.\n//       in particular the wrong matching should not affect the orientation-heuristic in practice\nfunction computeParentLiteralsCase2(literals: Array<Literal>, parentLiterals: Array<Literal>, allowSubstitutions: boolean, allowMultipleRemovals: boolean) {\n\tassert(allowMultipleRemovals ? (literals.length < parentLiterals.length) : (literals.length + 1 === parentLiterals.length));\n\n\tlet foundRemovedLit = false;\n\tlet i = 0;\n\tlet j = 0;\n\twhile (i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[j];\n\n\t\tconst success = literalsMatch(literal, parentLiteral, allowSubstitutions);\n\n\t\tif (success) {\n\t\t\tliteral.setLiteralInParent(parentLiteral);\n\t\t\ti = i + 1;\n\t\t\tj = j + 1;\n\t\t} else {\n\t\t\tassert(!foundRemovedLit || allowMultipleRemovals, `case 2 error:\\n${literals.toString()}\\n${parentLiterals.toString()}`);\n\t\t\tfoundRemovedLit = true;\n\t\t\tj = j + 1;\n\t\t}\n\t}\n}\n\n// inferences, which rewrite exactly one literal, and shift that literal to the first position in literals\n// need to find the position where the literal was rewritten\n// note: this may compute a wrong matching if a literal in the side-part of the clause matches the rewritten literal in the parent\n//       in this case the wrongly matched literals in the parent are pairwise unifiable, so a sane user would assign to all of them the same orientation.\n//       in particular the wrong matching should not affect the orientation-heuristic in practice\n// we also need to support simultanous superposition, which not only rewrites one literal and shifts that literal to the first position, but also allows other\n// literals to be rewritten. In particular, we are then not able anymore to always succeed with matching literals. In that case, we try to do an educated guess\n// of the ordering (in a way such that we compute the right literal matches at least in the case of non-simultanous superposition).\nfunction computeParentLiteralsCase3(literals: Array<Literal>, parentLiterals: Array<Literal>, allowSubstitutions: boolean, allowSimultanousSuperposition: boolean) {\n\tassert(literals.length === parentLiterals.length, `case 3 error:\\n${literals.toString()}\\n${parentLiterals.toString()}`);\n\n\tlet foundRewrittenLiteral = false;\n\tlet i = 1;\n\t// first shifted matchings can occur\n\twhile(i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i - 1];\n\n\t\tif (literalsMatch(literal, parentLiteral, allowSubstitutions)) {\n\t\t\tliteral.setLiteralInParent(parentLiteral);\n\t\t\ti = i + 1;\n\t\t} else {\n\t\t\t// shifted matching failed, so parentLiterals[i - 1] must be rewrittenLiteral\n\t\t\tliterals[0].setLiteralInParent(parentLiterals[i - 1]);\n\t\t\tfoundRewrittenLiteral = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// corner case where rewritten literal is last element of parent clause and therefore has no failing shifted matching\n\tif (!foundRewrittenLiteral) {\n\t\tassert(i === literals.length);\n\t\tliterals[0].setLiteralInParent(parentLiterals[parentLiterals.length - 1]);\n\t}\n\t// now nonshifted matchings can occur\n\twhile(i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i];\n\t\tif (!allowSimultanousSuperposition) {\n\t\t\tassert(literalsMatch(literal, parentLiteral, allowSubstitutions), `case 3 error: literal ${i} doesn't match parent literal.\\n${literals.toString()}\\n${parentLiterals.toString()}\\n`);\n\t\t}\n\t\tliteral.setLiteralInParent(parentLiteral);\n\t\ti = i + 1;\n\t}\n}\n\n\nexport function computeParentLiterals(dag: Dag) {\n\tfor (const node of dag.nodes.values()) {\n\t\tif (!node.isBoundary && node.unit.type === \"Clause\") {\n\t\t\tconst clause = node.unit as Clause;\n\n\t\t\tif (node.inferenceRule === \"evaluation\" ||\n\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras injectivity\" && node.parents.length === 1) ||\n\t\t\t\tnode.inferenceRule === \"subsumption resolution\" ||\n\t\t\t\tnode.inferenceRule === \"equality resolution\" ||\n\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras distinctness\" && node.parents.length === 1) ||\n\t\t\t\tnode.inferenceRule === \"forward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"equality factoring\") {\n\t\t\t\tassert(node.parents.length > 0);\n\n\t\t\t\t// we assume that the first parent is the main premise\n\t\t\t\tconst parent = dag.get(node.parents[0]);\n\n\t\t\t\t// only compute literal matchings for clauses\n\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\n\t\t\t\t\t// compute literal ordering at the timepoint where clause was generated\n\t\t\t\t\t// note that the active-event can change the order of literals (since at this point the selected literals are computed and shifted to the front)\n\t\t\t\t\tassert(node.newTime !== null);\n\t\t\t\t\tassert(parent.newTime !== null);\n\t\t\t\t\tconst parentWasAlreadyActivated = parent.activeTime !== null && parent.activeTime <= node.newTime!;\n\t\t\t\t\tconst parentLiterals = parentWasAlreadyActivated ? parentClause.literalsActiveEvent! : parentClause.literalsNewEvent!;\n\t\t\t\t\tconst literals = clause.literalsNewEvent!;\n\t\t\t\t\tassert(parentLiterals !== null);\n\t\t\t\t\tassert(literals !== null);\n\n\t\t\t\t\t// compute the literal-matchings\n\t\t\t\t\t// in full generality, this computation would be computationally expensive and a lot of implementation effort\n\t\t\t\t\t// instead, we hardcode computations of matchings for the most important inference rules implemented in Vampire, and don't compute matchings for other inferences\n\t\t\t\t\tif ((node.inferenceRule === \"evaluation\" && literals.length === parentLiterals.length) || \n\t\t\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"term algebras injectivity\") {\n\n\t\t\t\t\t\tcomputeParentLiteralsCase1(literals, parentLiterals);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"subsumption resolution\" || \n\t\t\t\t\t\tnode.inferenceRule === \"equality resolution\" || \n\t\t\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"term algebras distinctness\" ||\n\t\t\t\t\t\t(node.inferenceRule === \"evaluation\" && literals.length + 1 === parentLiterals.length)) {\n\n\t\t\t\t\t\tconst allowSubstitutions = node.inferenceRule === \"equality resolution\" || node.inferenceRule === \"factoring\";\n\t\t\t\t\t\tconst allowMultipleRemovals = node.inferenceRule === \"trivial inequality removal\" || node.inferenceRule === \"duplicate literal removal\";\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals, parentLiterals, allowSubstitutions, allowMultipleRemovals);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"forward demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"equality factoring\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst allowSubstitutions = node.inferenceRule === \"equality factoring\";\n\t\t\t\t\t\tcomputeParentLiteralsCase3(literals, parentLiterals, allowSubstitutions, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.inferenceRule === \"resolution\" ||\n\t\t\t\tnode.inferenceRule === \"superposition\") {\n\t\t\t\tassert(node.parents.length === 2);\n\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\n\t\t\t\t// only compute literal matchings for clauses\n\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\n\t\t\t\t\t// compute literal ordering at the timepoint where clause was generated\n\t\t\t\t\t// note again that the active-event can change the order of literals (since at this point the selected literals are computed and shifted to the front)\n\t\t\t\t\tassert(node.newTime !== null);\n\t\t\t\t\tassert(leftNode.newTime !== null);\n\t\t\t\t\tassert(rightNode.newTime !== null);\n\t\t\t\t\tconst leftWasAlreadyActivated = leftNode.activeTime !== null && leftNode.activeTime <= node.newTime!;\n\t\t\t\t\tconst rightWasAlreadyActivated = rightNode.activeTime !== null && rightNode.activeTime <= node.newTime!;\n\t\t\t\t\tconst leftLiterals = leftWasAlreadyActivated ? leftClause.literalsActiveEvent! : leftClause.literalsNewEvent!;\n\t\t\t\t\tconst rightLiterals = rightWasAlreadyActivated ? rightClause.literalsActiveEvent! : rightClause.literalsNewEvent!;\n\t\t\t\t\tconst literals = clause.literalsNewEvent!;\n\t\t\t\t\tassert(leftLiterals !== null);\n\t\t\t\t\tassert(rightLiterals !== null);\n\t\t\t\t\tassert(literals !== null);\n\t\t\t\t\tassert(leftLiterals.length > 0);\n\t\t\t\t\tassert(rightLiterals.length > 0);\n\n\t\t\t\t\tif (node.inferenceRule === \"resolution\") {\n\t\t\t\t\t\tassert(literals.length + 2 === leftLiterals.length + rightLiterals.length);\n\n\t\t\t\t\t\t// compute matchings separately for literals coming from leftLiterals resp. rightLiterals\n\t\t\t\t\t\t// split denotes the first position in literals with a literal coming from rightLiterals\n\t\t\t\t\t\tconst split = leftLiterals.length - 1;\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(0, split), leftLiterals, true, false);\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(split, literals.length), rightLiterals, true, false);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"superposition\") {\n\t\t\t\t\t\tassert(literals.length + 1 === leftLiterals.length + rightLiterals.length);\n\n\t\t\t\t\t\t// compute matchings separately for literals coming from leftLiterals resp. rightLiterals\n\t\t\t\t\t\t// split denotes the first position in literals with a literal coming from rightLiterals\n\t\t\t\t\t\tconst split = leftLiterals.length;\n\t\t\t\t\t\tcomputeParentLiteralsCase3(literals.slice(0, split), leftLiterals, true, true);\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(split, literals.length), rightLiterals, true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// update in the given dag:\n// - literal orientations\n// - literal representations\n// - ordering of literals in premises and conclusions\n// if changedClauseId is null, update all nodes in the dag\n// if changedClauseId is the id of a clause, update the node and all children of the node\n// Precondition: computeParentLiterals was already called on the current dag\nexport function computeClauseRepresentation(dag: Dag, changedClauseId: number | null): Set<number> {\n\tassert(changedClauseId === null || dag.nodes.has(changedClauseId));\n\n\tconst changedClauses = new Set<number>();\n\tif (changedClauseId !== null) {\n\t\tchangedClauses.add(changedClauseId);\n\t}\n\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tlet node = iterator.getNext();\n\n\t\tif (!node.isBoundary && node.unit.type === \"Clause\") {\n\t\t\tconst clause = node.unit as Clause;\n\n\t\t\t// compute whether clause should be updated. This is the case if\n\t\t\t// 1) all nodes should be updated (since changedClauseId === null)\n\t\t\t// 2) the node is changedClauseId\n\t\t\t// 3) a parent of node was changed\n\t\t\tlet update = changedClauseId === null || node.id === changedClauseId;\n\t\t\tif (!update) {\n\t\t\t\tfor (const parentId of node.parents) {\n\t\t\t\t\tif (changedClauses.has(parentId)) {\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Part 1: partition literals into premise and conclusion and compute literal-representation\n\t\t\t// Hack: Vampire by default uses \"equality resolution with deletion\" as inference rule during preprocessing.\n\t\t\t//       Unfortunately the produced inference is named \"equalityresolution\" and therefore clashes with\n\t\t\t//       inferences produced by the generating inference rule with the same name.\n\t\t\t//       We therefore check that inferences with name \"equality resolution\" are not \"equality resolution with deletion\"-inferences.\n\t\t\tconst isEqualityResolutionWithDeletion = node.inferenceRule === \"equality resolution\" && dag.get(node.parents[0]).isFromPreprocessing === true;\n\t\t\tconst propagateSingleParent = node.inferenceRule === \"subsumption resolution\" ||\n\t\t\t\t(node.inferenceRule === \"equality resolution\" && !isEqualityResolutionWithDeletion) ||\n\t\t\t\tnode.inferenceRule === \"equality factoring\" ||\n\t\t\t\tnode.inferenceRule === \"forward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\tnode.inferenceRule === \"evaluation\" ||\n\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras injectivity\" && node.parents.length === 1) ||\n\t\t\t\t(node.inferenceRule === \"term algebras distinctness\" && node.parents.length === 1);\n\t\t\tconst propagateTwoParents = node.inferenceRule === \"resolution\" ||\n\t\t\t\tnode.inferenceRule === \"superposition\";\n\n\t\t\tconst premiseLiterals = new Array<Literal>();\n\t\t\tconst conclusionLiterals = new Array<Literal>();\n\t\t\tconst contextLiterals = new Array<Literal>();\n\t\t\tfor (const literal of clause.premiseLiterals.concat(clause.conclusionLiterals, clause.contextLiterals)) {\n\n\t\t\t\tlet orientation: \"premise\" | \"conclusion\" | \"context\" | null = null;\n\n\t\t\t\tconst parentLiteral = literal.literalInParent;\n\t\t\t\tif (literal.orientationReason !== \"user\" && (propagateSingleParent || propagateTwoParents)) {\n\t\t\t\t\tassert(parentLiteral !== null);\n\t\t\t\t\t// propagate orientation and representation from parent literal\n\t\t\t\t\tliteral.representation = parentLiteral!.representation;\n\t\t\t\t\tif (propagateSingleParent) {\n\t\t\t\t\t\tassert(node.parents.length > 0);\n\n\t\t\t\t\t\t// we assume that the first parent is the main premise\n\t\t\t\t\t\tconst parent = dag.get(node.parents[0]);\n\n\t\t\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\t\t\t\t\t\t\t// figure out whether parentLiteral occurs in premise or conclusion and set orientation accordingly\n\t\t\t\t\t\t\tif (parentClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (parentClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert(parentClause.contextLiterals.find(l => l === parentLiteral));\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (propagateTwoParents) {\n\t\t\t\t\t\tassert(node.parents.length === 2);\n\t\t\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\t\t\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\t\t\t\t\t\t\t// figure out whether parentLiteral occurs in premise or conclusion of left or right premise and set orientation accordingly\n\t\t\t\t\t\t\tif (leftClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (leftClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else if (leftClause.contextLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t} else if (rightClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (rightClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert(rightClause.contextLiterals.find(l => l === parentLiteral));\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tliteral.orientationReason = \"inherited\"\n\t\t\t\t}\n\n\t\t\t\t// otherwise decide whether current orientation should be kept or whether it should be computed using a heuristic\n\t\t\t\telse if (literal.orientationReason !== \"none\" ) {\n\t\t\t\t\tif (clause.premiseLiterals.find(l => l === literal)) {\n\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t} else if (clause.conclusionLiterals.find(l => l === literal)) {\n\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(clause.contextLiterals.find(l => l === literal))\n\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// use heuristic to compute orientation\n\t\t\t\t\tif (literal.negated && literal.name !== \"=\") {\n\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t}\n\t\t\t\t\tliteral.orientationReason = \"heuristic\";\n\t\t\t\t}\n\n\t\t\t\tif (orientation === \"premise\") {\n\t\t\t\t\tpremiseLiterals.push(literal);\n\t\t\t\t} else if (orientation === \"conclusion\") {\n\t\t\t\t\tconclusionLiterals.push(literal);\n\t\t\t\t} else {\n\t\t\t\t\tassert(orientation === \"context\");\n\t\t\t\t\tcontextLiterals.push(literal);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Part 2: order literals according to the order of literals in the parents\n\t\t\t// only sort if no manually oriented literal in clause\n\t\t\tlet existsUserOrientedLiteral = false;\n\t\t\tfor (const literal of clause.premiseLiterals.concat(clause.conclusionLiterals, clause.contextLiterals)) {\n\t\t\t\tif (literal.orientationReason === \"user\") {\n\t\t\t\t\texistsUserOrientedLiteral = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!existsUserOrientedLiteral && propagateSingleParent) {\n\t\t\t\t// we assume that the first parent is the main premise\n\t\t\t\tconst parent = dag.get(node.parents[0]);\n\t\t\t\t\n\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\n\t\t\t\t\t// generate map parentLiteral -> indexInPremise\n\t\t\t\t\tconst premiseIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map parentLiteral -> indexInConclusion\n\t\t\t\t\tconst conclusionIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map parentLiteral -> indexInContext\n\t\t\t\t\tconst contextIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// sort premise, conclusion and context\n\t\t\t\t\tpremiseLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = premiseIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = premiseIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tconclusionLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = conclusionIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = conclusionIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tcontextLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = contextIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = contextIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (!existsUserOrientedLiteral && propagateTwoParents) {\n\t\t\t\tassert(node.parents.length === 2);\n\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInPremise\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst premiseIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i + leftClause.premiseLiterals.length);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInConclusion\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst conclusionIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i + leftClause.conclusionLiterals.length);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInContext\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst contextIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i + leftClause.contextLiterals.length);\n\t\t\t\t\t}\n\n\t\t\t\t\t// sort premise, conclusion and context\n\t\t\t\t\tpremiseLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = premiseIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = premiseIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tconclusionLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = conclusionIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = conclusionIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tcontextLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = contextIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = contextIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Part 3: update literals\n\t\t\tclause.premiseLiterals = premiseLiterals;\n\t\t\tclause.conclusionLiterals = conclusionLiterals;\n\t\t\tclause.contextLiterals = contextLiterals;\n\n\t\t\t// Part 4: mark clause to be changed\n\t\t\tchangedClauses.add(node.id);\n\t\t}\n\t}\n\n\treturn changedClauses;\n}\n\n\n\n\n\n","import {assert} from './util'\nimport {Unit, Formula, Clause} from './unit'\nimport {Literal, Term} from './literal'\nimport { Dag } from './dag'\nimport SatNode from './sat-node';\nimport { computeParentLiterals } from './clause-orientation';\n\nexport class Serializer {\n\treadonly version = 1 // the version number of the Serializer. The version number will be added to the generated json.\n\n\tstatic serializeAppState(problem: string, vampireUserOptions: string, dag: Dag): string {\n\t\tassert(!dag.isPassiveDag);\n\n\t\tconst obj = {\n      \"version\": 1,\n      \"problem\": problem,\n      \"vampireUserOptions\": vampireUserOptions,\n      \"dag\": dag\n\t\t};\n\n\t\tconst replacer = (key, value) => {\n\t\t\t// ignore several properties\n\t\t\tif (key === \"leaves\" ||\n\t\t\t\tkey === \"mergeMap\" ||\n\t\t\t\tkey === \"isPassiveDag\" ||\n\t\t\t\tkey === \"styleMap\" ||\n\t\t\t\tkey === \"activeNodeId\" ||\n\t\t\t\tkey === \"literalInParent\" ||\n\t\t\t\tkey === \"isVariable\") {\n\t\t\t\t\n\t\t\t\treturn undefined; \n\t\t\t}\n\t\t\t// encode premise-, conclusion-, and context-literals of Clauses\n\t\t\tif (key === \"unit\") {\n\t\t\t\tconst unit = (value as Unit);\n\t\t\t\tif (unit.type === \"Clause\") {\n\t\t\t\t\tconst clause = (value as Clause);\n\n\t\t\t\t\tconst convertToIndices = (literals) => {\n\t\t\t\t\t\tconst encodedLiterals = new Array<number>();\n\t\t\t\t\t\tfor (const lit1 of literals) {\n\t\t\t\t\t\t\tfor (let i = 0; i < clause.literalsNewEvent.length; i++) {\n\t\t\t\t\t\t\t\tconst lit2 = clause.literalsNewEvent[i];\n\t\t\t\t\t\t\t\tif (lit1 === lit2) {\n\t\t\t\t\t\t\t\t\tencodedLiterals.push(i);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn encodedLiterals;\n\t\t\t\t\t}\n\t\t\t\t\tconst encodedPremiseLiterals = convertToIndices(clause.premiseLiterals);\n\t\t\t\t\tconst encodedConclusionLiterals = convertToIndices(clause.conclusionLiterals);\n\t\t\t\t\tconst encodedContextLiterals = convertToIndices(clause.contextLiterals);\n\t\t\t\t\tconst encodedLiteralsActiveEvent = clause.literalsActiveEvent === null ? null : convertToIndices(clause.literalsActiveEvent);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t\"type\": \"Clause\", \n\t\t\t\t\t\t\"literalsNewEvent\": clause.literalsNewEvent, \n\t\t\t\t\t\t\"premiseLiterals\": encodedPremiseLiterals, \n\t\t\t\t\t\t\"conclusionLiterals\": encodedConclusionLiterals, \n\t\t\t\t\t\t\"contextLiterals\": encodedContextLiterals,\n\t\t\t\t\t\t\"literalsActiveEvent\": encodedLiteralsActiveEvent\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// convert sets and maps to arrays\n\t\t\tif (value instanceof Set) {\n\t\t\t\treturn Array.from(value);\n\t\t\t} else if (value instanceof Map) {\n\t\t\t\treturn Array.from(value.entries());\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\treturn JSON.stringify(obj, replacer);\n\t}\n\n\tstatic deserializeAppState(json: string): [number, string, string, Dag] {\n\t\tconst res = JSON.parse(json);\n\t\tassert(res.version !== undefined);\n\t\tassert(res.problem !== undefined);\n\t\tassert(res.vampireUserOptions !== undefined);\n\t\tassert(res.dag !== undefined);\n\n\t\tconst dag = this.reconstructDag(res.dag);\n\n\t\treturn [res.version, res.problem, res.vampireUserOptions, dag];\n\t}\n\n\tstatic reconstructDag(obj): Dag {\n\t\tassert(obj.nodes !== undefined);\n\t\tconst nodes = new Map<number,SatNode>();\n\t\tfor (const pairIdNode of obj.nodes) {\n\t\t\tnodes.set(pairIdNode[0], Serializer.reconstructSatNode(pairIdNode[1]));\n\t\t}\n\t\tconst dag = new Dag(nodes);\n\t\tcomputeParentLiterals(dag); // TODO: hack.\n\n\t\treturn dag;\n\t}\n\t\n\tstatic reconstructSatNode(obj): SatNode {\n\t\tassert(obj.id !== undefined);\n\t\tassert(obj.unit !== undefined);\n\t\tassert(obj.inferenceRule !== undefined);\n\t\tassert(obj.parents !== undefined);\n\t\tassert(obj.statistics !== undefined);\n\t\tassert(obj.isFromPreprocessing !== undefined);\n\t\tassert(obj.newTime !== undefined);\n\t\tassert(obj.activeTime !== undefined);\n\t\tassert(obj.deletionTime !== undefined);\n\t\tassert(obj.deletionParents !== undefined);\n\t\tassert(obj.position !== undefined);\n\t\tassert(obj.isBoundary !== undefined);\n\n\t\tconst unit = Serializer.reconstructUnit(obj.unit);\n\t\tconst statistics = new Map<string,number>();\n\t\tfor (const pair of obj.statistics) {\n\t\t\tstatistics.set(pair[0], pair[1]);\n\t\t}\n\n\t\tconst node = new SatNode(obj.id, unit, obj.inferenceRule, obj.parents, statistics, obj.isFromPreprocessing, obj.newTime, obj.activeTime, obj.deletionTime, obj.deletionParents, obj.isBoundary);\n\t\tnode.position = obj.position;\n\n\t\treturn node;\n\t}\n\n\tstatic reconstructUnit(obj): Unit {\n\t\tassert(obj.type !== undefined);\n\t\tif (obj.type === \"Formula\") {\n\t\t\tassert(obj.formula !== undefined);\n\t\t\treturn new Formula(obj.formula);\n\t\t} else {\n\t\t\tassert(obj.literalsNewEvent !== undefined);\n\t\t\tassert(obj.premiseLiterals !== undefined);\n\t\t\tassert(obj.conclusionLiterals !== undefined);\n\t\t\tassert(obj.contextLiterals !== undefined);\n\t\t\tassert(obj.literalsActiveEvent !== undefined);\n\t\t\t\n\t\t\tconst literalsNewEvent = obj.literalsNewEvent.map(literal => Serializer.reconstructLiteral(literal));\n\t\t\t\n\t\t\t// reconstruct encoded literal-arrays\n\t\t\tconst premiseLiterals = obj.premiseLiterals.map(n => literalsNewEvent[n]);\n\t\t\tconst conclusionLiterals = obj.conclusionLiterals.map(n => literalsNewEvent[n]);\n\t\t\tconst contextLiterals = obj.contextLiterals.map(n => literalsNewEvent[n]);\n\t\t\tconst literalsActiveEvent = obj.literalsActiveEvent === null ? null : obj.literalsActiveEvent.map(n => literalsNewEvent[n]);\n\t\t\t\n\t\t\tconst clause = new Clause(literalsNewEvent, premiseLiterals, conclusionLiterals, contextLiterals);\n\t\t\tclause.literalsActiveEvent = literalsActiveEvent;\n\t\t\treturn clause;\n\t\t}\n\t}\n\n\tstatic reconstructLiteral(obj): Literal {\n\t\tassert(obj.name !== undefined);\n\t\tassert(obj.args !== undefined);\n\t\tassert(obj.negated !== undefined);\n\t\tassert(obj.isSelected !== undefined);\n\t\tassert(obj.representation !== undefined);\n\t\tassert(obj.hideBracketsAssoc !== undefined);\n\t\tassert(obj.nonStrictForNegatedStrictInequalities !== undefined);\n\t\tassert(obj.orientationReason !== undefined);\n\n\t\tconst args = obj.args.map(term => Serializer.reconstructTerm(term));\n\t\t\n\t\tconst literal = new Literal(obj.name, args, obj.negated);\n\t\tliteral.isSelected = obj.isSelected;\n\t\tliteral.representation = obj.representation;\n\t\tliteral.hideBracketsAssoc = obj.hideBracketsAssoc;\n\t\tliteral.nonStrictForNegatedStrictInequalities = obj.nonStrictForNegatedStrictInequalities;\n\t\tliteral.orientationReason = obj.orientationReason;\n\n\t\treturn literal;\n\t}\n\n\tstatic reconstructTerm(obj): Term {\n\t\tassert(obj.name !== undefined);\n\t\tassert(obj.args !== undefined);\n\n\t\tconst args = obj.args.map(term => Serializer.reconstructTerm(term));\n\n\t\treturn new Term(obj.name, args);\n\t}\n}\n","import * as React from 'react';\nimport {Component} from 'react';\n\nimport Main from './Main';\nimport Aside from './Aside';\nimport {Dag, ParsedLine} from '../model/dag';\nimport SatNode from '../model/sat-node';\nimport './App.css';\nimport {assert} from '../model/util';\nimport {filterNonConsequences, filterNonParents, mergePreprocessing} from '../model/transformations';\nimport {findCommonConsequences} from '../model/find-node';\nimport {VizWrapper} from '../model/viz-wrapper';\nimport {Clause} from '../model/unit';\nimport {Literal} from '../model/literal';\nimport {computeClauseRepresentation, computeParentLiterals} from '../model/clause-orientation';\nimport {Serializer} from '../model/serialization';\n\nexport enum AppMode {\n  'proof',\n  'saturation',\n  'manualcs',\n  'saved'\n}\n\ntype Props = {\n  problem: string,\n  loadedProblem?: string,\n  vampireUserOptions: string,\n  mode: AppMode,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean, \n  orientClauses: boolean,\n  logging: boolean\n};\n\n/* Invariant: the state is always in one of the following phases\n *    \"loaded\": A dag is loaded. Clause selection is not possible. dags, nodeSelection and currentTime hold meaningful values.\n *    \"loaded selected\": Same as \"loaded\", but clause selection is possible.\n *    \"waiting\": Waiting for answer from Vampire server. message holds a meaningful value.\n *    \"layouting\": Layouting a dag. message holds a meaningful value.\n *    \"error\": Some error occured. message holds a meaningful value.\n */\ntype State = {\n  state: \"loaded\" | \"loaded select\" | \"waiting\" | \"layouting\" | \"error\",\n  dags: Dag[],\n  nodeSelection: number[],\n  currentTime: number,\n  animateDagChanges,\n  changedNodesEvent?: Set<number>, // update to trigger refresh of node in graph. Event is of the form [eventId, nodeId]\n  message: string,\n  showPassiveDag: boolean\n  nodeIdToActivate: number | null,\n  infoToggle: boolean,\n  editToggle: boolean\n}\n\nclass App extends Component<Props, State> {\n\n  state: State = {\n    state: \"waiting\",\n    dags: [],\n    nodeSelection: [],\n    currentTime: 0,\n    animateDagChanges: false,\n    changedNodesEvent: undefined,\n    message: \"\",\n    showPassiveDag: false,\n    nodeIdToActivate: null,\n    infoToggle: false,\n    editToggle: false,\n  };\n\n  render() {\n    const {\n      state,\n      dags,\n      nodeSelection,\n      currentTime,\n      animateDagChanges,\n      changedNodesEvent,\n      message,\n      showPassiveDag\n    } = this.state;\n    \n    let dag;\n    let main;\n    if (state === \"loaded\" || state === \"loaded select\") {\n      assert(dags.length > 0);\n      dag = dags[dags.length-1];\n      main = (\n        <Main\n          dag={dag}\n          showPassiveDag={showPassiveDag}\n          nodeSelection={nodeSelection}\n          changedNodesEvent={changedNodesEvent}\n          historyLength={dags[0].maximalActiveTime()}\n          currentTime={currentTime}\n          animateDagChanges={animateDagChanges}\n          infoToggle={this.state.infoToggle}\n          editToggle={this.state.editToggle}\n          readOnly={this.props.mode === AppMode.saved}\n          onNodeSelectionChange={this.updateNodeSelection.bind(this)}\n          onCurrentTimeChange={this.updateCurrentTime.bind(this)}\n          onDismissPassiveDag={this.dismissPassiveDag.bind(this)}\n          onUpdateNodePositions={this.updateNodePositions.bind(this)}\n          onLiteralOrientationChange={this.changeLiteralOrientation.bind(this)}\n          onLiteralRepresentationChange={this.changeLiteralRepresentation.bind(this)}\n          onToggleInfo={this.toggleInfo.bind(this)}\n          onToggleEdit={this.toggleEdit.bind(this)}\n        />\n      );\n    } else {\n      dag = null;\n      main = (\n        <main>\n          <section className=\"graph-placeholder\">{message}</section>\n          <section className=\"slider-placeholder\"/>\n        </main>\n      );\n    }\n\n    return (\n      <div className=\"app\">\n        {main}\n        <Aside\n          dag={dag}\n          currentTime={currentTime}\n          nodeSelection={nodeSelection}\n          multipleVersions={dags.length > 1}\n          infoToggle={this.state.infoToggle}\n          editToggle={this.state.editToggle}\n          readOnly={this.props.mode === AppMode.saved}\n          onUpdateNodeSelection={this.updateNodeSelection.bind(this)}\n          onUndo={this.undoLastStep.bind(this)}\n          onRenderParentsOnly={this.renderParentsOnly.bind(this)}\n          onRenderChildrenOnly={this.renderChildrenOnly.bind(this)}\n          onShowPassiveDag={this.showPassiveDag.bind(this)}\n          onSelectParents={this.selectParents.bind(this)}\n          onSelectChildren={this.selectChildren.bind(this)}\n          onSelectCommonConsequences={this.selectCommonConsequences.bind(this)}\n          onLiteralOrientationChange={this.changeLiteralOrientation.bind(this)}\n          onLiteralRepresentationChange={this.changeLiteralRepresentation.bind(this)}\n          onToggleInfo={this.toggleInfo.bind(this)}\n          onToggleEdit={this.toggleEdit.bind(this)}\n        />\n      </div>\n    );\n\n  }\n\n  async componentDidMount() {\n    if (this.props.mode === AppMode.saved) {\n      // render 'read-only' mode\n      const [, , , dag] = Serializer.deserializeAppState(this.props.loadedProblem || '{}');\n      this.setState({\n        state: 'loaded',\n        dags: [dag],\n        nodeSelection: [],\n        currentTime: dag.maximalActiveTime(),\n        animateDagChanges: false\n      });\n    } else {\n      // call Vampire on given input problem\n      await this.runVampire(this.props.problem, this.props.vampireUserOptions, this.props.mode);\n\n      if (this.state.state === 'loaded select' && this.props.mode === AppMode.manualcs) {\n        this.selectFinalPreprocessingClauses();\n      }\n    }\n  }\n\n  // LOAD AND SAVE /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  serialize(): string {\n    assert(this.state.state === \"loaded\" || this.state.state === \"loaded select\");\n    assert(this.state.dags.length > 0);\n\n    return Serializer.serializeAppState(this.props.problem, this.props.vampireUserOptions, this.state.dags[0]);\n  }\n\n  // NETWORK ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  updateNodeSelection(nodeSelection: number[]) {\n    if (this.props.logging) {\n      console.log(`Updating node selection to [${nodeSelection.toString()}]`);\n    }\n    this.setState({nodeSelection: nodeSelection});\n  }\n\n  updateCurrentTime(currentTime: number) {\n    if (this.props.logging) {\n      console.log(`Updating current time to ${currentTime}`);\n    }\n    const dags = this.state.dags\n    assert(dags.length > 0);\n    const dag = dags[dags.length - 1];\n\n    const nodesInActiveDag = dag.computeNodesInActiveDag(currentTime);\n    const nodeSelection = new Array<number>();\n    for (const nodeId of this.state.nodeSelection) {\n      if (nodesInActiveDag.has(nodeId)) {\n        nodeSelection.push(nodeId);\n      }\n    }\n    this.setState({\n      nodeSelection: nodeSelection,\n      currentTime: currentTime\n    });\n  }\n\n\n  // FILE UPLOAD ///////////////////////////////////////////////////////////////////////////////////////////////////////\n  jsonToParsedLines(json: any): Array<ParsedLine> {\n    const parsedLines = new Array<ParsedLine>();\n    for (const line of json.lines) {\n      const statistics = new Map<string,number>();\n      for (const key in line.statistics) {\n        const val = line.statistics[key];\n        if (typeof val === \"number\"){\n          statistics.set(key, val);\n        }\n      }\n      parsedLines.push(new ParsedLine(line.lineType, line.unitId, line.unitString, line.inferenceRule, line.parents, statistics));\n    }\n    return parsedLines;\n  }\n\n  async runVampire(problem: string, vampireUserOptions: string, mode: AppMode) {\n    assert(mode !== AppMode.saved, 'Saved mode does not require vampire.');\n\n    this.setState({\n      state: \"waiting\",\n      message: \"Waiting for Vampire...\",\n      dags: [],\n      nodeSelection: [],\n      currentTime: 0\n    });\n\n    const url = mode === AppMode.manualcs ? 'http://localhost:5000/vampire/startmanualcs' : 'http://localhost:5000/vampire/start';\n    if (this.props.logging) {\n      console.log(`Starting request to url '${url}' with Vampire-user-options '${vampireUserOptions}'.`);\n    }\n    const fetchedJSON = await fetch(url, {\n      method: 'POST',\n      mode: 'cors',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        file: problem,\n        vampireUserOptions: vampireUserOptions\n      })\n    });\n\n    try {\n      const json = await fetchedJSON.json();\n\n      if (this.props.logging) {\n        console.log(`Received response from Vampire server.`);\n      }\n      if (json.status === \"success\") {\n        assert(json.vampireState === \"running\" ||\n          json.vampireState === \"refutation\" ||\n          json.vampireState === \"saturation\" ||\n          json.vampireState === \"timeout\");\n\n        if (mode === AppMode.proof) {\n          assert(json.vampireState !== \"running\")\n          if (json.vampireState === \"saturation\") {\n            this.setState({\n              state: \"error\",\n              message: \"Saturation: Vampire saturated, so there exists no proof!\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n          if (json.vampireState === \"timeout\") {\n            this.setState({\n              state: \"error\",\n              message: \"Timeout: Vampire could not find a proof in the given time!\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n        } else {\n          if (json.vampireState === \"saturation\" && json.lines.length === 0) {\n            this.setState({\n              state: \"error\",\n              message: \"The example was already identified to be satisfiable during Vampire's preprocessing.\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n        }\n        if (this.props.logging) {\n          console.log(`Constructing Vampire-saturation-events from received JSON.`);\n        }\n        const parsedLines = this.jsonToParsedLines(json);\n\n        if (this.props.logging) {\n          console.log(`Constructing saturation graph from Vampire-saturation-events.`);\n        }\n        let dag = Dag.fromParsedLines(parsedLines, null);\n\n        if (this.props.logging) {\n          console.log(`Merging preprocessing-subgraph of saturation graph.`);\n        }\n        dag = mergePreprocessing(dag);\n\n        if (mode === AppMode.proof) {\n          assert(dag.isRefutation);\n          // find empty clause\n          for (const node of dag.nodes.values()) {\n            if (node.unit.type === \"Clause\") {\n              const clause = node.unit as Clause;\n              if (clause.premiseLiterals.length === 0 && clause.conclusionLiterals.length === 0) {\n\n                // filter all non-parents of empty clause\n                const relevantIds = new Set<number>();\n                relevantIds.add(node.id);\n                dag = filterNonParents(dag, relevantIds);\n                break;\n              }\n            }\n          }\n        }\n        if (this.props.logging) {\n          console.log(`Computing layout for saturation graph.`);\n        }\n        await VizWrapper.layoutDag(dag, true);\n\n        if (this.props.orientClauses) {\n          if (this.props.logging) {\n            console.log(`Computing literal flows for saturation graph.`);\n          }\n          computeParentLiterals(dag);\n          if (this.props.logging) {\n            console.log(`Computing clause representations for saturation graph.`);\n          }\n          computeClauseRepresentation(dag, null);\n        }\n        this.setLiteralOptions(dag);\n\n        const state = (mode === AppMode.manualcs && json.vampireState === \"running\") ? \"loaded select\" : \"loaded\";\n\n        this.setState({\n          state: state,\n          dags: [dag],\n          nodeSelection: [],\n          currentTime: dag.maximalActiveTime(),\n          animateDagChanges: false\n        });\n        if (this.props.logging) {\n          console.log(`Finished preparation of saturation graph.`);\n        }\n      } else {\n        assert(json.status === \"error\");\n        const errorMessage = json.message;\n        assert(errorMessage !== undefined && errorMessage !== null);\n        this.setState({\n          state: \"error\",\n          message: errorMessage,\n          dags: [],\n          nodeSelection: [],\n          currentTime: 0\n        });\n      }\n    } catch (error) {\n      if (error.name === \"SatVisAssertionError\") {\n        throw error;\n      }\n      this.setState({\n        state: \"error\",\n        message: `Error: ${error[\"message\"]}`,\n        dags: [],\n        nodeSelection: [],\n        currentTime: 0\n      });\n    }\n  }\n\n  // select the clause with id 'selectedId', then compute incremental layout for resulting dag\n  async selectClause(selectedId: number, positioningHint: [number, number]) {\n    assert(this.state.dags.length >= 1);\n    const currentDag = this.state.dags[this.state.dags.length-1];\n    const currentDagActiveNodes = currentDag.computeNodesInActiveDag(currentDag.maximalActiveTime()); // needs to be computed before dag is extended, since nodes are shared\n    assert(currentDag.mergeMap !== null);\n\n    // ask server to select clause and await resulting saturation events\n    const url = 'http://localhost:5000/vampire/select';\n    if (this.props.logging) {\n      console.log(`Starting request to url '${url}' with selected-id '${selectedId}'.`);\n    }\n    const fetchedJSON = await fetch(url, {\n      method: 'POST',\n      mode: 'cors',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({id: selectedId})\n    });\n\n    try {\n      const json = await fetchedJSON.json();\n      if (this.props.logging) {\n        console.log(`Received response from Vampire server.`);\n      }\n      if (json.status === \"success\") {\n        if (this.props.logging) {\n          console.log(`Constructing Vampire-saturation-events from received JSON.`);\n        }\n        const parsedLines = this.jsonToParsedLines(json);\n\n        // extend existing dag with new saturation events from server\n        if (this.props.logging) {\n          console.log(`Extending existing saturation graph with Vampire-saturation-events.`);\n        }\n        const newDag = Dag.fromParsedLines(parsedLines, currentDag);\n\n        // compute which nodes have been newly generated\n        const newDagActiveNodes = newDag.computeNodesInActiveDag(newDag.maximalActiveTime());\n        const newNodes = new Map<number, SatNode>();\n        for (const [nodeId, node] of newDag.nodes) {\n          if(!currentDagActiveNodes.has(nodeId) && newDagActiveNodes.has(nodeId)) {\n            newNodes.set(nodeId, node);\n          }\n        }\n\n        if (newNodes.size > 0) {\n          if (this.props.logging) {\n            console.log(`Extending layout to new nodes of saturation graph.`);\n          }\n          await VizWrapper.layoutNodesAtPosition(newNodes, positioningHint);\n        }\n\n        if (this.props.orientClauses) {\n          if (this.props.logging) {\n            console.log(`Updating literal flows for saturation graph.`);\n          }\n          computeParentLiterals(newDag);\n          if (this.props.logging) {\n            console.log(`Updating clause representations for saturation graph.`);\n          }\n          computeClauseRepresentation(newDag, null);\n        }\n        this.setLiteralOptions(newDag);\n  \n        const state = json.vampireState === \"running\" ? \"loaded select\" : \"loaded\";\n        const nodeSelection = new Array<number>();\n        for (const nodeId of newNodes.keys()) {\n          nodeSelection.push(nodeId);\n        }\n        this.setState({\n          state: state,\n          dags: [newDag],\n          nodeSelection: nodeSelection,\n          currentTime: newDag.maximalActiveTime(),\n          animateDagChanges: true\n        });\n        if (this.props.logging) {\n          console.log(`Finished extension of saturation graph.`);\n        }\n      } else {\n        assert(json.status === \"error\");\n        const errorMessage = json.message;\n        assert(errorMessage !== undefined && errorMessage !== null);\n        this.setState({\n          state: \"error\",\n          message: errorMessage,\n          dags: [],\n          nodeSelection: [],\n          currentTime: 0\n        });\n      }\n    } catch (error) {\n      if (error.name === \"SatVisAssertionError\") {\n        throw error;\n      }\n      this.setState({\n        state: \"error\",\n        message: `Error: ${error[\"message\"]}`,\n        dags: [],\n        nodeSelection: [],\n        currentTime: 0\n      });\n    }\n  }\n\n  async selectFinalPreprocessingClauses() {\n    if (this.props.logging) {\n      console.log(`Starting to select all clauses from preprocessing.`);\n    }\n    // iterate as long as the server waits for clause selections and as long as a suitable clause is found\n    let stop = false;\n    while (this.state.state === \"loaded select\" && !stop) {\n      const dag = this.state.dags[0];\n\n      // find a final preprocessing clause which can be selected\n      stop = true;\n      for (const [nodeId, node] of dag.nodes) {\n        if (node.isFromPreprocessing && node.newTime !== null) {\n          if (node.activeTime === null && node.deletionTime === null) {\n            // select that clause\n            assert(node.position !== null);\n            await this.selectClause(nodeId, node.position as [number, number]);\n            stop = false;\n            break;\n          }\n        }\n      }\n    }\n    if (this.props.logging) {\n      console.log(`Finished to select all clauses from preprocessing.`);\n    }\n  }\n\n  // SUBGRAPH SELECTION ////////////////////////////////////////////////////////////////////////////////////////////////\n\n  undoLastStep() {\n    if (this.props.logging) {\n      console.log(`Pop last saturation graph from the stack.`);\n    }\n    this.popDag();\n  }\n\n  async renderParentsOnly() {\n    const {dags, nodeSelection} = this.state;\n    const currentDag = dags[dags.length - 1];\n\n    if (this.props.logging) {\n      console.log(`Generate saturation graph which consists only of the (transitive) parents of clauses [${nodeSelection}].`);\n    }\n    const newDag = filterNonParents(currentDag, new Set(nodeSelection));\n    if (this.props.logging) {\n      console.log(`Computing layout for new saturation graph.`);\n    }\n    await VizWrapper.layoutDag(newDag, true);\n\n    if (this.props.logging) {\n      console.log(`Finished preparation of new saturation graph. Pushing it to the stack.`);\n    }\n    this.pushDag(newDag);\n  }\n\n  async renderChildrenOnly() {\n    const {dags, nodeSelection} = this.state;\n    const currentDag = dags[dags.length - 1];\n\n    if (this.props.logging) {\n      console.log(`Generate saturation graph which consists only of the (transitive) children of clauses [${nodeSelection}].`);\n    }\n    const newDag = filterNonConsequences(currentDag, new Set(nodeSelection));\n    if (this.props.logging) {\n      console.log(`Computing layout for new saturation graph.`);\n    }\n    await VizWrapper.layoutDag(newDag, true);\n\n    if (this.props.logging) {\n      console.log(`Finished preparation of new saturation graph. Pushing it to the stack.`);\n    }\n    this.pushDag(newDag);\n  }\n\n  // PASSIVE DAG ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  async showPassiveDag() {\n    assert(this.state.showPassiveDag === false);\n    assert(this.state.nodeSelection.length > 0);\n\n    if (this.props.logging) {\n      console.log(`Display selection graph containing all clauses which can be selected for activation and whose derivation contains all the clauses [${this.state.nodeSelection}].`);\n    }\n    this.setState({showPassiveDag: true});\n  }\n\n  async dismissPassiveDag(selectedId: number | null, positioningHint: [number, number] | null) {\n    assert((selectedId === null) === (positioningHint === null));\n    assert(this.state.showPassiveDag === true);\n\n    // remove passive dag\n    this.setState({ showPassiveDag: false});\n\n    if (selectedId !== null) {\n      // switch from currentDag to dag resulting from selecting nodeIdToActivate\n      if (this.props.logging) {\n        console.log(`Removing selection graph. Clause ${selectedId} was selected.`);\n      }\n      await this.selectClause(selectedId, positioningHint!);\n    } else {\n      if (this.props.logging) {\n        console.log(`Removing selection graph. No clause was selected.`);\n      }\n    }\n  }\n\n\n  // NODE SELECTION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  selectParents() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const newSelection = new Set(nodeSelection);\n    for (const nodeId of nodeSelection) {\n      assert(nodesInActiveDag.has(nodeId));\n      for (const parentId of currentDag.get(nodeId).parents) {\n        if(nodesInActiveDag.has(parentId)) {\n          newSelection.add(parentId);\n        }\n      }\n    }\n\n    this.updateNodeSelection(Array.from(newSelection));\n  }\n\n  selectChildren() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const newSelection = new Set(nodeSelection);\n    for (const nodeId of nodeSelection) {\n      assert(nodesInActiveDag.has(nodeId));\n      for (const childId of currentDag.getChildren(nodeId)) {\n        if(nodesInActiveDag.has(childId)) {\n          newSelection.add(childId);\n        }\n      }\n    }\n    this.updateNodeSelection(Array.from(newSelection));\n  }\n\n  selectCommonConsequences() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const commonConsequences = findCommonConsequences(currentDag, new Set(nodeSelection));\n    const newSelection = new Array<number>();\n    for (const nodeId of commonConsequences) {\n      if (nodesInActiveDag.has(nodeId)) {\n        newSelection.push(nodeId);\n      }\n    }\n    this.updateNodeSelection(newSelection);\n  }\n\n  // LITERALS ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  private changeLiteralOrientation(nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) {\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const dag = dags[0];\n    const node = dag.nodes.get(nodeId);\n    assert(node !== undefined);\n    assert(node!.unit.type === \"Clause\");\n    const clause = node!.unit as Clause;\n\n    clause.changeLiteralOrientation(oldPosition, newPosition);\n\n    const changedNodes = computeClauseRepresentation(dag, nodeId);\n    \n    this.setState({changedNodesEvent: changedNodes});\n  }\n\n  private changeLiteralRepresentation(nodeId: number, literal: Literal) {\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const dag = dags[0];\n    const node = dag.nodes.get(nodeId);\n    assert(node !== undefined);\n\n    literal.switchToNextRepresentation();\n    \n    const changedNodes = computeClauseRepresentation(dag, nodeId);\n\n    this.setState({changedNodesEvent: changedNodes});\n  }\n\n  // HELPERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  updateNodePositions(nodeIds: Array<number>, delta: [number, number]) {\n    const dags = this.state.dags\n    assert(this.state.dags.length > 0);\n    const dag = dags[dags.length - 1];\n    for (const nodeId of nodeIds) {\n      const node = dag.get(nodeId);\n      assert(node.position !== null);\n      node.position = [node.position![0] + delta[0], node.position![1] + delta[1]];\n    }\n  }\n\n  // push a new dag on the stack of dags\n  // Precondition: the layout for newDag has already been computed\n  private pushDag(newDag: Dag) {\n    assert(!newDag.isPassiveDag);\n\n    const {dags, nodeSelection} = this.state;\n    \n    // filter out selected nodes which don't occur in new graph\n    const selectedNodesInNewDag = new Array<number>();\n    for (const nodeId of nodeSelection) {\n      if (newDag.nodes.has(nodeId)) {\n        selectedNodesInNewDag.push(nodeId);\n      }\n    }\n\n    this.setState({\n      dags: dags.concat([newDag]),\n      nodeSelection: selectedNodesInNewDag,\n      animateDagChanges: false\n    });\n  }\n\n  private popDag() {\n    assert(this.state.dags.length > 1, \"Undo last step must only be called if there exist at least two dags\");\n\n    this.setState((state, props) => ({\n      dags: state.dags.slice(0, state.dags.length-1),\n      animateDagChanges: false\n    }));\n  }\n\n  setLiteralOptions(dag: Dag) {\n    const hideBracketsAssoc = this.props.hideBracketsAssoc;\n    const nonStrictForNegatedStrictInequalities = this.props.nonStrictForNegatedStrictInequalities;\n\n    for (const node of dag.nodes.values()) {\n      if (node.unit.type === \"Clause\") {\n        const clause = node.unit as Clause;\n        for (const literal of clause.premiseLiterals) {\n          literal.hideBracketsAssoc = hideBracketsAssoc;\n          literal.nonStrictForNegatedStrictInequalities = nonStrictForNegatedStrictInequalities;\n        }\n        for (const literal of clause.conclusionLiterals) {\n          literal.hideBracketsAssoc = hideBracketsAssoc;\n          literal.nonStrictForNegatedStrictInequalities = nonStrictForNegatedStrictInequalities;\n        }\n      }\n    }\n  }\n\n  // STATE TOGGLE //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  toggleInfo() {\n    this.setState({ infoToggle: !this.state.infoToggle });\n  }\n\n  toggleEdit() {\n    this.setState({ editToggle: !this.state.editToggle });\n  }\n}\n\nexport default App;\n","import { Dag } from \"./dag\";\nimport { DFPostOrderTraversal } from \"./traversal\";\n\n// return ids of nodes, which have a derivation where each of the nodes in relevantIds occurs\nexport function findCommonConsequences(dag: Dag, relevantIds: Set<number>): Array<number> {\n\n\t// want to compute common consequences\n\tconst commonConsequences = new Array<number>();\n\n\t// create dictionary which maps the id of each node to the subset of relevantIds occuring in the derivation of the node\n\tconst idToRelevantParentIds = new Map<number, Set<number>>();\n\n\t// add all transitive children of ids in transitiveChildren to transitiveChildren\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst currentNode = iterator.getNext();\n\t\tconst currentNodeId = currentNode.id;\n\n\t\tconst relevantParents = new Set<number>();\n\t\t// compute relevant parents and update dictionary\n\t\tif (relevantIds.has(currentNodeId)) {\n\t\t\trelevantParents.add(currentNodeId);\n\t\t}\n\t\tfor (const parentId of currentNode.parents) {\n\t\t\tconst relevantParentIdsFromParent = idToRelevantParentIds.get(parentId) as Set<number>;\n\t\t\t// merge relevantParentIdsFromParent into relevantParents\n\t\t\tfor (const relevantParentId of relevantParentIdsFromParent) {\n\t\t\t\trelevantParents.add(relevantParentId);\n\t\t\t}\n\t\t}\n\t\tidToRelevantParentIds.set(currentNodeId, relevantParents);\n\n\t\t// check whether each relevant id occurs in relevant parents\n\t\tif (relevantIds.size === relevantParents.size) {\n\t\t\tcommonConsequences.push(currentNodeId);\n\t\t}\n\t}\n\t\n\treturn commonConsequences;\n}","import * as React from 'react';\nimport {NavigationBar} from './NavigationBar';\nimport App, {AppMode} from './App';\nimport './AppWrapper.css';\n\ntype Props = {\n  name: string,\n  problem: string,\n  loadedProblem?: string,\n  loadedProblemName?: string,\n  vampireUserOptions: string,\n  mode: AppMode,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean,\n  orientClauses: boolean,\n  logging: boolean\n};\n\nexport class AppWrapper extends React.Component<Props, {}> {\n\n  private app = React.createRef<App>();\n\n  render() {\n    return (\n      <div id=\"appWrapper\">\n        <NavigationBar\n          name={this.props.mode === AppMode.saved ? `${this.props.loadedProblemName} (read-only)` : this.props.name}\n          onSave={() => this.save()}\n        />\n        <App ref={this.app}\n             problem={this.props.problem}\n             loadedProblem={this.props.loadedProblem}\n             vampireUserOptions={this.props.vampireUserOptions}\n             mode={this.props.mode}\n             hideBracketsAssoc={this.props.hideBracketsAssoc}\n             nonStrictForNegatedStrictInequalities={this.props.nonStrictForNegatedStrictInequalities}\n             orientClauses={this.props.orientClauses}\n             logging={this.props.logging}\n        />\n      </div>\n    )\n  }\n\n  save() {\n    if (!this.app.current) {\n      return;\n    }\n    const saveData = this.app.current.serialize();\n    const element = document.createElement('a');\n    const file = new Blob([saveData], {type: 'text/plain'});\n    element.href = URL.createObjectURL(file);\n    element.download = this.generateFilename();\n    document.body.appendChild(element);\n    element.click();\n  }\n\n  private generateFilename(): string {\n    const prefix = (this.props.name || '').split('.')[0];\n    return `${prefix || 'satvis'}-saved.txt`\n  }\n\n}\n\n  ","import * as React from 'react';\nimport {useHistory} from 'react-router-dom';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\nexport default function LoadSavedProblemButton(props) {\n  const history = useHistory();\n  const fileUpload = React.createRef<HTMLInputElement>();\n\n  function loadSavedProblemData(event: React.ChangeEvent<HTMLInputElement>) {\n    if (event.target.files !== null && event.target.files.length > 0) {\n      const file = event.target.files[0];\n      const reader = new FileReader();\n      // callback which will be executed when readAsText is called\n      reader.onloadend = () => {\n        const text = (reader.result ? reader.result : '') as string;\n        props.onLoadSavedProblemData(text, file.name);\n        history.push('/saved/');\n      };\n      reader.readAsText(file);\n    }\n  }\n\n  return (\n    <section className=\"load-component\">\n      <button\n        className=\"load-button\"\n        type=\"button\"\n        onClick={() => fileUpload.current && fileUpload.current.click()}>\n        <svg viewBox=\"0 0 24 24\" className=\"icon\">\n          <use xlinkHref={`${icons}#save-upload`}/>\n        </svg>\n        <span>Load saved proof</span>\n      </button>\n      <input\n        ref={fileUpload}\n        type=\"file\"\n        onChange={loadSavedProblemData}\n      />\n    </section>\n  );\n}\n","import * as React from 'react';\nimport {Link} from 'react-router-dom';\nimport './Menu.css';\nimport * as Monaco from 'monaco-editor'\nimport {assert} from '../model/util';\nimport LoadSavedProblemButton from './LoadSavedProblemButton';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  problem: string,\n  problemName: string,\n  inputSyntax: 'smtlib' | 'tptp',\n  vampireUserOptions: string,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean,\n  orientClauses: boolean,\n  logging: boolean,\n  onChangeProblem: (problem: string) => void,\n  onChangeProblemName: (problemName: string) => void,\n  onChangeInputSyntax: (syntax: 'smtlib' | 'tptp') => void\n  onChangeVampireUserOptions: (vampireUserOptions: string) => void,\n  onChangeHideBracketsAssoc: (newValue: boolean) => void,\n  onChangeNonStrictForNegatedStrictInequalities: (newValue: boolean) => void,\n  onChangeOrientClauses: (newValue: boolean) => void,\n  onChangeLogging: (newValue: boolean) => void,\n  onLoadSavedProblemData: (problemData: string, filename: string) => void\n}\n\nexport class Menu extends React.Component<Props, {}> {\n  private isChromeOrFirefox = navigator.userAgent.indexOf('Chrome') > -1 || navigator.userAgent.indexOf('Firefox') > -1;\n  private fileUpload = React.createRef<HTMLInputElement>();\n  monacoDiv = React.createRef<HTMLDivElement>();\n  monaco: Monaco.editor.IStandaloneCodeEditor | null = null\n\n  componentDidMount() {\n    if (!this.isChromeOrFirefox) {\n      return;\n    }\n    // generate instance of Monaco Editor\n    this.monaco = Monaco.editor.create(this.monacoDiv.current!, {\n      lineNumbers: 'off',\n      roundedSelection: false,\n      scrollBeyondLastLine: false,\n      scrollBeyondLastColumn: 0,\n      minimap: {\n        enabled: false\n      },\n      renderLineHighlight: 'none',\n      hideCursorInOverviewRuler: true,\n      links: false,\n      overviewRulerBorder: false,\n      automaticLayout: true,\n      lineDecorationsWidth: 0,\n      lineNumbersMinChars: 0,\n      wordWrap: 'wordWrapColumn'\n      // fontFamily: \"Monaco\" TODO: decide which font to use. By default, multiple fonts are loaded, which is quite slow\n    });\n    this.monaco.setValue(this.props.problem);\n    this.monaco.getModel()!.onDidChangeContent(() => {\n      this.props.onChangeProblem(this.monaco!.getModel()!.getValue());\n    });\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    assert(this.isChromeOrFirefox);\n    if (this.props.problem !== prevProps.problem) {\n      this.monaco!.setValue(this.props.problem);\n    }\n  }\n\n  render() {\n    if (!this.isChromeOrFirefox) {\n      return (\n        <section className=\"unsupported-message\">\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#alert-triangle`}/>\n          </svg>\n          <span>Your current browser is not supported. Please use Chrome or Firefox!</span>\n        </section>\n      );\n    }\n\n    return (\n      <section className=\"component-menu\">\n        <h1>Vampire Saturation Visualization</h1>\n\n        <section className=\"editor\">\n          <div className=\"editor-spacer\">\n            <main>\n              <div className=\"headline-wrapper\">\n                <h2>Input</h2>\n                <small className=\"file-name\">{this.props.problemName}</small>\n                <button title=\"Pick a new file\" onClick={this.chooseFile.bind(this)}>\n                  <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n                    <use xlinkHref={`${icons}#graph-upload`}/>\n                  </svg>\n                </button>\n              </div>\n\n              <input\n                ref={this.fileUpload}\n                type=\"file\"\n                onChange={this.uploadEncoding.bind(this)}\n              />\n              <div ref={this.monacoDiv} className=\"monaco\"></div>\n            </main>\n\n            <aside>\n              <fieldset className=\"options-card\">\n                <h3>Vampire Options</h3>\n                <ul>\n                  <li>\n                    <label htmlFor=\"inputSyntax\" className=\"form-label\">Input language</label>\n                    <select id=\"inputSyntax\" onChange={this.changeInputSyntax.bind(this)}\n                            value={this.props.inputSyntax}>\n                      <option value=\"smtlib\">SMTLIB</option>\n                      <option value=\"tptp\">TPTP</option>\n                    </select>\n                  </li>\n                  <li>\n                    <label htmlFor=\"userOptions\" className=\"form-label\">Additional Vampire options</label>\n                    <input id=\"userOptions\" type=\"text\" onChange={this.changeVampireUserOptions.bind(this)}\n                           value={this.props.vampireUserOptions}>\n                    </input>\n                  </li>\n                </ul>\n              </fieldset>\n\n              <fieldset className=\"options-card\">\n                <h3>Visualization Options</h3>\n                <ul>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.hideBracketsAssoc}\n                        onChange={this.changeHideBracketsAssoc.bind(this)}/>\n                      Hide brackets for associative operators\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.nonStrictForNegatedStrictInequalities}\n                        onChange={this.changeNonStrictForNegatedStrictInequalities.bind(this)}/>\n                      Show negated strict inequalities as (positive) nonstrict inequalities\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.orientClauses}\n                        onChange={this.changeOrientClauses.bind(this)}/>\n                      Heuristically orient clauses\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.logging}\n                        onChange={this.changeLogging.bind(this)}/>\n                      Logging enabled\n                    </label>\n                  </li>\n                </ul>\n              </fieldset>\n\n              <div className=\"run-options\">\n                <Link to=\"/proof/\" className=\"fake-button\">Find proof</Link>\n                <Link to=\"/saturation/\" className=\"fake-button\">Find saturation</Link>\n                <Link to=\"/manualcs/\" className=\"fake-button\">Start manual clause selection</Link>\n              </div>\n            </aside>\n          </div>\n        </section>\n\n        <LoadSavedProblemButton onLoadSavedProblemData={this.props.onLoadSavedProblemData}/>\n      </section>\n    );\n  }\n\n  chooseFile() {\n    if (this.fileUpload.current) {\n      this.fileUpload.current.click();\n    }\n  }\n\n  uploadEncoding(event: React.ChangeEvent<HTMLInputElement>) {\n    if (event.target.files !== null && event.target.files.length > 0) {\n      const file = event.target.files[0];\n\n      const reader = new FileReader();\n      // callback which will be executed when readAsText is called\n      reader.onloadend = () => {\n        const text = (reader.result ? reader.result : '') as string;\n        this.props.onChangeProblem(text);\n        this.props.onChangeProblemName(file.name);\n\n        // guess inputSyntax from file extension:\n        if (file.name.endsWith('.smt') || file.name.endsWith('.smtlib') || file.name.endsWith('.smt2') || file.name.endsWith('.smtlib2')) {\n          this.props.onChangeInputSyntax('smtlib');\n        } else if (file.name.endsWith('.tptp')) {\n          this.props.onChangeInputSyntax('tptp');\n        }\n      };\n      reader.readAsText(file);\n    }\n  }\n\n  changeVampireUserOptions(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.value;\n    this.props.onChangeVampireUserOptions(newValue);\n  }\n\n  changeTextArea(event: React.ChangeEvent<HTMLTextAreaElement>) {\n    const newValue = event.target.value;\n    this.props.onChangeProblem(newValue);\n  }\n\n  changeHideBracketsAssoc(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeHideBracketsAssoc(newValue);\n  }\n\n  changeNonStrictForNegatedStrictInequalities(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeNonStrictForNegatedStrictInequalities(newValue);\n  }\n\n  changeInputSyntax(event: React.ChangeEvent<HTMLSelectElement>) {\n    const newValue = event.target.value as 'smtlib' | 'tptp';\n    this.props.onChangeInputSyntax(newValue);\n  }\n\n  changeOrientClauses(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeOrientClauses(newValue);\n  }\n\n  changeLogging(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeLogging(newValue);\n  }\n}\n","import * as React from 'react';\nimport {HashRouter, Route} from 'react-router-dom';\nimport {AppWrapper} from './AppWrapper'\nimport {Menu} from './Menu'\nimport {AppMode} from './App';\n\ntype State = {\n\tproblem: string,\n\tproblemName: string,\n\tinputSyntax: \"smtlib\" | \"tptp\",\n\tvampireUserOptions: string,\n\thideBracketsAssoc: boolean,\n\tnonStrictForNegatedStrictInequalities: boolean,\n\torientClauses: boolean,\n\tlogging: boolean,\n\tloadedProblem?: string,\n\tloadedProblemName?: string\n}\n\nexport class AppRouter extends React.Component<{}, State> {\n\n\tstate: State = {\n\t\tproblem: \"\",\n\t\tproblemName: \"\",\n\t\tinputSyntax: \"smtlib\",\n\t\tvampireUserOptions: \"\",\n\t\thideBracketsAssoc: true,\n\t\tnonStrictForNegatedStrictInequalities: true,\n\t\torientClauses: true,\n\t\tlogging: false\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<HashRouter>\n\t\t\t\t<Route path=\"/\" exact render={() => \n\t\t\t\t\t<Menu \n\t\t\t\t\t\tproblem={this.state.problem}\n\t\t\t\t\t\tproblemName={this.state.problemName}\n\t\t\t\t\t\tinputSyntax={this.state.inputSyntax}\n\t\t\t\t\t\tvampireUserOptions={this.state.vampireUserOptions}\n\t\t\t\t\t\thideBracketsAssoc={this.state.hideBracketsAssoc}\n\t\t\t\t\t\tnonStrictForNegatedStrictInequalities={this.state.nonStrictForNegatedStrictInequalities}\n\t\t\t\t\t\torientClauses={this.state.orientClauses}\n\t\t\t\t\t\tlogging={this.state.logging}\n\t\t\t\t\t\tonChangeProblem={this.changeProblem.bind(this)}\n\t\t\t\t\t\tonChangeProblemName={this.changeProblemName.bind(this)}\n\t\t\t\t\t\tonChangeInputSyntax={this.changeInputSyntax.bind(this)}\n\t\t\t\t\t\tonChangeVampireUserOptions={this.changeVampireUserOptions.bind(this)}\n\t\t\t\t\t\tonChangeHideBracketsAssoc={this.changeHideBracketsAssoc.bind(this)}\n\t\t\t\t\t\tonChangeNonStrictForNegatedStrictInequalities={this.changeNonStrictForNegatedStrictInequalities.bind(this)}\n\t\t\t\t\t\tonChangeOrientClauses={this.changeOrientClauses.bind(this)}\n\t\t\t\t\t\tonChangeLogging={this.changeLogging.bind(this)}\n\t\t\t\t\t\tonLoadSavedProblemData={this.loadSavedProblem.bind(this)}\n\t\t\t\t\t/>\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/proof/\" render={() => \n\t\t\t\t\tthis.appComponent(AppMode.proof)\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/saturation/\" render={() => \n\t\t\t\t\tthis.appComponent(AppMode.saturation)\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/manualcs/\" render={() => \n\t\t\t\t\tthis.appComponent(AppMode.manualcs)\n\t\t\t\t}/>\n        <Route path=\"/saved/\" render={() =>\n          this.appComponent(AppMode.saved)\n        }/>\n\t\t\t</HashRouter>\n\t\t);\n\t}\n\n\tappComponent(mode: AppMode) {\n\t\tconst inputSyntax = this.state.inputSyntax === \"smtlib\" ? \"smtlib2\" : this.state.inputSyntax;\n\t\tconst vampireUserOptions = `${this.state.vampireUserOptions} --input_syntax ${inputSyntax}`;\n\n\t\treturn <AppWrapper\n\t\t\tname={this.state.problemName}\n\t\t\tmode={mode}\n\t\t\tproblem={this.state.problem}\n\t\t\tloadedProblem={this.state.loadedProblem}\n\t\t\tloadedProblemName={this.state.loadedProblemName}\n\t\t\tvampireUserOptions={vampireUserOptions}\n\t\t\thideBracketsAssoc={this.state.hideBracketsAssoc}\n\t\t\tnonStrictForNegatedStrictInequalities={this.state.nonStrictForNegatedStrictInequalities}\n\t\t\torientClauses={this.state.orientClauses}\n\t\t\tlogging={this.state.logging}\n\t\t/>\n\t}\n\n\tchangeProblem(problem: string) {\n\t\tthis.setState({problem: problem});\n\t}\n\tchangeProblemName(problemName: string) {\n\t\tthis.setState({problemName: problemName});\n\t}\n\tchangeVampireUserOptions(vampireUserOptions: string) {\n\t\tthis.setState({vampireUserOptions: vampireUserOptions});\n\t}\n\tchangeHideBracketsAssoc(newValue: boolean) {\n\t\tthis.setState({hideBracketsAssoc: newValue});\n\t}\n\tchangeNonStrictForNegatedStrictInequalities(newValue: boolean) {\n\t\tthis.setState({nonStrictForNegatedStrictInequalities: newValue});\n\t}\n\tchangeInputSyntax(inputSyntax: \"smtlib\" | \"tptp\") {\n\t\tthis.setState({inputSyntax: inputSyntax});\n\t}\n\tchangeOrientClauses(newValue: boolean) {\n\t\tthis.setState({orientClauses: newValue});\n\t}\n\tchangeLogging(newValue: boolean) {\n\t\tthis.setState({logging: newValue});\n\t}\n\n\tloadSavedProblem(problemData: string, filename: string) {\n\t\tthis.setState({loadedProblem: problemData, loadedProblemName: filename})\n\t}\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport './index.css';\nimport { AppRouter } from './components/Router';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <AppRouter/>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}